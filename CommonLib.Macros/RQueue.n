using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CommonLib.Macros
{
  public class RQueue[T] : IEnumerable[T]
  {
    mutable queue : array[T];
    [Accessor]
    mutable write_index : int;
    [Accessor]
    mutable read_index : int;
    
    public this(size : int) {queue = array(size)}
    
    public Enqueue(elem : T) : void
    {
      queue[write_index] = elem;
      write_index++;
      when (write_index == queue.Length) write_index = 0;
    }
    
    public Resize(size : int) : void
    {
      Array.Resize(ref queue, size)
    }
    
    public GetEnumerator() : IEnumerator[T] 
    {
      for (mutable i = read_index; i != write_index; )
      {
        yield queue[i];
        i++;
        when (i == queue.Length) i = 0;
      }
    }
    
    public Deque() : T
    {
      def val = queue[read_index];
      read_index++;
      when (read_index == queue.Length) read_index = 0;
      val
    }
    
    public Count : int
    {
      get
      {
        def diff = write_index - read_index;
        if (diff < 0) diff + queue.Length else diff
      }
    }
    
    public Peek() : T
    {
      queue[read_index]
    }
    
    public ElementAtPos(index : int) : T
    {
      queue[(read_index + index) % queue.Length]
    }
    
    public Item[index : int] : T
    {
      get
      {
        queue[index]
      }
      set
      {
        queue[index] = value
      }
    }
  }
}
