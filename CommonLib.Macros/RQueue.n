using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CommonLib.Macros
{
  public class RQueue[T] : IEnumerable[T]
  {
    mutable queue : array[T];
    [Accessor]
    mutable write_index : int;
    [Accessor]
    mutable read_index : int;
    
    public this(size : int) {queue = array(size)}
    
    public Enqueue(elem : T) : void
    {
      def idx = ThreadSafeUtils.LockFreeUpdateValRet(ref write_index, _ + 1);
      queue[idx % queue.Length] = elem;
    }
    
    public Resize(size : int) : void
    {
      Array.Resize(ref queue, size)
    }
    
    public Empty : bool
    {
      get
      {
        Count == 0
      }
    }
    
    public GetEnumerator() : IEnumerator[T] 
    {
      for (mutable i = read_index; i != write_index; i++)
      {
        yield queue[i % queue.Length];
      }
    }
    
    public Clear() : void
    {
      write_index = 0;
      read_index = 0;
    }
    
    public Deque() : T
    {
      def idx = ThreadSafeUtils.LockFreeUpdateValRet(ref read_index, _ + 1);
      def val = queue[idx % queue.Length];
      queue[idx % queue.Length] = default(T);
      val
    }
    
    public Count : int
    {
      get
      {
        write_index - read_index
      }
    }
    
    public Peek() : T
    {
      queue[read_index % queue.Length]
    }
    
    public ElementAtPos(index : int) : T
    {
      queue[(read_index + index) % queue.Length]
    }
    
    public Item[index : int] : T
    {
      get
      {
        queue[index % queue.Length]
      }
      set
      {
        queue[index % queue.Length] = value
      }
    }
  }
}
