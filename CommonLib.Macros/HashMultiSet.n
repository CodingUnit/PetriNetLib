using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CommonLib.Macros
{
  [Record]
  class Bucket[T]
  {
    public key   : T;
    public count : int {get;set;}
     
    public IndexInItems : int {get;set;}
    public IndexInBuckets : int {get;set;}
    public Empty : bool
    {
      get
      {
        count == 0
      }
    }
      
    public override ToString() : string
    {
      $"($key, $count)"
    }
  }
    
  public class HashMultiSet[T] : IEnumerable[T * int]
  {
    mutable buckets : array[Bucket[T]]  = array(32);
    items           : RQueue[Bucket[T]] = RQueue(32);
    
    public GetEnumerator() : IEnumerator[T * int]
    {
      foreach (cur in items)
      {
        yield (cur.key, cur.count)
      }
    }
    
    public Count : int
    {
      get
      {
        items.Count
      }
    }
    
    factor : double
    {
      get
      {
        1.0 * Count / buckets.Length
      }
    }
    
    Rehash() : void
    {
      buckets = array(buckets.Length * 2);
      items.Resize(buckets.Length);
      foreach (bucket in items)
      {
        AddInternal(bucket)
      }
    }
    
    public this()
    {
    }
    
    public this(vals : IEnumerable[T])
    {
      foreach (item in vals)
      {
        Add(item)
      }
    }
    
    hash1(x : T) : int
    {
      x.GetHashCode() % buckets.Length
    }
    
    hash2(x : T) : int
    {
      def prime = buckets.Length - 1;
      prime - (x.GetHashCode() % prime)
    }
    
    public ElementAtPos(pos : int) : T
    {
      items.ElementAtPos(pos).key
    }
    
    public Contains(k : T, count : int = 1) : bool
    {
      def (e, _) = FindEntry(k);
      e != null && !e.Empty && e.count >= count
    }
    
    AddInternal(bucket : Bucket[T]) : void
    {
      def (_, point) = FindEntry(bucket.key);
      bucket.IndexInBuckets = point;
      buckets[point] = bucket;
    }
    
    public Add(k : T, count : int = 1) : void
    {
      def (entry, point) = FindEntry(k);
      if (entry != null)
      {
        entry.count += count;
      } else
      {
        def bucket = Bucket(k, count, items.WriteIndex, point);
        buckets[point] = bucket;
        items.Enqueue(bucket);
        when (factor >= 0.75) Rehash();
      }
    }
    
    public Remove(k : T, count : int = 1) : void
    {
      def (entry, point) = FindEntry(k);
      when (entry != null)
      {
        if (entry.count > count)
        {
          entry.count -= count;
        } else 
        {
          buckets[point] = null;
          def new_elem = items.Deque();
          when (entry.IndexInItems >= items.ReadIndex)
          {
            new_elem.IndexInItems = entry.IndexInItems;
            items[entry.IndexInItems] = new_elem;
          }
        }
      }
    }
    
    FindEntry(k : T) : Bucket[T] * int
    {
      def probePoint = hash1(k);
      def incr       = hash2(k);
      
      def loop(point)
      {
        def entry = buckets[point];
        if (entry == null || entry.Empty || entry.key.Equals(k)) (entry, point) else loop((point + incr) % buckets.Length)
      }
    
      loop(probePoint)
    }
    
  }
}
