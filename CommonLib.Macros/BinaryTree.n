using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CommonLib.Macros
{
  [Record]
  class TreeNode[T]
  {
    public mutable parent : TreeNode[T];
    public mutable left   : TreeNode[T];
    public mutable right  : TreeNode[T];
    public mutable data   : T;
  }
  /// <summary>
  /// Description of BinaryTree.
  /// </summary>
  public class BinaryHeap[T] where T : IComparable[T]
  {
    mutable heap : array[T] = array(32);
    mutable size : int;

    DoubleSize() : void
    {

    }

    /*
    Depends on what is meant by "random element." If it means that the heap contains elements [e1, e2, ..., eN] and one wants to delete some ei (1 <= i <= N), then this is possible.

If you are using a binary heap implementation from some library, it might be that it doesn't provide you with the API that you need. In that case, you should look for another library that has it.

If you were to implement it yourself, you would need two additional calls:

A procedure deleteAtIndex(heap, i) that deletes the node at index i by positioning the last element in the heap array at i, decrementing the element count, and finally shuffling down/up the new ith element to maintain the heap invariant. The most common use of this procedure is to "pop" the heap by calling deleteAtIndex(heap, 1) -- assuming 1-origin indexing. This operation will run O(log n) (though, to be complete, I'll note that the highest bound can be improved up to O(log(log n)) depending on some assumptions about your elements' keys).

A procedure deleteElement(heap, e) that deletes the element e (your arbitrary element). Your heap algorithm would maintain an array ElementIndex such that ElementIndex[e] returns the current index of element e: calling deleteAtIndex(heap, ElementIndex[e]) will then do what you want. It will also run in O(log n) because the array access is constant.

Since binary heaps are often used in algorithms that merely pop the highest (or lowest) priority element (rather than deleting arbitrary elements), I imagine that some libraries might miss on the deleteAtIndex API to save space (the extra ElementIndex array mentioned above).
    
    */
    BubbleUp(index : int) : void
    {
      when (index != 0) 
      {
        def parent = (index - 1) / 2;
        
        when (heap[parent].CompareTo(heap[index]) > 0)
        {
          def temp = heap[parent];
          heap[parent] = heap[index];
          heap[index] = temp;
          BubbleUp(parent)
        }
      }
    //if(index == 0)
    //    return;

    //int parentIndex = (index-1)/2;

    //if(_vector[parentIndex] > _vector[index])
    //{
    //    int temp = _vector[parentIndex];
    //    _vector[parentIndex] = _vector[index];
    //    _vector[index] = temp;
    //    BubbleUp(parentIndex);
    //}
    }


    public Insert(val : T) : void
    {
      when (size == heap.Length - 1) DoubleSize();
      def pos = size;
      heap[pos] = val;

      BubbleUp(pos);
        /*
        public void insert(Comparable x)
{
	if(size == heap.length - 1) doubleSize();

	//Insert a new item to the end of the array
	int pos = ++size;

	//Percolate up
	for(; pos > 1 && x.compareTo(heap[pos/2]) < 0; pos = pos/2 )
		heap[pos] = heap[pos/2];

	heap[pos] = x;
}
        */
    }
  }
}
