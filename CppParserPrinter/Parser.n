using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Cpp.Grammar;
using Cpp.Grammar.CppGrammarParseTree;
using Nitra;

namespace CppParserPrinter
{
  /// <summary>
  /// Description of Parser.
  /// </summary>
  public class Parser
  {
    parserHost : ParseSession;
    msg : Nitra.ProjectSystem.CompilerMessageList;
    
    public this()
    {
      parserHost = ParseSession(Cpp.Grammar.CppGrammar.Declaration, compilerMessages = msg);
    }
    
    NameToCName(n : Name) : CName
    {
      | Name.Id(Identifier = n)        => CName.String(n.GetText())
      | Name.Splicable(Name = n)       => CName.Splicable(n.GetText())
    }
    
    GetModifier(mod : Modifier) : CMod
    {
      | Modifier.Private => CMod.Private()
      | Protected        => CMod.Protected()
      | Public           => CMod.Public()
    }
    
    GetTypeDecl(decl : TypeDecl) : CTypeDecl
    {
      | TypeDecl.ClassDecl(ClassDecl = ClassDecl(Name = n, BaseOptData = b, BodyData = body)) =>
           
               def get_base(b)
               {
                 def mod = GetModifier(b.Modifier);
                 def name = NameToCName(b.BaseClass);
                 (mod, name) :: []
               }
           
              def decls = body.Map(GetTypeDecl);
              def b = b.Map(get_base).WithDefault([]);
              def name = NameToCName(n);
              CTypeDecl.Type(CComplexType.Class(Some(name), b, decls))
      | TypeDecl.Decl(Decl = Decl(SpecifiersData = s, Type = t, Decls = d, InitOptData = i)) => 
          def spec = s.Map(GetSpecifier);
          def type = GetType(t);
          def init = i.Map(x => x.ConstExpr |> GetConstExpr);
          def decls = d.Map(x => GetDecl(x, init));
          CTypeDecl.Decl(CTree.Decl(spec, type, decls))
    }
    
    GetSpecifier(spec : Specifier) : CSpec
    {
      | Specifier.Typedef  => CSpec.Typedef()
      | Specifier.Const    => CSpec.Const()
      | Specifier.Inline   => CSpec.Inline()
      | Specifier.Extern   => CSpec.Extern()
      | Specifier.Static   => CSpec.Static()
      | Specifier.Virtual  => CSpec.Virtual()
      | Specifier.Volatile => CSpec.Volatile()
      | _                  => null
    }
    
    GetType(t : CppGrammarParseTree.Type) : CType
    {
      | Type.Named(Name = n) => CType.Class(NameToCName(n))
    }
    
    GetDecl(t : TreeDecl, init : option[CConstExpr]) : CDecl
    {
      match (t)
      {
        | TreeDecl.Id(Name = n)                  => CDecl.Id(n |> NameToCName, init)
        | TreeDecl.Array(Name = n, SizeData = s) => CDecl.Array(n |> NameToCName, init, s.Map(int.Parse))
        | TreeDecl.Function(Name = n, ParmsData = (p, _)) => 
            def parms = p.Map(x => (x.Type |> GetType, x.NameOptData.Map(NameToCName)));
            CDecl.Function(n |> NameToCName, init, parms)
        | TreeDecl.Pointer(Name = n) => CDecl.Pointer(n |> NameToCName, init)
        | _ => null
      }
    }
    
    GetConstExpr(expr : ConstExpr) : CConstExpr
    {
      null
    }
    
    ConvertTree(decl : Declaration) : CTree
    {
      | Declaration.TypeDecl(TypeDecl = td) => 
          match (GetTypeDecl(td))
          {
            | CTypeDecl.Type(c) => c |> CTree.Type
            | CTypeDecl.Decl(d) => d
          }
      | Declaration.Decl(Decl = Decl(SpecifiersData = s, Type = t, DeclsData = d, InitOptData = i)) => 
          def spec = s.Map(GetSpecifier);
          def type = t |> GetType;
          def init = i.Map(x => x.ConstExpr |> GetConstExpr);
          def decls = d.Map(GetDecl(_, init));
          CTree.Decl(spec, type, decls)
    }
    
    public Parse(text : string) : CTree
    {
      if (string.IsNullOrWhiteSpace(text)) null else
      {
        def source = SourceSnapshot(text, null : string);
        def result = parserHost.Parse(source);//Main.StateMachine(source, parserHost);
        def ast = result.CreateParseTree();
        if (result.IsSuccess) 
        {
          match (ast)
          {
            | Declaration as a => ConvertTree(a)
            | _                => null
          }
        } else 
        {
          def msg = msg.GetMessages();
          null
          //(null, msg.GetMessages().NToList())
        }
      }
    }
  }
}
