language CPNML
{
  syntax module CpnML.Grammar.Main start rule LangExpr;
  //syntax module Nemerle.Statechart.Grammar.Actions;
  //syntax module Nemerle.Statechart.Grammar.Base;
  //syntax module Nemerle.Statechart.Grammar.Events;
  //syntax module Nemerle.Statechart.Grammar.PseudoStates;
  //syntax module Nemerle.Statechart.Grammar.Regions;
  //syntax module Nemerle.Statechart.Grammar.Targets;
  //syntax module Nemerle.Statechart.Grammar.Transitions;
}

namespace CpnML.Grammar
{

  syntax module Main
  {
    using Base;
	  using Nitra.Core;

    syntax Literal
    {
      | Numeric
      | FloatingNumber
      | String
      | Boolean
      | Char
      | NilList = "nil"
    }

    token Char = '#' '"' Any '"';

    syntax InitExpr
    {
      | Literal
    }

    syntax Oper
    {
		  
    }

    syntax CondExpr
    {
    }

    syntax SimpleExpr
    {
      
    }

    syntax VarRef
    {
      | Var = AnyIdentifier
      | IndexVar
    }

    syntax IndexVar = Name=Identifier '(' Idx=Expr')';

	  //syntax FuncCall

    syntax TypeExpr
    {
      | Int    = "int"
      | Real   = "real"
      | String = "string"
    }

	  syntax Expr
    {
	    | UnitVal = '(' ')'
      | Literal
      
      precedence Type:
      | TypeAnnot = Expr Type
	    | Tuple = '(' Expr ',' Expr (',' Expr)* ')'
      | Record = '{' (Elem;",")* '}'
      {
        syntax Elem = Name=AnyIdentifier '=' Expr;
      }
      precedence Func:
	    | FuncCall   = Name=(Identifier;'.')+ Parms=Expr
	    //| ModuleFunc = Name=(Identifier;'.')+ FuncCall
      | List = '[' (Expr;",")* ']'      
      //| Let = Expr* "in" Expr* "end"
      | Match = "case" Expr "of" (Case;"|")*
      {
        syntax Case = Expr "=>" Expr;
      }
      //| IndexVar
      | Var = Identifier
      //| Lambda = Name=AnyIdentifier Parms=AnyIdentifier* "=>" Expr*
	    precedence ArcDelay:
	    | Delay = Expr '@' '+' Expr

	    precedence Union:
      | SetUnion = Expr "++" Expr// ^ Oper
		  | SetDiff  = Expr "--" Expr
		  
      precedence Token:
      | TokenExpr = Integer '`' Expr// ^ Oper
		  
      //| RecordAccess = !Char '#' AnyIdentifier Expr            
      precedence Conditional:
      | If = "if" Expr ^ Conditional "then" Expr "else" Expr
      precedence And:
      | AndAlso = Expr "andalso" Expr
      precedence Or:
		  | OrElse  = Expr "orelse" Expr
      precedence Equality:
		  | Equal    = Expr '=' Expr
      | NotEqual = Expr "<>" Expr
      precedence Relational:
		  | Above	   = Expr '>' Expr
		  | Below	   = Expr '<' Expr
		  | AboveEqual = Expr ">=" Expr
		  | BelowEqual = Expr "<=" Expr
      precedence Append:
      | Append  = Expr "@" Expr
      | Concat  = Expr '^' Expr
      | ListCombine = Expr "::" Expr
      precedence Additive:
      | Plus	   = Expr '+' Expr
		  | Minus    = Expr '-' Expr
      precedence MulDiv:
      | Multiply = Expr '*' Expr
      | Div      = Expr '/' Expr
      | IntDiv   = Expr "div" Expr
      | Mod      = Expr "mod" Expr
      precedence Not:
      | Not     = "not" Expr
      precedence Sharp:
      | SharpOper = '#' Expr
      precedence Braces:
      | BraceExpr = '(' Expr ')'
      precedence FigBraces:
      | FigBraceExpr = '{' Expr '}'
    }

    syntax Type = ":" TypeExpr;

    syntax Func = "fun" Name=Identifier '(' Parms=(Parm;",")* ')' Type? '=' Body=Expr ';'?
    {
      syntax Parm
      {
        | Var = Identifier Type?
        | IndexVar
      }
    }

	  syntax Declaration
    {
      | Val  = "val" Name=Identifier Type? '=' InitExpr ';'?
      | Func
      
      | FunMatch = !Func "fun" MatchCase+
      {
        syntax MatchCase = Name=Identifier Case "|" (Case;"|")+
        {
          syntax Case = Expr '=' Expr;
        }
      }
    }

	  syntax LangExpr
	  {
		  | Declaration
		  | Expression = !Declaration Expr
	  }
  
  }
}