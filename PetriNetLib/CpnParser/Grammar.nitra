language CPNML
{
  syntax module CpnML.Grammar.Main start rule LangExpr;
  //syntax module Nemerle.Statechart.Grammar.Actions;
  //syntax module Nemerle.Statechart.Grammar.Base;
  //syntax module Nemerle.Statechart.Grammar.Events;
  //syntax module Nemerle.Statechart.Grammar.PseudoStates;
  //syntax module Nemerle.Statechart.Grammar.Regions;
  //syntax module Nemerle.Statechart.Grammar.Targets;
  //syntax module Nemerle.Statechart.Grammar.Transitions;
}

namespace CpnML.Grammar
{

  syntax module Main
  {
    using Base;
	  using Nitra.Core;

    syntax Literal
    {
      | Numeric
      | FloatingNumber
      | String
      | Boolean
      | Char
      | NilList = "nil"
    }

    token Char = '#' '"' Any '"';

    syntax InitExpr
    {
      | Literal
    }

    syntax Oper
    {
		  | SetUnion = TokenExpr "++" TokenExpr
		  | SetDiff  = TokenExpr "--" TokenExpr
		  | Plus	   = Expr '+' Expr
		  | Minus    = Expr '-' Expr
      | Multiply = Expr '*' Expr
      | Div      = Expr '/' Expr
      | IntDiv   = Expr "div" Expr
      | Mod      = Expr "mod" Expr
		  | Equal    = Expr "=" Expr
		  | Above	   = Expr '>' Expr
		  | Below	   = Expr '<' Expr
		  | AboveEqual = Expr ">=" Expr
		  | BelowEqual = Expr "<=" Expr
		  | NotEqual = Expr "<>" Expr
		  | AndAlso = Expr "andalso" Expr
		  | OrElse  = Expr "orelse" Expr
		  | Concat  = Expr '^' Expr
      | Not     = "not" Expr
      | ListCombine = Expr "::" Expr
      | ListAppend  = Expr "@" Expr
      | RecordAccess = !Char '#' AnyIdentifier Expr
    }

    syntax TokenExpr = Integer '`' Expr;
    
    syntax CondExpr
    {
    }

    syntax SimpleExpr
    {
      
    }

    syntax VarRef
    {
      | Var = AnyIdentifier
      | IndexVar
    }

    syntax IndexVar = Name=AnyIdentifier '(' Idx=SimpleExpr')';

	  syntax FuncCall  = Name=AnyIdentifier '(' Parms=(Expr;',')* ')';

    syntax TypeExpr
    {
      | Int    = "int"
      | Real   = "real"
      | String = "string"
    }

	  syntax Expr
    {
	    | UnitVal = '(' ')'
      | BraceExpr = '(' Expr* ')'
      | Literal
      | TokenExpr
      | If = "if" Expr "then" Expr* "else" Expr*
      | Oper
      precedence TypeExpr:
      | TypeAnnot = Expr ':' TypeExpr
      | Var = AnyIdentifier
	    | Tuple = '(' (Expr;",")+ ')'
      | Record = '{' (Elem;",")* '}'
      {
        syntax Elem = Name=AnyIdentifier '=' Expr;
      }
	    | FuncCallML = Name=AnyIdentifier Expr*
	    | FuncCall
	    | ModuleFunc = (AnyIdentifier;'.')+ FuncCall
      | List = '[' (Expr;",")* ']'
      | Let = Expr* "in" Expr* "end"
      | Match = "case" Expr "of" (Case;"|")*
      {
        syntax Case = Expr "=>" Expr*;
      }
      | Lambda = Name=AnyIdentifier Parms=AnyIdentifier* "=>" Expr*
	    precedence ArcDelay:
	    | Delay = Expr '@' '+' Expr*
	  
    }

    syntax Type = ":" TypeExpr;

	  syntax Declaration
    {
      | Val  = "val" Name=AnyIdentifier Type? '=' InitExpr ';'?
      | Func = "fun" Name=AnyIdentifier '(' Parms=(Parm;",")* ')' Type? '=' Body=Expr ';'?
      {
        syntax Parm
        {
          | Var = AnyIdentifier Type?
          | IndexVar
        }
      }
      | FunMatch = "fun" MatchCase*
      {
        syntax MatchCase = Name=AnyIdentifier (Case;"|")*
        {
          syntax Case = Expr '=' Expr;
        }
      }
    }

	  syntax LangExpr
	  {
		  | Declaration
		  | Expr
	  }
  
  }
}