language CPNML
{
  syntax module CpnML.Grammar.Main start rule LangExpr;
  //syntax module Nemerle.Statechart.Grammar.Actions;
  //syntax module Nemerle.Statechart.Grammar.Base;
  //syntax module Nemerle.Statechart.Grammar.Events;
  //syntax module Nemerle.Statechart.Grammar.PseudoStates;
  //syntax module Nemerle.Statechart.Grammar.Regions;
  //syntax module Nemerle.Statechart.Grammar.Targets;
  //syntax module Nemerle.Statechart.Grammar.Transitions;
}

namespace CpnML.Grammar
{

  syntax module Main
  {
    using Base;
	using Nitra.Core;

    syntax Literal
    {
      | Integer
      | FloatingNumber
      | String
    }
    syntax InitExpr
    {
      | Literal
    }

    syntax Oper
    {
		| SetUnion = TokenExpr "++" TokenExpr
		| SetDiff  = TokenExpr "--" TokenExpr
		| Plus	   = Expr '+' Expr
		| Minus    = Expr '-' Expr
		| Equal    = Expr "=" Expr
		| Above	   = Expr '>' Expr
		| Below	   = Expr '<' Expr
		| AboveEqual = Expr ">=" Expr
		| BelowEqual = Expr "<=" Expr
		| NotEqual = Expr "<>" Expr
		| AndAlso = Expr "andalso" Expr
		| OrElse  = Expr "orelse" Expr
		| Concat  = Expr '^' Expr
    }

    syntax TokenExpr = Integer '`' TokenRef
    {
        syntax TokenRef
        {
          | VarRef
          | Literal
        }
    }
    
    syntax CondExpr
    {
    }

    syntax SimpleExpr
    {
      
    }

    syntax VarRef
    {
      | Var = AnyIdentifier
      | IndexVar
    }

    syntax IndexVar = Name=AnyIdentifier '(' Idx=SimpleExpr')';

	syntax FuncCall  = Name=AnyIdentifier '(' Expr* ')';

	syntax Expr
    {
	  | UnitVal = '(' ')'
      | Literal
      | TokenExpr
      | If = "if" Expr "then" Expr "else" Expr
      | Oper
      | Var = AnyIdentifier
	  | Tuple = '(' Expr* ')'
	  | FuncCallML = Name=AnyIdentifier Expr*
	  | FuncCall
	  | ModuleFunc = (AnyIdentifier;'.')+ FuncCall
	  precedence ArcDelay:
	  | Delay = Expr ^ ArcDelay '@' '+' Expr
	  
    }

	syntax Declaration
    {
      | Val  = "val" Name=AnyIdentifier '=' InitExpr ';'
      | Func = "fun" Name=AnyIdentifier '(' Parm* ')' '=' Expr ';'
      {
        syntax Parm
        {
          | Var = AnyIdentifier
          | IndexVar
        }
      }
    }

	syntax LangExpr
	{
		| Declaration
		| Expr
	}
  }
}