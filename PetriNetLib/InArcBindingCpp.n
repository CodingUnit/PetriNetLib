using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;

using System;
using System.Collections.Generic;
using System.Linq;
using PetriNetModel;

namespace PetriNetLib
{
  [Record]
  class InArcBindingCpp
  {
    public place      : GenPlaceCpp;

    public gen : CppGenerator;
    public transition : Transition;
    public Depends     : list[InArcBindingCpp] {get;set;}
      //public NeedBinding : bool {get;set;}

    public priority : int
    {
      [Memoize]
      get
      {
        if (Depends == null || Depends.IsEmpty()) 0 else Depends.Max(_.priority) + 1
      }
    }

    public name       : string
    {
      [Memoize]
      get
      {
        place.Name
      }
    }

    public arc        : Arc;
    
    public arc_kind   : ArcKind
    {
      [Memoize]
      get
      {
        arc.kind
      }
    }
    
    public expr       : PExpr
    {
      [Memoize]
      get
      {
        arc.expr
      }
    }

    public bind_var : string
    {
      [Memoize]
      get
      {
        match (expr)
        {
          | <[ $(n : usesite) ]> => n
          | _                    => null
        }
      }
    }

      //public before_bind_expr  : PExpr
      //{
      //  [Memoize]
      //  get
      //  {
      //    match (expr)
      //    {
      //      | <[ $(_ : usesite)(..$_) ]> => <[ def $(introduced_var : name) = $expr ]>
      //      | _                          => <[]>
      //    }
      //  }
      //}

    public TokenType : string
    {
      [Memoize]
      get
      {
        def gc = place.Colour;
        gc.DestType
      }
    }
    
    public source_token_peek(n : string) : string
    {
        //if (place.IsTimed)
        //{
        //  def name = $"$(name)_tok";
        //    <[ $(name : usesite) ]>
        //} else
      if (place.IsIndexedContainer)
        $<#$name.peek_indexed($n)#> else
        $<#$name.peek()#>
    }

    source_token_name : string
    {
      [Memoize]
      get
      {
        $"$(name)_tok"
      }
    }
    
    public timed_bind_expr : string
    {
      [Memoize]
      get
      {
        if (place.IsTimed)
        {
          match (expr)
          {
            | <[ $(n : usesite) ]> => def ty = TokenType;
                                      if (place.IsIndexedContainer) 
                                      {
                                          $<#int $(idx_name(n));
                                          $ty $source_token_name = $(source_token_peek(n));#>
                                      } else
                                      {
                                          $<#$ty $source_token_name = $(source_token_peek(n));#>
                                      }
            | _                     => ""
          }
          
        } else
        {
          ""
        }
      }
    }

    idx_name(name : string) : string
    {
      $"$(name)_idx"
    }
    
    public bind_expr  : string
    {
      [Memoize]
      get
      {
        if (place.IsTimed)
        {
          def time_expr = timed_bind_expr;
          def bind_expr = match (expr)
          {
            
            | <[ $(n : usesite) ]> => 
              def ty = gen.TypeOfVar(n);
              $<#$ty $expr = $source_token_name;#>
            | _                    => ""
          }
          $<#$time_expr; $bind_expr;#>
        } else
        match (expr)
        {
//          | <[ () ]>             => <[]>
          | <[ $(n : usesite) ]> => def ty = gen.TypeOfVar(n);
                                    if (place.IsIndexedContainer) 
                                    {
                                      def idx = idx_name(n);
                                      $<# int $idx;
                                          $ty $n = $(source_token_peek(idx));#>
                                    } else
                                        $<#$ty $n = $(source_token_peek("")); #>
          | _                    => ""
        }
      }
    }

      //public introduced_var : Name
      //{
      //  [Memoize]
      //  get
      //  {
      //    match (expr)
      //    {
      //      | <[ $(n : usesite)(..$_) ]> => Macros.NewSymbol(n.Substring(0, 2));
      //      | _                          => null
      //    }
      //  }
    unfold(e : PExpr) : string
    {
      | <[ () ]> => <#unit.instance()#>
      | e        => e |> gen.ConvExpr(_, false)
    }
        
        //match (expr)
        //{
        //  | <[ () ]>                       => <[ Unit.Instance ]> 
        //  | <[ $e %@+ $(time : int)]>      => match (global_time)
        //                                      {
        //                                        | <[ $(t : int)]> => def time = time + t;     
        //                                                             <[ $(unfold(e)) %@+ $time]>
        //                                      } 
                                              
        //  | <[ $e %@+ $time]>              => <[ $(unfold(e)) %@+ ($time + $global_time)]>
      //}

    public IsInhibitor : bool
    {
      [Memoize]
      get
      {
        arc_kind == ArcKind.Inhibitor
      }
    }
    
    public check_expr : string
    {
      [Memoize]
      get
      {
        def check_func(e)
        {
          | <[ 1 ` $expr]>      => expr |> check_func
          | <[ () ]>            => $<#$name.have_tokens()#>
          | <[ $e %@+ $time]>   => $<#$name.have_relative_time($(unfold(e)), $time)#>
          | <[ $(_ : usesite)]> => $<#$name.have_tokens()#>
          | _                   => def tok = Generator.GetTokenExpr(expr);
                                   $<#$name.have($tok)#>
        }
        
        def cont_proc(other)
        {
          match (place.DestContainerType)
          {
            | Var 
            | ReqContainer => ""
            | Single       => $<#$(name)_flag#>
            | ZeroSingle   => $<#$(name) == 0#>
            | MinusSingle  => $<#$(name) == -1#>
            | _            => other()
          }
        }
        
        match (arc_kind)
        {
          | ArcKind.Normal    => cont_proc(_ => check_func(expr))
          | ArcKind.Inhibitor => cont_proc(_ => $<#!$name.have_tokens()#>)
          | _                 => ""
        }
      }
    }
    public extract_expr   : string
    {
      [Memoize]
      get
      {
        def extract(e)
        {
            //| <[ $e %@+ $time ]>  => <[]>
          | <[ 1 ` $expr]>      => extract(expr)
          | <[ $e %@+ $time]>   => $<#$name.get_relative_time($(unfold(e)), $time);#>
          | <[ () ]>            => $<#$name.get();#>
          | <[ $(n : usesite)]> => if (place.IsIndexedContainer) 
                                    $<#$name.get_indexed($(idx_name(n)));#> else 
                                    $<#$name.get($expr);#>
          | _                   => $<#$name.get($expr);#>
        }
        
        def cont_proc(other)
        {
          match (place.DestContainerType)
          {
            | Var 
            | ReqContainer => ""
            | Single       => $<#$(name)_flag = false;#>
            | ZeroSingle   => $<#$(name) = 0;#>
            | MinusSingle  => $<#$(name) = -1;#>
            | _            => other()
          }
        }
        
        match (arc_kind)
        {
         | ArcKind.Normal         => cont_proc(_ => extract(expr))
         | ArcKind.Reset          => cont_proc(_ => $<#$name.get_all()#>)
         | _                      => ""
        }
      }
    }

  }
}
