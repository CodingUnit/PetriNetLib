using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Macro;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections.Immutable;
using CommonLib.Macros;
using Nemerle.Compiler.Parsetree;

namespace PetriNetLib
{
  
  //using Nemerle.Builtins.Function;
  
  //[Lens]
  //[Record]
  //public class Colour
  //{
  //  public idx  : int;
  //  public type : Type;
  //}
  
  [Record]
  public class Token
  {
    public value  : object;//TokenVal[Colour];
    public colour : Colour;
    
    public this(val : object)
    {
      value = val;
      //colour = Colour(-1, val.GetType());
    }
    
  }
  
  [Record]
  [Lens]
  public class Place
  {
    public idx    : int;
    public name   : string;
    public colour : Colour;
    
    public init_mark : PExpr;
    public tree      : CpnTree.Place;
    public net       : PetriNet;
      
    public override GetHashCode() : int
    {
      idx
    }
  }
  
  [Record]
  public class TokenSet
  {
    public num   : int;
    public token : Token;
  }
  
  [Record]
  [Lens]
  public class Transition
  { 
    public idx : int;
    public name : string;
    public guard : PExpr;
    
    public time_expr : PExpr;
    public code_segment : PExpr;
    public priority : int;
    public net : PetriNet;
    
    public override GetHashCode() : int
    {
      idx
    }
  }
  
  [Record]
  [Lens]
  public class Arc
  { 
    public expr : PExpr;
    
  }
  
  public class ColourSet
  {
    public name : string;
    public type : Colour;
  }
  
  public variant ExecError
  {
    | TokenConstantNotFound { place : Place; val : object }
    | VarNotFound {name : string}
    | TypeTokenNotCompat {incol : Colour; outcol : Colour;place : Place}
  }
  
  [Lens]
  [Record]
  public class TransitionExecContext
  {
    public binding : Hashtable[string, Token];
    public tokens  : list[Token];
    public error   : list[ExecError];
    
    public all_getted_tokens : list[Token]
    {
      get
      {
        []
      }
    }
  }
  
  public class PetriNet
  {
    mutable places      : array[Place];
    mutable transitions : array[Transition];
    public  vars        : Hashtable[string, Colour] = Hashtable();
    public  colour_sets : Hashtable[string, Colour] = Hashtable();
    mutable ml_decls : list[PExpr];
    
    tree_places : list[CpnTree.Place];
    tree_tran   : list[CpnTree.Transition];
    tree_arcs   : list[CpnTree.Arc];
    tree_decls  : list[CpnDecl];
    
    matrix_len         : array[int] = array[];
    mutable input_matrix       : array[3, Arc];//List[List[List[Arc]]];
    mutable output_matrix      : array[3, Arc];
    mutable incidence_matrix   : array[3, int];
    colours            : list[Colour] = [];
    converter          : Converter = Converter();
    
    //InputTransitionArcs : list[Transition * list[Place * Arc]]
    //{
    //  [Memoize]
    //  get
    //  {
    //    OutputArcs.GroupBy((_, t, _) => t).Map(x => (x.Key, x.Map((p, _, a) => (p, a))));
    //  }
    //}
    
    //InputArcs : IEnumerable[Place * Transition * Arc]
    //{
    //  [Memoize]
    //  get
    //  {
    //    foreach (c in Enumerable.Range(0, colours.Length))
    //    {
    //      foreach (p in Enumerable.Range(0, places.Length))
    //      {
    //        foreach (t in Enumerable.Range(0, transitions.Length))
    //        {
    //          def arc = input_matrix[p, t, c];
    //          if (arc != null)
    //            yield (places[p], transitions[t], arc) else ()
    //        }
    //      }
    //    }
    //   }
    //}

    TranOutputArcs(tran : Transition) : IEnumerable[Place * Arc]
    {
      null
      //InputArcs.Where((_, t, _) => t : object == tran).Select((p, _, a) => (p, a))
    }
    
    //OutputArcs : IEnumerable[Place * Transition * Arc]
    //{
    //  [Memoize]
    //  get
    //  {
    //    foreach (c in Enumerable.Range(0, colours.Length))
    //      foreach (p in Enumerable.Range(0, places.Length))
    //        foreach (t in Enumerable.Range(0, transitions.Length))
    //        {
    //          def arc = output_matrix[p, t, c];
    //          when (arc != null)
    //            yield (places[p], transitions[t], arc)
    //        }
    //   }
    //}
    
    //arcs               : List[List[Arc]] = List();
    //transition_input_matrix  : List[List[int]];
    //transition_output_matrix : List[List[int]];
    //place_arcs               : List[List[Arc]];
    //transition_arcs          : List[List[Arc]];
    
    //place_idx : int;
    //transition_idx : int;
    //colour_idx : int;
    
    //GetEdgesNull(count : int) : List[List[Arc]]
    //{
    //  ListUtils.Init(count, _ => null).ToList()
    //}
    
    //GetEmptyMatrix(count : int) : IEnumerable[List[List[Arc]]]
    //{
    //  Enumerable.Repeat(ListUtils.Init(places.Count, _ => null).ToList(), count)
    //}
    
    BuildMatrix() : void
    {
      def col    = colours.Length;
      def places = places.Length;
      def tran   = transitions.Length;
      
      
      when (matrix_len.Length == 0 || matrix_len[0] != col || matrix_len[1] != places || matrix_len[2] != tran)
      {
        input_matrix = array(col, places, tran);
        output_matrix = array(col, places, tran);
        incidence_matrix = array(col, places, tran);
      
        for (mutable c = 0; c < col; c++)
          for (mutable p = 0; p < places; p++)
            for (mutable t = 0; t < tran; t++)
            {
              def output = if (output_matrix[c, p, t] != null) 1 else 0; 
              def input = if (input_matrix[c, p, t] != null) 1 else 0; 
              incidence_matrix[c, p, t] = output - input;
            }
      }
    }
    
    public this(places : list[CpnTree.Place], tran : list[CpnTree.Transition], arcs : list[CpnTree.Arc], decls : list[CpnDecl])
    {
      tree_places = places;
      tree_tran = tran;
      tree_arcs = arcs;
      tree_decls = decls;
    }
    
    public Process() : void
    {
      mutable pidx : int = 0;
      mutable tidx : int = 0;
      
      def create_place(p)
      {
        | CpnTree.Place(n, t, i) =>
        def col = colour_sets[t];
        def expr = i |> converter.ParseML;
        def place = Place(pidx, n, col, expr, p, this);
        pidx += 1;
        place
      }
      
      def create_tran(t)
      {
        | CpnTree.Transition(n, g, t) =>
        
        def guard = g.Map(converter.ParseML).WithDefault(<[]>);
        def time  = t.Map(converter.ParseML).WithDefault(<[]>);
        Transition(tidx, n, guard, time, null, 0, this)
      }
      
      def create_arcs(a)
      {
        | CpnTree.Arc(t) => 
          def expr = converter.ParseML(t);
          Arc(expr)
      }
      
      def (color, decls) = tree_decls.PartitionType();
      foreach (d : CpnDecl.ColorSet in color)
      {
        colour_sets[d.name] = d.type
      }
      
      foreach (d in decls)
      {
        | CpnDecl.Var(i, c) => vars[i] = colour_sets[c]
        | ML(str)           => def expr = converter.ParseML(str);
                               ml_decls ::= expr
        | _                 => ()
      }
      
      places      = tree_places.MapToArray(create_place);
      transitions = tree_tran.MapToArray(create_tran);
      def arcs    = tree_arcs.MapToArray(create_arcs);
    }
    //public AddColour(col : Colour) : PetriNet
    //{
    //  def col = Colour.idx_lens.Set(col, colours.Length);
    //  //col.idx = colour_idx;
      
    //  PetriNet.colours_lens.Update(_, col :: _)
    //}
    
    //public AddPlace(place : Place) : Place
    //{
    //  def place = Place.idx_lens.Set(place, places.Count);
    //  places = places.Add(place);
    //  place
    //}
    
    //public AddTransition(tran : Transition) : Transition
    //{
    //  def tran = Transition.idx_lens.Set(tran, transitions.Count);
    //  transitions = transitions.Add(tran);
    //  tran
    //}
    
    //public AddArc(place : Place, arc : Arc, tran : Transition) : void
    //{
    //  def idx  = place.idx;
    //  def tidx = tran.idx;
    //  def cidx = arc.colour.idx;
    //  output_matrix[cidx, idx, tidx] = arc;
    //}
    
    //public AddArc(tran : Transition, arc : Arc, place : Place) : void
    //{
    //  def idx  = place.idx;
    //  def tidx = tran.idx;
    //  def cidx = arc.colour.idx;
    //  input_matrix[cidx, idx, tidx] = arc;
    //}
    
    // public AddToken(place_idx : int, tok : Token) : void
    // {
    //   def set_tok(t)
    //   {
    //     Place.marking_lens.Update(t[place_idx], tok :: _) |> t.SetItem(place_idx, _)
    //   }
       
    //   ThreadSafeUtils.LockFreeUpdate(ref places, set_tok)
    //   //places[place_idx] = place;
    // }
     
    // public AddToken(place : Place, tok : Token) : void
    // {
       
    // }
     
    // TypeCompatible(col : Colour, col_out : Colour) : bool
    // {
    //   false
    // }
     
    // RemoveTokens(places : list[Place * Arc]) : TransitionExecContext * list[Place]
    // {
    //   mutable tokens = [];
    //   mutable err = [];
    //   mutable binding = [];
       
    //   def get_tokens(place, arc) : list[Token]
    //   {
    //     def marking = place.marking;
    //     match (arc.expr)
    //     {
    //       | ArcExpr.Constant(v) => if (marking.Find(x => x.value.Equals(v)) is Some(tok))
    //                                {
    //                                  tokens ::= tok;
    //                                  marking.Remove(tok)
    //                                } else
    //                                {
    //                                  err ::= ExecError.TokenConstantNotFound(place, v);
    //                                  marking
    //                                }
    //       | Var(n)              => if (decls.vars.Contains(n))
    //                                {
    //                                  def type = decls.vars[n];
    //                                  if (TypeCompatible(place.colour, type))
    //                                  {
    //                                    binding ::= (n, marking.Head);
    //                                    marking.Tail
    //                                  } else
    //                                  {
    //                                    err ::= ExecError.TypeTokenNotCompat(place.colour, type, place);
    //                                    marking
    //                                  }
    //                                } else
    //                                {
    //                                  err ::= ExecError.VarNotFound(n);
    //                                  marking
    //                                }
    //       | NumTok(n, Constant(t)) => def tok = marking.Filter(x => x.value.Equals(t));
    //                                   if (tok.Length >= n)       
    //                                   {
    //                                     def tok = tok.Take(n);
    //                                     tokens += tok.NToList();
    //                                     marking.Except(tok).NToList()
    //                                   } else
    //                                   {
    //                                     err ::= ExecError.TokenConstantNotFound(place, t);
    //                                     marking
    //                                   }
    //       | _                        => throw InvalidOperationException("unimplemented expression")
    //       //| Tuple(t)               => 
    ////       | Constant { val : object; }
    ////| NumTok { num : int; tok : ArcExpr; }
    ////| Var { n : string; }
    ////| Tuple { tup : list[ArcExpr];}
    ////| ListExpr {expr : ListExpr;}
    ////| Delay { expr : ArcExpr; delay : ArcExpr; }
    ////| IfThen { expr : CondExpr; then : ArcExpr; els : ArcExpr; }
    ////| Func { name : string; parms : list[ArcExpr]; }
    //     }
    //   }
       
    //   def new_marking = places.Map(x => (x[0], get_tokens(x)));
    //   def places = new_marking.Map(Place.marking_lens.Set);
    //   (TransitionExecContext(Hashtable(binding), tokens, err), places)
    // }
     
    // AddTokens(tran_ctx : TransitionExecContext, places : IEnumerable[Place * Arc]) : list[Place]
    // {
    //   mutable tok = tran_ctx.tokens;
    //   mutable binding = tran_ctx.binding;
       
    //   def eval(e)
    //   {
    //     | ArcExpr.Constant(c) => c
    //     | Var(n)              => binding[n].value
    //   }
       
    //   def get_tok(expr : ArcExpr) : option[TokenSet]
    //   {
    //       | ArcExpr.Constant(c) => c |> Token |> TokenSet(1, _) |> Some
    //       | Var(n)              => if (binding.Contains(n))
    //                                {
    //                                  binding[n] |> TokenSet(1, _) |> Some
    //                                } else
    //                                {
    //                                  None()
    //                                }
    //       | BinaryOperator(op) => def left  = op.left  |> eval;
    //                               def right = op.right |> eval;
    //                               def res  = match (op)
    //                                          {
    //                                            | BinaryOper.Mul => match (left, right)
    //                                                                {
    //                                                                  | (l is int, r is int) => Some(l * r)
    //                                                                  | _                    => None()
    //                                                                }
    //                                            | Add            => match (left, right)
    //                                                                {
    //                                                                  | (l is int, r is int) => Some(l + r)
    //                                                                  | _                    => None()
    //                                                                }
    //                                          }
    //                               res.Map(x => TokenSet(1, Token(x)))
    //       | NumTok(n, t)      => get_tok(t).Map(x => TokenSet(n * x.num, x.token))
                                  
    //   }
       
    //   def add_tok(a : ArcExpr) : option[TokenSet]
    //   {
    //     get_tok(a)
    //   }
       
    //   def tokens = places.MapLazy((p, a) => (p, add_tok(a.expr).Value));
    //   null
    // }
       
    // public Step() : void
    // {
    //   def input_places_contains_tokens = InputTransitionArcs.Where((t, a : list[_]) => a.All((p, _) => !p.marking.IsEmpty()));
    //   def places = input_places_contains_tokens.SelectMany((_, l) => l.Select((p, _ : Arc) => p));
    //   foreach ((t, p) in input_places_contains_tokens)
    //   {
    //     def (tran_ctx, places) = RemoveTokens(p);
    //     def out_acs = TranOutputArcs(t);
         
    //     //t.ChangeContext()
    //   }
    //   // забираем токены из входных позиций и передаем в выходные позиции перехода
    //   //OutputArcs.Where((p, t, a) => !p.marking.IsEmpty());
    // }
  }
}
