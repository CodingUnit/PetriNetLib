using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using CommonLib.Macros;


namespace PetriNetLib
{
  
  [Record]
  public variant Colour
  {
    | List {type : string; with_range : int * int;}
    | Union { types : list[string * string]}
    | Product {tuple : list[string]}
    | Record {vals : list[string * string]}
    | Index {min : string; max : string;id : string}
    | SubsetBy { name : string; by : string}
    | SubsetWith { name : string; with_list : list[string]}
    | Enum {vals : list[string]}
    | Unit {with_new_name : option[string]}
    | Bool {with_new : option[string * string]}
    | Integer {with_range : option[string * string]}
    | Simple {type : string}
    | Alias {name : string}
    | String { str_with : char * char; str_and : option[char * char];} 
  }
  
  [Record]
  public variant CpnDecl
  {
    | ML {str : string;}
    | Var {id : string; type : string;}
    | ColorSet
    {
      name : string;
      type : Colour;
    }
  }
  
  [Record]
  public variant CpnTree
  {
    | Declaration {decl : list[CpnDecl]}
    | Place {name : string; id : string; type : string; init_mark : string;}
    | Transition {name : string; id : string;guard : option[string];time : option[string];}
    | Arc {text : string;from : string; to : string;p2t : bool;}
  }
  
  /// <summary>
  /// Description of Parser.
  /// </summary>
  public class Parser
  {
    mutable xml : XmlDocument;
    
    [Accessor]
    mutable decls : list[CpnDecl];
    
    [Accessor]
    mutable places : list[CpnTree.Place];
    [Accessor]
    mutable transitions : list[CpnTree.Transition];
    [Accessor]
    mutable arcs : list[CpnTree.Arc];
    
    
    parse_color(col : XmlElement) : CpnDecl
      {
        def name = col.GetOneText("id");
        def set = if (col.Contains("index"))
        {
          def range = col.GetText("index", "ml");
          def type  = col.GetOneText("index", "id");
          Colour.Index(range[0], range[1], type)
        } else 
        if (col.Contains("alias"))
        {
          def alias = col.GetOneText("alias", "id");
          Colour.Alias(alias)
        } else
        if (col.Contains("product"))
        {
          def vals = col.Get("product", "id");
          Colour.Product(vals.Map(_.InnerText))
        } else
        if (col.Contains("record"))
        {
          def fields = col.Get("record", "recordfield");
          
          def get_fields(x)
          {
            def arr = x.GetText("id");
            (arr[0], arr[1])
          }
          
          def fields = fields.Map(get_fields);
          Colour.Record(fields)
        }
        else
        if (col.Contains("enum"))
        {
          def en = col.GetText("enum", "id");
          Colour.Enum(en.NToList())
        } else
        if (col.Contains("unit"))
        {
          def new_name = col.GetOneTextOpt("int", "with", "id");
          Colour.Unit(new_name)
        } else
        if (col.Contains("bool"))   Colour.Simple("bool")   else
        if (col.Contains("int"))    
        {
          def wit = col.GetText("int", "with", "ml").ToArray();
          def wit = if (wit.IsEmpty()) None() else (wit[0], wit[1]) |> Some;
          Colour.Integer(wit)
        } else
        if (col.Contains("intinf")) Colour.Simple("intinf") else
        if (col.Contains("time"))   Colour.Simple("time")   else
        if (col.Contains("real"))   Colour.Simple("real")   else
        if (col.Contains("string")) Colour.Simple("string") else
        null;
        CpnDecl.ColorSet(name, set)
      }
      
    public Parse(file : string) : void
    {
      xml = XmlDocument();
      xml.Load(file);
      def glob = xml.GetChilds("workspaceElements", "cpnet", "globbox");
      def blocks = glob.GetChilds("block");
      def glob = glob.Concat(blocks);
      def ml_decls = glob.GetFirstChildText("ml");
      decls = ml_decls.Map(x => CpnDecl.ML(x));
      def var_tags = glob.Get("var");
      def color = glob.Get("color");
      
      decls += color.Map(parse_color);
      
      def get_places(p)
      {
        def id = p.GetAttrText("id");
        def name = p.GetOneText("text");
        def type = p.GetOneText("type", "text");
        def initmark = p.GetOneText("initmark", "text");
        def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
        CpnTree.Place(name, id, type, initmark)
      }
      
      def get_tran(p)
      {
        def id = p.GetAttrText("id");
        def name = p.GetOneText("text");
        def guard = p.GetOneTextOpt("cond", "text");
        def time  = p.GetOneTextOpt("time", "text");
        def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
        CpnTree.Transition(name, id, guard, time)
      }
      
      def get_arc(a)
      {
        def annot = a.GetOneText("annot", "text");
        def p2t   = a.GetAttrText("orientation") == "PtoT";
        def trans  = a.GetOne("transend").GetAttrText("idref");
        def place  = a.GetOne("placeend").GetAttrText("idref");
        def (from, to) = if (p2t) (place, trans) else (trans, place);
        CpnTree.Arc(annot, from, to, p2t)
      }
      
      decls += color.Map(parse_color);
      //decls = idx_color.Map((x, r, i) => CpnDecl.ColorSet(x.InnerText, Color.Index(r.First().InnerText |> int.Parse, r.Skip(1).First().InnerText |> int.Parse, i.First().InnerText)));
      def var = var_tags.Map(x => CpnDecl.Var(x.GetOneText("id"), x.GetOneText("type", "id")));
      decls += var;
      def page = xml.GetChilds("workspaceElements", "cpnet", "page");
      def places = page.Get("place");
      this.places = places.Map(get_places);
      def tran   = page.Get("trans");
      transitions   = tran.Map(get_tran);
      arcs          = page.Get("arc").Map(get_arc);
    }
  }
}
