using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using CommonLib.Macros;


namespace PetriNetLib
{
  
  [Record]
  public variant Colour
  {
    | List {type : string; with_range : int * int;}
    | Union { types : list[string * string]}
    | Product {tuple : list[string]}
    | Record {vals : list[string * string]}
    | Index {min : string; max : string;id : string}
    | SubsetBy { name : string; by : string}
    | SubsetWith { name : string; with_list : list[string]}
    | Enum {vals : list[string]}
    | Simple
    | StringWith { str_with : char * char; str_and : option[char * char];} 
  }
  
  [Record]
  public variant CpnDecl
  {
    | ML {str : string;}
    | Var {id : string; type : string;}
    | ColorSet
    {
      name : string;
      type : Colour;
    }
  }
  
  [Record]
  public variant CpnTree
  {
    | Declaration {decl : list[CpnDecl]}
    | Place {name : string; id : string; type : string; init_mark : string;}
    | Transition {name : string; id : string;guard : option[string];time : option[string];}
    | PlaceToTranArc {text : string;from : string; to : string;}
    | TranToPlaceArc {text : string;from : string; to : string;}
  }
  
  /// <summary>
  /// Description of Parser.
  /// </summary>
  public class Parser
  {
    mutable xml : XmlDocument;
    
    [Accessor]
    mutable decls : list[CpnDecl];
    
    [Accessor]
    mutable places : list[CpnTree.Place];
    [Accessor]
    mutable transitions : list[CpnTree.Transition];
    [Accessor]
    mutable arcs : list[CpnTree.Arc];
    
    public static Get[T](this xml : XmlDocument, params path : array[string]) : IEnumerable[XmlElement]
    {
      Get(xml.ChildNodes.OfType(), path)
    }
    
    public static GetChilds[T](this xml : XmlDocument, params path : array[string]) : IEnumerable[XmlElement]
    {
      Get(xml.ChildNodes.OfType(), path).SelectMany(x => x.ChildNodes.OfType())
    }
    
    public static GetChilds[T](this xml : XmlElement, params path : array[string]) : IEnumerable[XmlElement]
    {
      Get(xml.ChildNodes.OfType(), path).SelectMany(x => x.ChildNodes.OfType())
    }
    
    public static Contains(this path : XmlElement, elem : string) : bool
    {
      path.ChildNodes.OfType().Exists(x : XmlElement => x.Name == elem)
    }
    
    public static GetText(this parent : XmlElement, params elem : array[string]) : IEnumerable[string]
    {
      Get(parent, elem).Select(x => x.InnerText)
    }
    
    public static GetOneText(this parent : XmlElement, params elem : array[string]) : string
    {
      GetOne(parent, elem).InnerText
    }
    
    public static GetOneTextOpt(this parent : XmlElement, params elem : array[string]) : option[string]
    {
      GetOneOpt(parent, elem).Map(_.InnerText)
    }
    
    public static GetText(this parent : IEnumerable[XmlElement], params elem : array[string]) : IEnumerable[string]
    {
      parent.Get(elem).Select(_.InnerText)
    }
    
    public static GetOne(this parent : XmlElement, params elem : array[string]) : XmlElement
    {
      parent.Get(elem).First()
    }
    
    public static GetOneOpt(this parent : XmlElement, params elem : array[string]) : option[XmlElement]
    {
      def lst = parent.Get(elem);
      if (lst.IsEmpty()) None() else lst.First() |> Some
    }
    
    public static Get(this path : IEnumerable[XmlElement], params elem : array[string]) : IEnumerable[XmlElement]
    {
      def loop(p, child : IEnumerable[XmlElement])
      {
        match (p)
        {
          | []           => Enumerable.Empty()
          | head :: []   => child.Where(x => x.Name == head)
          | head :: tail => def inner = child.Filter(x => x.Name == head);
                            inner.SelectMany(x => loop(tail, x.ChildNodes.OfType()))
        }
      }
      
      loop(elem.NToList(), path)
    }
    
    public static Get(this path : XmlElement, params elem : array[string]) : IEnumerable[XmlElement]
    {
      Get(path.ChildNodes.OfType(), elem)
    }
    
    public Parse(file : string) : void
    {
      xml = XmlDocument();
      xml.Load(file);
      def glob = xml.GetChilds("workspaceElements", "cpnet", "globbox");
      def ml_decls = glob.GetText("ml");
      decls = ml_decls.Map(x => CpnDecl.ML(x));
      def var_tags = glob.Get("var");
      def color = glob.Get("color");
      
      def parse_color(col)
      {
        def name = col.GetOneText("id");
        def set = if (col.Contains("index"))
        {
          def range = col.Get("index", "ml").MapToArray(x => x.InnerText);
          //def range = range.Select(x => int.Parse(x)).ToArray();
          def type  = col.GetOneText("index", "id");
          Colour.Index(range[0], range[1], type)
        } else 
        if (col.Contains("product"))
        {
          def vals = col.Get("product", "id");
          Colour.Product(vals.Map(_.InnerText))
        } else
        if (col.Contains("record"))
        {
          def rec = col.GetChilds("record");
          def fields = rec.Get("recordfield");
          def fields = fields.Map(x => x.GetText("id").ToArray());
          def fields = fields.Map(x => (x[0], x[1]));
          Colour.Record(fields)
        }
        else
        {
          null
        }
        CpnDecl.ColorSet(name, set)
        //null : CpnDecl.ColorSet
        //Parse(x, ["id"]);
        //.First(), Parse(x, ["index", "ml"]), Parse(x, ["index", "id"]))).Where((_, x, _) => !x.IsEmpty()
      }
      
      def get_places(p)
      {
        def name = p.GetOneText("text");
        def type = p.GetOneText("type", "text");
        def initmark = p.GetOneText("initmark", "text");
        CpnTree.Place(name, type, initmark)
      }
      
      def get_tran(p)
      {
        def name = p.GetOneText("text");
        def guard = p.GetOneTextOpt("cond", "text");
        def time  = p.GetOneTextOpt("time", "text");
        CpnTree.Transition(name, guard, time)
      }
      
      def get_arc(a)
      {
        def annot = a.GetOneText("annot", "text");
        CpnTree.Arc(annot)
      }
      
      decls += color.Map(parse_color);
      //decls = idx_color.Map((x, r, i) => CpnDecl.ColorSet(x.InnerText, Color.Index(r.First().InnerText |> int.Parse, r.Skip(1).First().InnerText |> int.Parse, i.First().InnerText)));
      def var = var_tags.Map(x => CpnDecl.Var(x.GetOneText("id"), x.GetOneText("type", "id")));
      decls += var;
      def page = xml.GetChilds("workspaceElements", "cpnet", "page");
      def places = page.Get("place");
      this.places = places.Map(get_places);
      def tran   = page.Get("trans");
      transitions   = tran.Map(get_tran);
      arcs          = page.Get("arc").Map(get_arc);
    }
  }
}
