using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using CommonLib.Macros;

namespace PetriNetLib
{
  /// <summary>
  /// Description of GenTranCpp.
  /// </summary>
  [Record]
  [Lens]
  class GenTranCpp : Transition, IEquatable[GenTranCpp]
  {
    gen : CppGenerator;
    
    public this(tran : Transition, gen : CppGenerator)
    {
      base(tran.idx, tran.id, tran.name, tran.guard, tran.time_expr, tran.code_segment, tran.priority, tran.net, tran.UnnamedIdx);
      this.gen = gen;
    }
    
    public Equals(tr : GenTranCpp) : bool
    {
      this == tr : object
    }
    
    public IsCopyVar(place : GenPlaceCpp, arc : Arc) : bool
    {
        match (arc.ExprWithoutTime)
        {
          | <[ () ]>             =>
              def check2(places)
              {
                match (places.Find((p, _) => place == p : object))
                {
                  | Some((_, Arc(ExprWithoutTime = <[ () ]>))) => true
                  | _                                          => false
                }
              }
              match (arc.from)
              {
                | ArcSource.PlaceEnd      => check2(OutputPlacesArcs)
                | ArcSource.TransitionEnd => check2(InputPlacesArcs)
              }
          | <[ $(n : usesite) ]> => 
              def check(places)
              {
                match (places.Find((p, _) => place == p : object))
                {
                  | Some((_, Arc(ExprWithoutTime = <[ $(n2 : usesite) ]>))) when (n == n2) => true
                  | _                                                                      => false
                }
              }
              
            match (arc.from)
            {
              | ArcSource.PlaceEnd      => check(OutputPlacesArcs)
              | ArcSource.TransitionEnd => check(InputPlacesArcs)
            }
          | _ => false  
        }
    }
    
    public PartOfGroup : option[string]
    {
      [Memoize]
      get
      {
        def places = InputGenPlaces;//
        def place = places.Where(x => !x.OutputGenTransitions.ElementsEqual((x, y) => x.priority == y.priority))
                          .Map(x => (x, x.OutputGenTransitions.Where((x : Transition, _) => x.IsUnnamed)
                          .Select(x => x[0])));
        match (place.Find(x => x[1].Contains(this)))
        {
          | Some((_, g)) => g.Fold("", (x, a) => $"$(x.UnnamedIdx)$a") |> Some
          | _            => None()
        }
      }
    }
    
     public IsPartOfGroupTransition : bool
    {
      [Memoize]
      get
      {
        PartOfGroup.HasValue
      }
    }
    
    public GroupName : option[string]
    {
      [Memoize]
      get
      {
        if (PartOfGroup.HasValue)
        {
          def tran = InputGenPlaces.First().OutputTransitions.Where((x, _) => x.IsUnnamed).NToList();
          //def sorted = tran.OrderByDescending((x, _) => x.priority);
          def name = tran.Map((x, _) => x.UnnamedIdx);
          def name = name.Fold("", (x, a) => $"$x$a");
          $"GroupTransition$name" |> Some
        } else None()
      }
    }
    
    public PlacesParticipate : list[GenPlaceCpp]
    {
      [Memoize]
      get
      {
        def to_func = OutputGenPlaces.Filter(_.IsFuncPlace);
        if (!to_func.IsEmpty()) 
        {
          def outpath = to_func.SelectMany(x => x.PathThroughOrdinaryPlaces.Fold([], (x, a) => if (x is PetriNetNode.Place(p)) p :: a else a)).NToList();
          InputGenPlaces + outpath
        } else
        {
          def output = OutputGenPlaces.SelectMany(x => x.OutputGenTransitions.Where(x => x.IsFuncTran).SelectMany(x => x.OutputGenPlaces)).Concat(OutputGenPlaces);
          InputGenPlaces.Concat(output).Distinct().NToList()
        }
      }
    }
    
    public PlacesParticipateMask : string
    {
      [Memoize]
      get
      {
        PlacesParticipate.Fold("", (x, a) => if (a.IsEmpty()) $"pl_$(x.Name)" else $"pl_$(x.Name) | $a");
      }
    }
    
    public IsFuncTran : bool
    {
      [Memoize]
      get
      {
        InputGenPlaces.Exists(x => x.port is Some(PortType.InOut))
      }
    }
    
    public InArcProcess : list[InArcBindingCpp]
    {
      [Memoize]
      get
      {
        InputPlacesArcs.Map((x, a) => InArcBindingCpp(x, gen, this, [], a))
      }
    }
    
    public OutArcProcess : list[OutArcProcessCpp]
    {
      [Memoize]
      get
      {
        OutputPlacesArcs.Map((p, a) => OutArcProcessCpp(p, this, a, gen))
      }
    }
    
    public Body : string
    {
      [Memoize]
      get
      {
        def body = TranBody;
        def places = PlacesParticipateMask;
        def out_tran = OutputGenPlaces.SelectMany(x => x.OutputGenTransitions);
        def tr_next = out_tran.Where(x => x.IsImmediate && !x.IsTimed && !x.IsPartOfFuncPlace);
        def tr_next = tr_next.Map(x => $<#$(x.Name)();#>);
        def tr = if (PartOfGroup is Some(g)) $"tr_GroupTransition$g" else $"tr_$(Name)";
        if (tr_next.IsEmpty())
        $<#bool res = false;
              if (lock($places, $tr))
              {
                $body;
                unlock($places);
              }
              return res;#> else 
        $<#bool res = false;
              if (lock($places, $tr))
              {
                $body;
                unlock($places);
                if (res)
                {
                  ..$(tr_next; "\n")
                }
              }
              return res;#>
      }
    }
    
    public TranBody : string
    {
      [Memoize]
      get
      {
        gen.CreateTranBody(this);
      }
    }
    
    public DfsIterator : IEnumerable[PetriNetNode]
    {
      [Memoize]
      get
      {        
        def it = DfsIter(gen);
        it.Dfs(this |> PetriNetNode.Tran).ToArray()
      }
    }
    
    public PathThroughOrdinaryPlaces : IEnumerable[PetriNetNode]
    {
      [Memoize]
      get
      {
        def visit(v)
        {
          | PetriNetNode.Place(p) when p.IsTimed => false
          | _                                    => true
        }
        
        DfsIterator.Visit(visit).ToArray()
      }
    }
    
    public InputPlacesArcs : list[GenPlaceCpp * Arc]
    {
      [Memoize]
      get
      {
        gen.Places.MapIndex((p, i) => (p, gen.Proc.OutputMatrix[i, idx]))
        .Filter((_, a) => a != null)
        .SelectMany((p, a) => a.Map(x => (p, x))).NToList()
      }
    }
    
    public InputGenPlaces : list[GenPlaceCpp]
    {
      [Memoize]
      get
      {
        gen.Places.MapIndex((p, i) => (p, gen.Proc.OutputMatrix[i, idx]))
        .Filter((_, a) => a != null)
        .Map((p : GenPlaceCpp, _) => p)
      }
    }
    
    public IsPartOfFuncPlace : bool
    {
      [Memoize]
      get
      {
        InputGenPlaces.Exists(x => x.IsFuncPlace && x.FuncTran == this : object)
      }
    }
    
    public OutputPlacesArcs : list[GenPlaceCpp * Arc]
    {
      [Memoize]
      get
      {
        gen.Places.MapIndex((p, i) => (p, gen.Proc.InputMatrix[i, idx]))
        .Filter((_, a) => a != null)
        .SelectMany((p, a) => a.Map(x => (p, x))).NToList()
      }
    }
    
    public OutputGenPlaces : list[GenPlaceCpp]
    {
      [Memoize]
      get
      {
        gen.Places.MapIndex((p, i) => (p, gen.Proc.InputMatrix[i, idx]))
        .Filter((_, a) => a != null)
        .Map((p, _) => p)
      }
    }
  }
}
