using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace PetriNetLib
{
  /// <summary>
  /// Description of LinearComposition.
  /// </summary>
  class LinearComposition : ProcessComposition
  {
    model : OutModel;
    
    gen : Generator;
    
    places : array[GenPlace]
    {
      get
      {
        gen.Places
      }
    }
    
    CreatePlaces() : list[GPlace]
    {
      places.Where(x => !x.IsFuncPlace).Map(x => LinearGPlace(x.Name, x.gen_idx));
      //$<#pl_$(x.Name) = 0x$((1 << x.gen_idx).ToString("X"))#>
      //$<#typedef enum
      //   {
      //     ..$(enums;",\n")
      //   } tplace;#>
    }
    
    CreateTransitions() : list[GTran]
    {
     // def func = $<#      
     // tran_func get_transition(int n) const
	    //{
		   // return *(tran_func *)&tran_funcs[n];
	    //}
     // #>;
     // protected_fields.Add(func);
      def tran = EnumTransitions.OrderBy(x => x.Priority);
      def restran = tran.Select((x, i) => LinearGTran(x.ExecName, i))//$<#tr_$(x.ExecName) = 0x$((1 << i).ToString("X"))#>);
      
      
      
      private_fields.Add($<#
      typedef enum 
      {
        ..$(restran;",\n")
      } ttran;#>);
      
      def lock_places = tran.Select(x => if (x == null) "(tplace)0" else x.PlacesParticipateMask);
      //def next = tran.Select(x => if (x == null) "(ttran)0" else x.NextTran |> TranToMask);
      def can_rep = tran.Select((x, i) => if (x == null) 1 << i else if (x.CompleteTran) 1 << i else 0);
      //def can_rep = can_rep.Fold(0, _ | _);
      //def size = tran.Length;
      
      private_fields.Add($<#const tran_func_type *tran_funcs;
      #>);
      
      def init = tran.Select(x => $<#&$Name::$(x.ExecName)#>);//..$(tran;",\n");
      def init = $<#static const tran_func_type tr_funcs[] = {..$(init; ",\n")};
                   tran_funcs = tr_funcs; 
                  #>;
                  
      def lock_init = $<#static const tplace tr_lock[] = {..$(lock_places; ",\n")};
                         tran_lock = tr_lock;
                       #>;
                       
      //def next_tr = $<#static const ttran next_tr[] = {..$(next; ",\n")};
      //                 next_tran = next_tr;
      //                #>;
      cons_expr.AddRange(init :: lock_init :: []);
      
      //private_fields.Add($<#u32 can_repeat(u32 tr) const
      //{
      //  bool can_rep = tran_can_repeat & tr;
      //  return tr * can_rep;
      //}
      //#>);
      
      //private_fields.Add($<#const tplace *tran_lock;
      //#>);
      //private_fields.Add($<#const ttran *next_tran;
      //#>);
      
      //private_fields.Add($<#static const u32 tran_can_repeat = $(can_rep);
      //#>);
  //    protected_fields.Add(<#void transition(u32 tr_mask)
		//{
		//	u32 tr = LSB(tr_mask) - 1;
		//	tran_func_type tran = tran_funcs[tr];
		//	u32 lock_places = tran_lock[tr];
		//	if (lock(lock_places, tr_mask))
		//	{
		//	  u32 next = (this->*tran)();
		//	  if (next)
		//		  tran_ena(next, can_repeat(tr_mask));
		//		unlock(lock_places);
		//	}
		//}#>);
      // все переходы у которых во входных позициях есть фишки
      def tran = transitions.Where(x => x.IsUnnamed && !x.IsTimed && x.InputGenPlaces.All(x => x.IsHaveInitMarking && x.port.IsNone));
      def tran = tran |> TranMask;
      def tran = $<#tran_ena($tran);#>;
      cons_expr.Add(tran);
    }      
    
    public Process(model : OutModel) : GenModel
    {
      def places = CreatePlaces();
      null
    }
  }
}
