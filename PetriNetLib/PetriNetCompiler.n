using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;
using System.IO;

namespace PetriNetLib
{
    
  public class PetriNetCompiler
  {
    //mutable gen : Generator;
    mutable genproc : IMainProcessor;
    mutable langgen : ILangGenerator;
    mutable proc : PetriNetProcessor;
    [Accessor]
    mutable target_lang : TargetLangType;
    [FlagAccessor(
                  Debug, Events, PrintBinding
                )]
    public Flags : PetriNetFlags;
    
    public PhaseTwo() : void
    {
      //when (!only_)
        //gen.PhaseTwo();   
      genproc.PhaseTwo();
    }
    
    public Process(ty : TypeBuilder, mainproc : IMainProcessorFabric, typer : Typer, file : string, page : string, target : TargetLangType) : void
    {
      target_lang = target;
            
      def parser = Parser(page);
      if (parser.Parse(file))
      {
        def file = System.IO.Path.GetFileNameWithoutExtension(file);
        proc = PetriNetProcessor(file, Flags, typer, ty, parser.Places, parser.Transitions, parser.Arcs, parser.Decls);
        proc.Process();      
        //gen = Generator(proc.OutModel, proc);
        genproc = mainproc.Construct($"$file.h", proc.OutModel, proc, TypeInterface(typer));
        //when (!only_)
          //gen.PhaseOne();
        genproc.PhaseOne();
        ty.UserData["PetriNetGen"] = this;
      } else
      {
        Message.Error($"Error opening file $file")
      }
    }
    
    public MainGen() : GenModel
    {
      //when (!only_)
        //gen.Generate();
      genproc.Generate();
      def comp = LinearComposition();
      comp.Process(proc.OutModel)
    }
  }
}
