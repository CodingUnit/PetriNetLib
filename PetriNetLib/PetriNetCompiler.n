using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;
using System.IO;

namespace PetriNetLib
{
  public class PetriNetCompiler
  {
    //mutable gen : Generator;
    mutable cpp_gen : CppGenerator;
    mutable proc : PetriNetProcessor;
    mutable only_cpp : bool;
    [FlagAccessor(
                  Debug, Events, PrintBinding
                )]
    public Flags : PetriNetFlags;
    
    public PhaseTwo() : void
    {
      //when (!only_cpp)
        //gen.PhaseTwo();   
      cpp_gen.PhaseTwo();
    }
    
    public Process(ty : TypeBuilder, typer : Typer, file : string, page : string, only_cpp : bool) : void
    {
      this.only_cpp = only_cpp;
      def parser = Parser(page);
      parser.Parse(file);
      def file = System.IO.Path.GetFileNameWithoutExtension(file);
      proc = PetriNetProcessor(file, Flags, typer, ty, parser.Places, parser.Transitions, parser.Arcs, parser.Decls);
      proc.Process();      
      //gen = Generator(proc.OutModel, proc);
      cpp_gen = CppGenerator($"$file.h", proc.OutModel, proc);
      //when (!only_cpp)
        //gen.PhaseOne();
      cpp_gen.PhaseOne();
      ty.UserData["PetriNetGen"] = this;
    }
    
    public MainGen() : void
    {
      //when (!only_cpp)
        //gen.Generate();
      cpp_gen.Generate();
    }
  }
}
