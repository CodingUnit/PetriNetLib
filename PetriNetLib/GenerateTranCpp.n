using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace PetriNetLib
{
  /// <summary>
  /// Description of GenerateTranCpp.
  /// </summary>
  partial class CppGenerator
  {
    internal CreateTranBody(tran : GenTranCpp) : string
    {
      def output = tran.OutputPlacesArcs;
      def name   = tran.Name;
      //def map    = Hashtable();

      def input = tran.InArcProcess;

      foreach (i in input)
      {
        match (i.expr)
        {
          | <[ $_(..$p) ]> => foreach (p in p)
                                {
                                  | <[ $(n : usesite)]> => match (input.Find(x => x.bind_var == n))
                                      {
                                        | Some(x) => i.Depends ::= x;
                                        | _       => ()
                                      }
                                  | _                   => ()
                                }
          | _ => ()
        }
        //map[i.name] = i;
      }

      def input    = input.OrderBy(_.priority); 
      def add_proc = tran.OutArcProcess;//output.Map((p, a) => OutArcProcessCpp(places[p.idx], tran, a, this));

      def extract = input.Map(_.extract_expr);
      def add_body = add_proc.Map(_.add_token);
      def code = (tran.code_segment |> ConvExpr(_, true)) + ";" ?? "";
      
      //def out_tran = tran.OutputGenPlaces.SelectMany(x => x.OutputGenTransitions).NToList();
      //def participate_tran = out_tran;
      
      //def tr_pl_mask = participate_tran.Where(x => x.IsImmediate && !x.IsTimed && !x.IsPartOfFuncPlace);//.Map(x => $"tr_$(x.Name)");//, x.InputPlaces.Select(x => x[0]) |> mask_for_places));
      def tr_comp_mask = if (tran.IsImmediate && !tran.IsPartOfGroupTransition && !tran.IsTimed && !tran.IsPartOfFuncPlace && !tran.IsFuncTran) $"tr_$(tran.Name)" else "0";
      //def tr_mask = tr_pl_mask.Fold("", (t, a) => if (a.IsEmpty()) t else $"$t | $a");
      //def tr_mask = if (tr_mask.IsEmpty()) "0" else tr_mask;
      def tr_ena = if (tr_comp_mask == "0") "" else $"tran_ena($tr_comp_mask);";
      //def tr_next = tr_pl_mask.Map(x => $<#$(x.Name)();#>);
      def res = if (tran.IsPartOfFuncPlace || tran.IsFuncTran) [] else if (output.Exists(x => x[0].port is Some(PortType.InOut)))
                                                    ["res = in;"] else
                                                    ["res = true;"];
      def body = extract + (code :: add_body) + [tr_ena] + res;
      
      def body = body.Filter(x => !x.IsEmpty());
      def body = if (tran.guard is <[]>) body else //tran_ena($t, $p);
                  {
                    def guard = tran.guard |> ConvExpr(_, false);
                    $<#if ($guard) 
                    {
                      ..$(body;"\n")
                    }#> :: [];
                  }

      def tran_evt = if (proc.Flags.HasFlag(PetriNetFlags.Events)) $<#On$name()#> else "";

      def fold(x, a)
      {
        def pre_bind = x.pre_bind_expr;
        if (a : object == null)
        {
          def expr = x.bind_expr :: body + [tran_evt];
          def expr = expr.Filter(x => !x.IsEmpty());
          def expr = $<#..$(expr;"\n")#>;
          if (x.check_expr.IsEmpty())
          {
            $<#$pre_bind$expr#>
          }
          else
          {
            $<#$pre_bind if ($(x.check_expr))
                {
                  $expr
                }#>
          }
        } else
        {
          
          def expr = [x.bind_expr] + [a];
          def expr = expr.Filter(x => !x.IsEmpty());
          def expr = $<#..$(expr;"\n")#>;
          if (x.check_expr.IsEmpty())
            expr
          else
            $<#$pre_bind if ($(x.check_expr))
              {
                $expr
              }#>
        }
      }


      //def input = eval(input, []);

      input.Fold(null, fold)
    }    

    
    
    CreateGroupTransitions() : list[string]
    {
      //def places = places.Where(x => !CommonLib.Macros.ListUtils.ElementsEqual(x.OutputTransitions.Where((x, _) => x.IsUnnamed).Map((x, _) => x.priority), _ == _));
      
      def create_group_tran(p)
      {
        def tran = p.OutputGenTransitions.Where((x, _) => x.IsUnnamed).NToList();
        def sorted = tran.OrderByDescending(x => x.priority);
        def group = sorted.Fold("return false;", (x, a) => $"if (!$(x.Name)()) \n$a");
        def name = tran.First().GroupName.Value;
        def tr_comp = $"tr_$name";
        $<#bool $name()
            {
              $group
              tran_ena(0, $tr_comp);
              return true;
            }#>;
      }
      
      "" :: PlacesWithGroup.Map(create_group_tran) + [""]
    }
    
    EnumTransitions : list[string * int]
    {
      [Memoize]
      get
      {
        def tran = transitions.Where(x => !x.IsPartOfFuncPlace && !x.IsFuncTran).Select(x => ($"$(x.ExecName)", x.priority));
        def groups = PlacesWithGroup.Select(x => x.OutputTransitions.Where(x => x[0].IsUnnamed));
        def groups = groups.Select(x => ("GroupTransition" + x.Fold("", ((x, _), a) => $"$(x.UnnamedIdx)$a"), x.Select(x => x[0].priority).Max()));
        groups.Concat(tran).NToList()
      }
    }
    
    CreateTransitions() : void
    {
      def func = $<#      
      tran_func get_transition(int n) const
	    {
		    return *(tran_func *)&tran_funcs[n];
	    }
      #>;
      protected_fields.Add(func);
      def tran = EnumTransitions;
      def restran = tran.OrderBy((_, p) => p).Select(((x, _), i) => $<#tr_$x = 0x$((1 << i).ToString("X"))#>);
      
      
      
      private_fields.Add($<#
      typedef enum 
      {
        ..$(restran;",\n")
      } ttran;#>);
      
      def tran = tran.Map((x, _) => x);
      def size = tran.Length;
      
      private_fields.Add($<#
      tran_func_type tran_funcs[$size];
      #>);
      
      def init = tran.Select((x, i) => $<#tran_funcs[$i] = &$Name::$x;#>);//..$(tran;",\n");
      cons_expr.AddRange(init);
      
      // все переходы у которых во входных позициях есть фишки
      def tran = transitions.Where(x => x.IsUnnamed && !x.IsTimed && x.InputGenPlaces.All(x => x.IsHaveInitMarking && x.port.IsNone));
      def tran = tran |> TranMask;
      def tran = $<#tran_ena($tran);#>;
      cons_expr.Add(tran);
    }
    
    CreateTran(tran : GenTranCpp) : string
    {
      def name = tran.ExecName;
      
      if (tran.IsFuncTran)
      {
        def body = tran.TranBody;      
        def parms = tran.InArcProcess.Map(x => $"$(x.place.Colour.VarSpec)$(x.bind_var)");
        $<#void $name(..$(parms; ","))
            {
              $body
            }
          #>
      } else
      {
        def body = tran.Body;      
        $<#bool $name()
            {
              $body
            }
          #>//)
        }
    }

  }
}
