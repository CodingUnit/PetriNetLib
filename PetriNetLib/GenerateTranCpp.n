using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using CommonLib.Macros;

namespace PetriNetLib
{
  /// <summary>
  /// Description of GenerateTranCpp.
  /// </summary>
  partial class CppGenerator
  {
    internal CreateTranBody(tran : GenTranCpp) : string
    {
      //def output = tran.OutputPlacesArcs;
      def name   = tran.Name;
      //def map    = Hashtable();

      def input = tran.InArcProcess;

      foreach (i in input)
      {
        match (i.expr)
        {
          | <[ $_(..$p) ]> => foreach (p in p)
                                {
                                  | <[ $(n : usesite)]> => match (input.Find(x => x.bind_var == n))
                                      {
                                        | Some(x) => i.Depends ::= x;
                                        | _       => ()
                                      }
                                  | _                   => ()
                                }
          | _ => ()
        }
        //map[i.name] = i;
      }

      def input    = input.OrderBy(_.priority); 
      def add_proc = tran.OutArcProcess;//output.Map((p, a) => OutArcProcessCpp(places[p.idx], tran, a, this));

      def extract = input.Map(_.extract_expr);
      def add_body = add_proc.Map(_.add_token);
      def code = tran.Code;
      
      //def out_tran = tran.OutputGenPlaces.SelectMany(x => x.OutputGenTransitions).NToList();
      //def participate_tran = out_tran;
      
      //def tr_pl_mask = participate_tran.Where(x => x.IsImmediate && !x.IsTimed && !x.IsPartOfFuncPlace);//.Map(x => $"tr_$(x.Name)");//, x.InputPlaces.Select(x => x[0]) |> mask_for_places));
      //def tr_comp_mask = if (tran.IsImmediate && !tran.IsPartOfGroupTransition && !tran.IsTimed && !tran.IsPartOfFuncPlace && !tran.IsFuncTran) $"tr_$(tran.Name)" else "0";
      //def tr_mask = tr_pl_mask.Fold("", (t, a) => if (a.IsEmpty()) t else $"$t | $a");
      //def tr_mask = if (tr_mask.IsEmpty()) "0" else tr_mask;
      //def tr_ena = if (tr_comp_mask == "0") "" else $"tran_ena($tr_comp_mask);";
      //def tr_next = tr_pl_mask.Map(x => $<#$(x.Name)();#>);
      def res = if (tran.IsPartOfFuncPlace || tran.IsFuncTran) [] else //if (output.Exists(x => x[0].port is Some(PortType.InOut)))
                                                    //["res = in;"] else
                                                    ["return true;"];
      def body = extract + (code :: add_body) + res;
      
      def body = body.Filter(x => !x.IsEmpty());
      def body = if (tran.guard is <[]>) body else //tran_ena($t, $p);
                  {
                    def guard = tran.guard |> ConvExpr(_, false);
                    $<#if ($guard) 
                    {
                      ..$(body;"\n")
                    }#> :: [];
                  }

      def tran_evt = if (proc.Flags.HasFlag(PetriNetFlags.Events)) $<#On$name()#> else "";

      def fold(x, a)
      {
        def pre_bind = x.pre_bind_expr;
        if (a : object == null)
        {
          def expr = x.bind_expr :: body + [tran_evt];
          def expr = expr.Filter(x => !x.IsEmpty());
          def expr = $<#..$(expr;"\n")#>;
          if (x.check_expr.IsEmpty())
          {
            $<#$pre_bind$expr#>
          }
          else
          {
            $<#$pre_bind if ($(x.check_expr))
                {
                  $expr
                }
                return false;#>
          }
        } else
        {
          
          def expr = [x.bind_expr] + [a];
          def expr = expr.Filter(x => !x.IsEmpty());
          def expr = $<#..$(expr;"\n")#>;
          if (x.check_expr.IsEmpty())
            expr
          else
            $<#$pre_bind if ($(x.check_expr))
              {
                $expr
              }
              return false;#>
        }
      }


      //def input = eval(input, []);

      input.Fold(null, fold)
    }    

    
    class EnumComp : IEqualityComparer[IEnumerable[string]]
    {
      public Equals(x : IEnumerable[string], y : IEnumerable[string]) : bool
      {
        x.OrderBy(x => x).ZipLazy(y.OrderBy(x => x)).All((x, y) => x == y)
      }
      
		  public GetHashCode(obj : IEnumerable[string]) : int
		  {
		    obj.Fold(0, (x, a) => x.GetHashCode() + a * 12345)
		  }
		
    }
    
    public CreateGroupTranBody(g : GroupTranCpp) : string
    {
      //def places = places.Where(x => !CommonLib.Macros.ListUtils.ElementsEqual(x.OutputTransitions.Where((x, _) => x.IsUnnamed).Map((x, _) => x.priority), _ == _));
      
        //def tran = p.OutputGenTransitions.Where((x, _) => x.IsUnnamed).NToList();
            //$<#$body$else#>
        def sorted = g.grouped.OrderByDescending(x => x.priority).NToList();//
        def bind = sorted.Map(x => x.InArcProcess.Map(x => x.bind_expr));
        //x.InArcProcess.OrderBy(x => x.place.idx).Select(x => x.bind_expr)
        def (dup_bind, _other) = bind.DuplicatesPartition(EnumComp());
        def dup_bind = dup_bind.SelectMany(x => x).Distinct();
        
        def dup_bind = if (dup_bind.IsEmpty()) "" else $<#..$(dup_bind; "\n")
        #>;
        
        def create_body(x, a)
        {
          def last = sorted.Last() == x : object;
          def cond = match (x.guard)
          {
            | null
            | <[]> => null
            | e    => e |> ConvExpr(_, true)
          }
          def els = if (last) "" else " else";
          def body = x.Body;
          
          def res = if (cond == null) 
          {
            $<#$dup_bind$body#>
          } else
          
          $<#$(dup_bind)if ($cond)
          {
            $body
          }$els
          #>;
          $"$res$a"
          //$"if (!$(x.Name)()) \n$a"
        }
        
        def group = sorted.Fold("return false;", create_body);
        //def tr_comp = $"tr_$name";
        $<#$group
           return true;
          #>;
      
      //"" :: PlacesWithGroup.Map(create_group_tran) + [""]
    }
    
    EnumTransitions : list[GenTranCpp]
    {
      [Memoize]
      get
      {
        def tran = transitions.Filter(x => !x.IsPartOfFuncPlace && !x.IsFuncTran && !x.PartOfGroup.HasValue);
        //def groups = PlacesWithGroup.Select(x => x.OutputTransitions.Where(x => x[0].IsUnnamed));
        //def groups = GroupTransitions.Select(x => (x.Name, ));//groups.Select(x => ("GroupTransition" + x.Fold("", ((x, _), a) => $"$(x.UnnamedIdx)$a"), x.Select(x => x[0].priority).Max(), null));
        GroupTransitions.Map(_ : GenTranCpp) + tran
      }
    }
    
    TranToMask(tr : IEnumerable[GenTranCpp]) : string
    {
      if (tr.IsEmpty()) "(ttran)0" else
      {
        def str = tr.Fold("", (t, a) => if (a.IsEmpty()) $<#tr_$(t.ExecName)#> else $<#tr_$(t.ExecName) | $a#>);
        $<#(ttran)($str)#>
      }
    }
    
    CreateTransitions() : void
    {
      def func = $<#      
      tran_func get_transition(int n) const
	    {
		    return *(tran_func *)&tran_funcs[n];
	    }
      #>;
      protected_fields.Add(func);
      def tran = EnumTransitions.OrderBy(x => x.Priority);
      def restran = tran.Select((x, i) => $<#tr_$(x.ExecName) = 0x$((1 << i).ToString("X"))#>);
      
      
      
      private_fields.Add($<#
      typedef enum 
      {
        ..$(restran;",\n")
      } ttran;#>);
      
      def lock_places = tran.Select(x => if (x == null) "(tplace)0" else x.PlacesParticipateMask);
      def next = tran.Select(x => if (x == null) "(ttran)0" else x.NextTran |> TranToMask);
      def can_rep = tran.Select((x, i) => if (x == null) 1 << i else if (x.CompleteTran) 1 << i else 0);
      def can_rep = can_rep.Fold(0, _ | _);
      //def size = tran.Length;
      
      private_fields.Add($<#const tran_func_type *tran_funcs;
      #>);
      
      def init = tran.Select(x => $<#&$Name::$x#>);//..$(tran;",\n");
      def init = $<#static const tran_func_type tr_funcs[] = {..$(init; ",\n")};
                   tran_funcs = tr_funcs; 
                  #>;
                  
      def lock_init = $<#static const tplace tr_lock[] = {..$(lock_places; ",\n")};
                         tran_lock = tr_lock;
                       #>;
                       
      def next_tr = $<#static const ttran next_tr[] = {..$(next; ",\n")};
                       next_tran = next_tr;
                      #>;
      cons_expr.AddRange(init :: lock_init :: next_tr :: []);
      
      private_fields.Add($<#u32 can_repeat(u32 tr) const
      {
        bool can_rep = tran_can_repeat & tr;
        return tr * can_rep;
      }
      #>);
      
      private_fields.Add($<#const tplace *tran_lock;
      #>);
      private_fields.Add($<#const ttran *next_tran;
      #>);
      
      private_fields.Add($<#static const u32 tran_can_repeat = $(can_rep);
      #>);
      protected_fields.Add(<#bool transition(u32 tr)
		{
			bool res = false;
			tran_func_type tran = tran_funcs[tr];
			u32 lock_places = tran_lock[tr];
			if (lock(lock_places, tr))
			{
				if ((this->*tran)())
				{
				  tran_ena(next_tran[tr], can_repeat(tr));
				  res = true;
				}
				unlock(lock_places);
			}
			return res;
		}#>);
      // все переходы у которых во входных позициях есть фишки
      def tran = transitions.Where(x => x.IsUnnamed && !x.IsTimed && x.InputGenPlaces.All(x => x.IsHaveInitMarking && x.port.IsNone));
      def tran = tran |> TranMask;
      def tran = $<#tran_ena($tran);#>;
      cons_expr.Add(tran);
    }
    
    CreateTran(tran : GenTranCpp) : string
    {
      def name = tran.ExecName;
      
      if (tran.IsFuncTran)
      {
        def body = tran.Body;      
        def parms = tran.InArcProcess.Map(x => $"$(x.place.Colour.VarSpec)$(x.bind_var)");
        $<#
        bool $name(..$(parms; ","))
            {
              $body
            }#>
      } else
      {
        def body = tran.Body;
        $<#
        bool $name()
            {
              $body
            }#>//)
        }
    }

  }
}
