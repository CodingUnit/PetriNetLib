using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;
using PetriNetModel;

namespace PetriNetLib
{
  /// <summary>
  /// Description of GenTran.
  /// </summary>
  partial class Generator
  {
    CreateTranBody(tran : Transition) : PExpr
    {
      def input  = tran.InputPlaces;
      def output = tran.OutputPlaces;
      def map    = Hashtable();
      
      def unfold(e)
      {
        | <[ () ]> => <[ Unit.Instance ]>
        | e        => e
      }
      
      def create_add(p, a)
      {
        def name = p.name;
        match (a.expr)
        {
          | <[ () ]>                       => <[ $(name : usesite).Add(Unit.Instance) ]> 
          | <[ $e %@+ $time]>              => <[ $(name : usesite).Add($(unfold(e)) %@+ $time)]>
          | <[ 1 ` $e ]>
          | <[ $_(..$_)]> as e                                    
          | <[ $(_ : usesite) ]> as e      => <[ $(name : usesite).Add($e)]>
          | <[ $(_ : int) ` $_ ]> 
          | <[ $_ %++ $_ ]>                => def expr = GetTokenExpr(a.expr);
                                              <[ $(name : usesite).Add($expr)]>
          | e                              => <[ $(name : usesite).Add($e)]>
        }
      }
      
      def input = input.Map((x, a) => InArcBinding(x, tran, [], a.expr));
      
      foreach (i in input)
      {
        match (i.expr)
        {
          | <[ $_(..$p) ]> => foreach (p in p)
                              {
                                | <[ $(n : usesite)]> => match (input.Find(x => x.bind_var == n))
                                                         {
                                                           | Some(x) => i.Depends ::= x;
                                                           | _       => ()
                                                         }
                                | _                   => ()
                              }
          | _ => ()
        }
        map[i.name] = i;
      }
      
      def input    = input.Sort((x, y) => y.priority - x.priority); 
      def add_body = output.Map(create_add);
      
      def extract = input.Map(_.extract_expr);
      def body = extract + add_body;
      def body = if (tran.guard is <[]>) body else 
                  <[ when ($(tran.guard)) {..$body}]> :: [];
      
          
      def fold(x, a)
      {
        if (a == null)
        {
          <[  //$(x.before_bind_expr);
              when ($(x.check_expr))
              {
               $(x.bind_expr);
               {..$body}
              }
          ]>
        } else
        {
          <[  //$(x.before_bind_expr);
              when ($(x.check_expr))
              {
               $(x.bind_expr);
               $a
              }
          ]>
        }
      }
      
      
      //def input = eval(input, []);
      
      input.Fold(null, fold);
    }
    
  }
}
