using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;

namespace PetriNetLib
{
  /// <summary>
  /// Description of GenTran.
  /// </summary>
  partial class Generator
  {
    CreateTranBody(tran : Transition) : PExpr
    {
      def input  = tran.InputPlaces;
      def output = tran.OutputPlaces;
      def map = Hashtable();
      
      def create_add(p, a)
      {
        def name = p.name;
        match (a.expr)
        {
          | <[ 1 ` $e ]>
          | <[ $_(..$_)]> as e                                    
          | <[ $(_ : usesite) ]> as e      => <[ $(name : usesite).Add($e)]>
          | <[ $(_ : int) ` $_ ]> 
          | <[ $_ %++ $_ ]>                => def expr = GetTokenExpr(a.expr);
                                              <[ $(name : usesite).Add($expr)]>
          
        }
      }
      
      def input = input.Map((x, a) => InArcBinding(x, tran, [], false, a.expr));
      
      foreach (i in input)
      {
        match (i.expr)
        {
          | <[ $_(..$p) ]> => foreach (p in p)
                              {
                                | <[ $(n : usesite)]> => match (input.Find(x => x.var == n))
                                                         {
                                                           | Some(x) => i.Depends ::= x;x.NeedBinding = true;
                                                           | _       => ()
                                                         }
                                | _                   => ()
                              }
          | _ => ()
        }
        map[i.name] = i;
      }
      
      def eval(inp, res)
      {
        match (inp)
        {
          | []           => res
          | head :: tail => match (head.Depends)
                            {
                              | []   => eval(tail, head :: res)
                              | lst  => def res = eval(lst, res.Except(lst).NToList());
                                        eval(tail.Except(res).NToList(), head :: res)
                            }
                            
        }
      }
      
      def add_body = output.Map(create_add);
      
      def extract = input.Map(_.extract_expr);
      def guard   = x => if (tran.guard is <[]>) x else <[ when ($(tran.guard)) {..$x}]> :: [];
      
      def fold(x, a)
      {
        if (a == null)
        {
          def body = extract + add_body;
          def guard_and_body = guard(body);
          <[  $(x.before_bind_expr);
              when ($(x.check_expr))
              {
               $(x.bind_expr);
               {..$guard_and_body}
             }
          ]>
        } else
        {
          <[  $(x.before_bind_expr);
              when ($(x.check_expr))
              {
               $(x.bind_expr);
               $a
              }
          ]>
        }
      }
      
      
      def input = eval(input, []);
      
      input.Fold(null, fold);
    }
    
  }
}
