using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using CommonLib.Macros;
using PetriNetModel;

namespace PetriNetLib
{
  /// <summary>
  /// Description of Generator.
  /// </summary>
  class Generator
  {
    model : OutModel;
    proc : PetriNetProcessor;
    converter : Converter;
    typer : Typer;
    typebuilder : TypeBuilder;
    mutable typing_method : MethodBuilder;
    //compiler : CompilerHost = CompilerHost();
    
    public this(model : OutModel, proc : PetriNetProcessor)
    {
      this.typer = proc.Typer;
      this.typebuilder = proc.Typebuilder;
      this.model = model;
      this.proc = proc;
      this.converter = proc.Converter;
    }
    
    GetTypeExpr(p : ColourSet) : PExpr
    {
        | ColourSet(_, Colour.Simple(type)) => 
              match (type)
              {
                | "string" => <[ string ]>
                | "int"    => <[ int ]>
                | "intinf" => <[ IntInf ]>
                | "real"   => <[ double ]>
                | "time"   => <[ Time ]>
                | "bool"   => <[ bool ]>
                | "unit"   => <[ void ]>
              }
        
        | ColourSet(_, Product(vals))  => def vals = vals.Map(x => <[ $(TypeFromStr(x)) ]>);
                                          <[ (..$vals) ]>
        | ColourSet(n, Index)
        | ColourSet(n, Enum)           => <[ $(n : usesite) ]>
        | ColourSet(_, List(t, _))     => 
            def inner = t |> TypeFromStr;
            <[ list[$inner]]>
    }
      
    TypeFromStr(str : string) : PExpr
    {
      | "string" => <[ string ]>
      | "int"    => <[ int ]>
      | "intinf" => <[ IntInf ]>
      | "real"   => <[ double ]>
      | "time"   => <[ Time ]>
      | "bool"   => <[ bool ]>
      | "unit"   => <[ void ]>
      | str      => proc.colour_sets[str] |> GetTypeExpr
      
    }
    
    CreatePlace(place : Place) : ClassMember
    {
      def name = place.name;
      def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
      def type = GetTypeExpr(place.colour);
      <[decl: $(name : usesite) : PetriNetModel.Place.[$type] = PetriNetModel.Place()]>
    }
    
    IsTokenExpr(expr : PExpr) : bool
    {
      | <[ $(_ : usesite) ]> => false
      | _                    => true
    }
    
    CreateDummyMethod() : void
    {
      def meth = typebuilder.DefineAndReturn(<[decl: TypingMethod() : void {}]>);
      typing_method = meth :> MethodBuilder;
    }
    
    CreateOperators() : void
    {
      def token_op = <[decl: public static @`[T](count : int, tok : T) : IEnumerable[T]
                             {
                               Enumerable.Repeat(tok, count)
                             }]>;
     typebuilder.DefineWithSource(token_op);
     def token_combine_op = <[decl: public static @%++[T](tok1 : IEnumerable[T], tok2 : IEnumerable[T]) : IEnumerable[T]
                             {
                               tok1.Union(tok2)
                             }]>;
     typebuilder.DefineWithSource(token_combine_op);
    }
    
    GetTokenExpr(expr : PExpr) : PExpr
    {
      def loop(e)
      {
        | <[ $(count : int) ` $expr ]> => Enumerable.Repeat(expr, count).NToList()
        | <[ $left %++ $right ]>       => loop(left) + loop(right)
        | _                            => [expr]
      }
      
      match (loop(expr))
      {
        | [<[$_(..$_)]> as e] => e
        | e                   => <[IEnumerable[..$e]]>
      }
      
    }
    
    CreateTranBody(tran : Transition) : PExpr
    {
      def input = tran.InputPlaces;
      def output = tran.OutputPlaces;
      
      def create_check(p, a)
      {
        def name = p.name;
        if (a.expr |> IsTokenExpr)
        {
          def tok = GetTokenExpr(a.expr);
          <[ $(name : usesite).Have($tok) ]>
        } else
        {
          <[ $(name : usesite).HaveTokens ]>
        }
      }
      
      def create_run_body(p, a)
      {
        def name = p.name;
        if (a.expr |> IsTokenExpr)
        {
          def expr = GetTokenExpr(a.expr);
          <[ $(name : usesite).GetMany($expr)]>
        } else
        {
          <[def $(a.expr) = $(name : usesite).Get()]>
        }
      }
      
      def create_out(p, a)
      {
        def name = p.name;
        match (a.expr)
        {
          | <[ 1 ` $e ]>
          | <[ $_(..$_)]> as e                                    
          | <[ $(_ : usesite) ]> as e      => <[ $(name : usesite).Add($e)]>
          | <[ $(_ : int) ` $_ ]> 
          | <[ $_ %++ $_ ]>                => def expr = GetTokenExpr(a.expr);
                                              <[ $(name : usesite).AddMany($expr)]>
          
        }
      }
      
      def checks = input.Map(create_check);
      def checks = checks.Reduce((x, y) => <[ $x && $y]>);
      def run_body = input.Map(create_run_body);
      def out_body = output.Map(create_out);
      <[ 
         match ($checks)
         {
           | true => {..$run_body}
                     {..$out_body}
           | _    => ()
         }
       ]>
    }
    
    CreateTran(tran : Transition) : ClassMember
    {
      def name = tran.name;
      
      def body = CreateTranBody(tran);      
      <[
         decl: public $(name : usesite)() : void
               {
                 $body
               }
       ]>
    }
    
    CreateVars(name : string, type : ColourSet) : ClassMember
    {
      def type = GetTypeExpr(type);
      <[decl: $(name : usesite) : $type]>
    }
     
    CreateVals(expr : PExpr) : ClassMember
    {
      | <[ def $(name : usesite) = $val]> => 
          def type = typer.TypeExpr(val);
          def ty = type.ty;
          <[ decl: $(name : usesite) : $(ty : typed) = $val ]>
          
      | _ => null
    }
    
    ProcessFun(expr : PExpr) : PExpr
    {
      | <[ def $(n : usesite)(..$parms) { ..$body } ]> => 
      
            def proc_parm(p, (parm, e))
            {
              match (p)
              {
                | <[parameter: $(n : usesite) : Index.[$(type : usesite)]]> => 
                  match (model.GetIndex(type))
                  {
                    | Some((t, _)) => (<[parameter: $(n : usesite) : $(t : usesite)]> :: parm, <[def $(n : usesite) = $(n : usesite).num ]> :: e)
                    | _            => (parm, e)
                  }
                  
              }
            }
      
            def expr = <[ {..$body} ]>;
            def (parms, expr) = parms.Fold(([], expr :: []), proc_parm);
            def parms = parms.Rev();
            //def expr = <[ {..$expr} ]>;
      
          
      //def process(_, b, e)
      //{
      //  if (b)
      //  match (e)
      //  {
      //    | <[ $(n : usesite)($p)]> => match (model.GetIndex(n))
      //                                 {
      //                                   | Some((t, _)) => <[ $(t : usesite)($p)]>
      //                                   | _            => e
      //                                 }
      //    | e => e                              
      //  } else e
      //}
      
      //def expr = Macros.TraverseExpr(None(), expr, false, process);
      <[ def $(n : usesite)(..$parms) { ..$expr } ]>
    }
    
    CreateDecl(expr : PExpr) : ClassMember
    {
      
      | <[ def $(_ : usesite)(..$_) { ..$_ } ]> => 
          
          def func = ProcessFun(expr);
          def ty = Typer(typing_method);
          def te = ty.TypeExpr(func);
          match (func)
          {
            | <[ def $(n : usesite)(..$parms) { ..$expr } ]> =>
                match (te)
                {
                  | TExpr.DefFunctionsIn(h :: _, _) => def ret = h.ReturnType;
                                                      <[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                        {
                                                          ..$expr
                                                        }]>
                }
        }
      | _ => null
    }
    
    TypeOfExpr(expr : PExpr) : PExpr
    {
      | <[ $(_ : int)]>       => <[ int ]>
      | <[ $(_ : string)]>    => <[ string ]>
      | <[ $(_ : double)]>    => <[ double ]>
      | <[ $(_ : bool)]>      => <[ double ]>
      | <[ $(_ : int) ` $t ]> => def t = TypeOfExpr(t); <[ IEnumerable[$t] ]>
      | <[ $(_ : usesite) ]>  => null//model.ml_decls.Find();
    }

    CreateColourSet(col : ColourSet) : ClassMember.TypeDeclaration
    {
      | ColourSet(n, Colour.Alias(new_name))  => def name = Macros.UseSiteSymbol(n);
                                                 def mods = AttributesAndModifiers(NemerleModifiers.Private, []);
                                                 def al = TopDeclaration.Alias(name, mods, Typarms.Empty, <[ $(new_name : usesite) ]>);
                                                 def ty = al |> ClassMember.TypeDeclaration.TypeDeclaration;
                                                 ty.SetEnv(typebuilder.GlobalEnv);
                                                 ty
      | ColourSet(n, Colour.Record(vals))     => def fields = vals.Map((n, t) => (n, TypeFromStr(t)));
                                                 def fields = fields.Map((n, t) => <[decl: $(n : usesite) : $t]>);
                                                 <[decl: [Record] class $(n : usesite)
                                                         {
                                                           ..$fields
                                                         }
                                                 ]>
      | ColourSet(n, Colour.Index(mn, mx, _)) => def eval(m)
                                                 {
                                                    def expr = converter.ParseML(m);
                                                    match (expr)
                                                    {
                                                      | <[$(n : int)]>  => n
                                                      | <[$(name : usesite) ]> => 
                                                                           def match_var(x)
                                                                           {
                                                                             | <[ def $(n : usesite) = $_]> => n == name 
                                                                             | _                            => false
                                                                           }
                                                                           
                                                                           match (model.ml_decls.Find(match_var))
                                                                           {
                                                                             | Some(<[ def $(_ : usesite) = $(v : int)]>) => v
                                                                             | _                                  => throw InvalidOperationException()
                                                                           }
                                                    }
                                                 }
                                                 def mn = mn |> eval;
                                                 def mx = mx |> eval;
                                                  <[decl: [Record]
                                                      class $(n : usesite)
                                                      {
                                                        public static min : int = $(mn : int);
                                                        public static max : int = $(mx : int);
                                                        public num : int;
                                                        
                                                        public static all() : IEnumerable[$(n : usesite)]
                                                        {
                                                          Enumerable.Range(min, max).Select($(n : usesite))
                                                        }
                                                      }
                                                     ]>
      | ColourSet(n, Colour.Enum(vals)) => def vals = vals.Map(x => <[decl: | $(x : usesite) ]>);
                                           <[decl: enum $(n : usesite)
                                           {
                                             ..$vals
                                           }]>
      | _ => null
    }

    enum TDestCont
    {
      | MultiSet
      | RandomEnumerable
      | TokenQueue
      | SortedSet
    }
    
    DestContainerType() : TDestCont
    {
      TDestCont.MultiSet
    }
    
    CreateInitMarking(place : Place) : PExpr
    {
      def combine(e1, e2)
      {
        | (<[Enumerable.Repeat($tok, $(n : int))]>, <[Enumerable.Repeat($tok2, $(n2 : int))]>) when (tok.Equals(tok2)) 
            => <[Enumerable.Repeat($tok, $(n2 + n))]>
        | (<[Enumerable.Repeat($(tok : int), $(n : int))]>, <[Enumerable.Repeat($(tok2 : int), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Union(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : int)]>);
               <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : string), $(n : int))]>, <[Enumerable.Repeat($(tok2 : string), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Union(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : string)]>);
               <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : double), $(n : int))]>, <[Enumerable.Repeat($(tok2 : double), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Union(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : double)]>);
               <[ array[..$val] ]>       
        | _  //(<[Enumerable.Repeat($_, $(_ : int))]>, <[Enumerable.Repeat($_, $(_ : int))]>)                         
            => <[ $e1.Union($e2)]> 
      }
      
      def fold(expr)
      {
        match (expr)
        {
          //| <[ {..$e} ]>   => e.Fold(acc, fold)
          | <[ 1 ` $tok]>             => <[ array[$tok] ]>
          | <[ $(n : int) ` $tok]>    => <[ Enumerable.Repeat($tok, $n) ]>
          | <[ $l %++ $r]>            => combine(fold(l), fold(r))
          | e                         => e
        }
      }
      
      def mark = fold(place.init_mark);
      def name = place.name;
      <[ $(name : usesite).Add($mark)]>
    }
    
    public PhaseTwo() : void
    {
      /*
      [assembly: OperatorAttribute("Nemerle.Core", "*",  false, 260, 261)]
[assembly: OperatorAttribute("Nemerle.Core", "/",  false, 260, 261)]
[assembly: OperatorAttribute("Nemerle.Core", "+",  false, 240, 241)]
      */
      CreateDummyMethod();
      def methods = model.transitions.MapToList(CreateTran);
      def vals = model.ml_decls.Map(CreateVals).Filter(_ != null);
      foreach (m in vals) typebuilder.DefineWithSource(m);
      def decls = model.ml_decls.Map(CreateDecl).Filter(_ != null);
      def decls = decls + methods;
      foreach (m in decls) typebuilder.DefineWithSource(m);
      typebuilder.Compile()
    }
    
    public Generate() : void
    {
      
      CreateOperators();
      assert2(false);
      def sets = model.colour_sets.Values.Map(CreateColourSet).Filter(_ != null);
      foreach (m in sets) typebuilder.DefineNestedTypeWithSource(m).Compile();
      def fields = model.places.MapToList(CreatePlace);
      def marking = model.places.MapToList(CreateInitMarking);
      def cons = <[decl: public this() {..$marking}]>;
      def vars = model.vars.KeyValuePairs.MapToList(CreateVars);
      def members = cons :: fields + vars;
      foreach (m in members) typebuilder.DefineWithSource(m);
    }
  }
}
