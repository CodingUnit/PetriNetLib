using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using CommonLib.Macros;
using PetriNetModel;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace PetriNetLib
{
  /// <summary>
  /// Description of Generator.
  /// </summary>
  partial class Generator
  {
    model : OutModel;
    proc : PetriNetProcessor;
    converter : Converter;
    typer : Typer;
    typebuilder : TypeBuilder;
    mutable typing_method : MethodBuilder;
    //compiler : CompilerHost = CompilerHost();
    mutable cons_expr : list[PExpr] = [];
    mutable fields    : list[ClassMember] = [];
    mutable init_body : list[PExpr] = [];
    
    public this(model : OutModel, proc : PetriNetProcessor)
    {
      this.typer = proc.Typer;
      this.typebuilder = proc.Typebuilder;
      
      this.model = model;
      this.proc = proc;
      this.converter = proc.Converter;
    }
    
    GetTypeExpr(p : ColourSet) : PExpr
    {
        | ColourSet(_, Colour.Simple(type)) => 
              match (type)
              {
                | "string" => <[ string ]>
                | "int"    => <[ int ]>
                | "intinf" => <[ IntInf ]>
                | "real"   => <[ double ]>
                | "time"   => <[ Time ]>
                | "bool"   => <[ bool ]>
                | "unit"   => <[ void ]>
              }
        
        | ColourSet(_, Product(vals))  => def vals = vals.Map(x => <[ $(TypeFromStr(x)) ]>);
                                          <[ (..$vals) ]>
        | ColourSet(n, Index)
        | ColourSet(n, Enum)           => <[ $(n : usesite) ]>
        | ColourSet(_, List(t, _))     => 
            def inner = t |> TypeFromStr;
            <[ list[$inner]]>
    }
      
    TypeFromStr(str : string) : PExpr
    {
      | "string" => <[ string ]>
      | "int"    => <[ int ]>
      | "intinf" => <[ IntInf ]>
      | "real"   => <[ double ]>
      | "time"   => <[ Time ]>
      | "bool"   => <[ bool ]>
      | "unit"   => <[ void ]>
      | str      => proc.colour_sets[str] |> GetTypeExpr
      
    }
    
    CreatePlace(place : Place) : ClassMember
    {
      def name = place.Name;
      //def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
      def type = GetTypeExpr(place.colour);
      def dest_cont = match (DestContainerType(place))
      {
        | TDestCont.MultiSet  => <[ MultiSet() ]>
        | RandomEnumerable    => <[ RandomArray() ]>
        | SortedSet           => <[ SortedArray() ]>
        | TokenQueue          => <[ TokenQueue() ]>
        | TimedSimpleMultiset => <[ TimedSimpleMultiset() ]>
      }
      <[decl: $(name : usesite) : PetriNetModel.Place.[$type] = PetriNetModel.Place($(name : string), $dest_cont)]>
    }
    
    IsTokenExpr(expr : PExpr) : bool
    {
      | <[ $(_ : usesite) ]> => false
      | _                    => true
    }
    
    CreateDummyMethod() : void
    {
      def meth = typebuilder.DefineAndReturn(<[decl: TypingMethod() : void {}]>);
      typing_method = meth :> MethodBuilder;
    }
    
    //CreateOperators() : void
    //{
    //  def token_op = <[decl: public static @`[T](count : int, tok : T) : IEnumerable[T]
    //                         {
    //                           Enumerable.Repeat(tok, count)
    //                         }]>;
    // _ = typebuilder.DefineWithSource(token_op);
    // def token_combine_op = <[decl: public static @%++[T](tok1 : IEnumerable[T], tok2 : IEnumerable[T]) : IEnumerable[T]
    //                         {
    //                           tok1.Union(tok2)
    //                         }]>;
    // _ = typebuilder.DefineWithSource(token_combine_op);
    //}
    
    internal static GetTokenExpr(expr : PExpr) : PExpr
    {
      def loop(e)
      {
        | <[ $(count : int) ` $expr ]> => Enumerable.Repeat(expr, count).NToList()
        | <[ $left %++ $right ]>       => loop(left) + loop(right)
        | _                            => [expr]
      }
      
      match (loop(expr))
      {
        | [<[$_(..$_)]> as e] => e
        | e                   => <[IEnumerable[..$e]]>
      }
      
    }
    
    
    CreateTran(tran : Transition) : ClassMember
    {
      def name = tran.Name;
      
      def body = CreateTranBody(tran);      
      <[
         decl: public $(name : usesite)() : void
               {
                 when (Lock($(name : usesite)))
                 {
                  $body;
                  Unlock();
                 }
               }
       ]>
    }
    
    //CreateVars(name : string, type : ColourSet) : ClassMember
    //{
    //  def type = GetTypeExpr(type);
    //  <[decl: mutable $(name : usesite) : $type]>
    //}
     
    CreateVals(expr : PExpr) : ClassMember
    {
      | <[ def $(name : usesite) = $val]> => 
          def type = typer.TypeExpr(val);
          def ty = type.ty;
          <[ decl: $(name : usesite) : $(ty : typed) = $val ]>
          
      | _ => null
    }
    
    ProcessFun(expr : PExpr) : PExpr
    {
      | <[ def $(n : usesite)(..$parms) { ..$body } ]> => 
      
            def proc_parm(p, (parm, e))
            {
              match (p)
              {
                | <[parameter: $(n : usesite) : Index.[$(type : usesite)]]> => 
                  match (model.GetIndex(type))
                  {
                    | Some((t, _)) => (<[parameter: $(n : usesite) : $(t : usesite)]> :: parm, <[def $(n : usesite) = $(n : usesite).num ]> :: e)
                    | _            => (parm, e)
                  }
                  
              }
            }
      
      def expr = <[ {..$body} ]>;
      def (parms, expr) = parms.Fold(([], expr :: []), proc_parm);
      def parms = parms.Rev();
          
      <[ def $(n : usesite)(..$parms) { ..$expr } ]>
    }
    
    CreateDecl(expr : PExpr) : ClassMember
    {
      
      | <[ def $(_ : usesite)(..$_) { ..$_ } ]> => 
          
          def func = ProcessFun(expr);
          def ty = Typer(typing_method);
          def te = ty.TypeExpr(func);
          match (func)
          {
            | <[ def $(n : usesite)(..$parms) { ..$expr } ]> =>
                match (te)
                {
                  | TExpr.DefFunctionsIn(h :: _, _) => def ret = h.ReturnType;
                                                      <[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                        {
                                                          ..$expr
                                                        }]>
                }
        }
      | _ => null
    }
    
    //TypeOfExpr(expr : PExpr) : PExpr
    //{
    //  | <[ $(_ : int)]>       => <[ int ]>
    //  | <[ $(_ : string)]>    => <[ string ]>
    //  | <[ $(_ : double)]>    => <[ double ]>
    //  | <[ $(_ : bool)]>      => <[ double ]>
    //  | <[ $(_ : int) ` $t ]> => def t = TypeOfExpr(t); <[ IEnumerable[$t] ]>
    //  | <[ $(_ : usesite) ]>  => null//model.ml_decls.Find();
    //}

    CreateColourSet2(col : ColourSet) : ClassMember.TypeDeclaration
    {
      | ColourSet(n, Colour.Index(_, _, i)) => 
          <[decl: [Record]
            class $(i : usesite) : $(n : usesite)
            {
                                                       
            }
            ]>;
      | _ => null    
    }
    
    CreateColourSet(col : ColourSet) : ClassMember.TypeDeclaration
    {
      | ColourSet(n, Colour.Alias(new_name))  => def name = Macros.UseSiteSymbol(n);
                                                 def mods = AttributesAndModifiers(NemerleModifiers.Private, []);
                                                 def al = TopDeclaration.Alias(name, mods, Typarms.Empty, <[ $(new_name : usesite) ]>);
                                                 al |> ClassMember.TypeDeclaration.TypeDeclaration;
      | ColourSet(n, Colour.Record(vals))     => def fields = vals.Map((n, t) => (n, TypeFromStr(t)));
                                                 def fields = fields.Map((n, t) => <[decl: $(n : usesite) : $t]>);
                                                 <[decl: [Record] class $(n : usesite)
                                                         {
                                                           ..$fields
                                                         }
                                                 ]>
      | ColourSet(n, Colour.Index(mn, mx, i)) => def eval(m)
                                                 {
                                                    def expr = converter.ParseML(m);
                                                    match (expr)
                                                    {
                                                      | <[$(n : int)]>  => n
                                                      | <[$(name : usesite) ]> => 
                                                                           def match_var(x)
                                                                           {
                                                                             | <[ def $(n : usesite) = $_]> => n == name 
                                                                             | _                            => false
                                                                           }
                                                                           
                                                                           match (model.ml_decls.Find(match_var))
                                                                           {
                                                                             | Some(<[ def $(_ : usesite) = $(v : int)]>) => v
                                                                             | _                                  => throw InvalidOperationException()
                                                                           }
                                                    }
                                                 }
                                                 def mn = mn |> eval;
                                                 def mx = mx |> eval;
                                                 
                                                     
                                                  <[decl: [Record]
                                                      class $(n : usesite)
                                                      {
                                                        public static min : int = $(mn : int);
                                                        public static max : int = $(mx : int);
                                                        public num : int;
                                                        
                                                        public override Equals(obj : object) : bool
                                                        {
                                                          | $(n : usesite) as o => o.num == num
                                                          | _                   => false
                                                        }
                                                        
                                                        public override GetHashCode() : int 
                                                        {
                                                          num
                                                        }
                                                        
                                                        public override ToString() : string
                                                        {
                                                          $(n : string) + $"($num)"
                                                        }
                                                        
                                                        public static all() : IEnumerable[$(n : usesite)]
                                                        {
                                                          Enumerable.Range(min, max).Select($(n : usesite))
                                                        }
                                                      }
                                                     ]>
      | ColourSet(n, Colour.Enum(vals)) => def vals = vals.Map(x => <[decl: | $(x : usesite) ]>);
                                           <[decl: enum $(n : usesite)
                                           {
                                             ..$vals
                                           }]>
      | ColourSet(n, Colour.Timed(c))   => CreateColourSet(ColourSet(n, c))
      | _                               => null
    }

    enum TDestCont
    {
      | MultiSet
      | RandomEnumerable
      | TokenQueue
      | SortedSet
      | TimedSimpleMultiset
    }
    
    NumberTokensGet(arc : Arc) : int
    {
      match (arc.expr)
      {
        | <[ $(n : int) ` $_ ]>     => n
        | <[ $(_ : usesite)]>       => 1
        | _                         => -1
      }
    }
    
    DestContainerType(pl : Place) : TDestCont
    {
      match (pl.colour.type)
      {
        | Colour.Sorted => TDestCont.SortedSet
        | Timed         => TDestCont.TimedSimpleMultiset
        | Queue         => TDestCont.TokenQueue
        | _             => def tran = pl.OutputTransitions;
                           def one = tran.Select((_, x) => NumberTokensGet(x)).All(_ == 1);
                           if (one) TDestCont.RandomEnumerable else TDestCont.MultiSet
                          
      }
    }
    
    CreateInitMarking(place : Place) : PExpr
    {
      def combine(e1, e2)
      {
        | (<[Enumerable.Repeat($tok, $(n : int))]>, <[Enumerable.Repeat($tok2, $(n2 : int))]>) when (tok.Equals(tok2)) 
            => <[Enumerable.Repeat($tok, $(n2 + n))]>
        | (<[Enumerable.Repeat($(tok : int), $(n : int))]>, <[Enumerable.Repeat($(tok2 : int), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Union(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : int)]>);
               <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : string), $(n : int))]>, <[Enumerable.Repeat($(tok2 : string), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Union(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : string)]>);
               <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : double), $(n : int))]>, <[Enumerable.Repeat($(tok2 : double), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Union(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : double)]>);
               <[ array[..$val] ]>       
        | _  //(<[Enumerable.Repeat($_, $(_ : int))]>, <[Enumerable.Repeat($_, $(_ : int))]>)                         
            => <[ $e1.Union($e2)]> 
      }
      
      def fold(expr)
      {
        //| <[ {..$e} ]>   => e.Fold(acc, fold)
        | <[ 1 ` $tok]>             => <[ array[$tok] ]>
        | <[ $(n : int) ` $tok]>    => <[ Enumerable.Repeat($tok, $n) ]>
        | <[ $l %++ $r]>            => combine(fold(l), fold(r))
        | e                         => e
      }
      
      if (place.init_mark == null) <[]> else
      {
        def mark = fold(place.init_mark);
        def name = place.name;
        <[ $(name : usesite).Add($mark)]>
      }
    }
    
    
    
    CreateToString() : ClassMember
    {
      def strings = model.places.Map(x => <[ $(x.name : usesite).ToString() ]>);
      <[decl: public override ToString() : string 
      { 
        def str = array[..$strings];
        string.Join(";\n", str)
      }]>
    }
    
    CreateCons() : ClassMember
    {
      def marking = model.places.MapToList(CreateInitMarking);
      if (model.IsTimed || model.IsHaveImmediateTransitions) <[decl: public this(time_step : int = 15) { base(time_step);{..$marking} {..$cons_expr}}]>; 
      else <[decl: public this() { {..$marking} {..$cons_expr} }]>;
    }
    
    CreateTimeMethods() : ClassMember
    {
      def body = model.transitions.Where(_.IsTimed).Map(x => <[ $(x.name : usesite)() ]>);
      def next = model.places.Where(_.IsTimed).Map(x => <[ $(x.name : usesite).NextTokenDelay ]>);
      //cons_expr ::= <[ time_cancel = time_cancel_source.Token; scheduler = Task(_ => TimeStep(), time_cancel)]>;
      //fields ::= <[decl: mutable scheduler : Task ]>;
      //fields ::= <[decl: public Dispose() : void {time_cancel.Cancel(); try {scheduler.Wait() } catch {| AggregateException => ()} finally {time_cancel_source.Dispose()}}]>;
      //fields ::= <[decl: time_cancel_source : CancellationTokenSource = CancellationTokenSource()]>;
      //fields ::= <[decl: mutable time_cancel : CancellationToken]>;
      //init_body ::= <[scheduler.Start()]>;
      def next = next.Map(x => <[ min = PetriNetUtils.TimeMin(min, $x); ]>);
      fields ::= <[decl: public GetNextTime() : DateTime
                   {
                     mutable min : DateTime = DateTime.MaxValue;
                     {..$next}
                     min
                   }]>;
      <[decl: public TimeStep() : void
      {
        {..$body}
      }]>
    }
    
    CreateStepMethod() : void
    {
      def body = model.transitions.Where(x => x.IsImmediate && !x.IsTimed).Map(x => <[ $(x.name : usesite)() ]>);
      if (body.IsEmpty()) 
      {
        //fields ::= <[decl: public Dispose() : void
        //{
        //}]>;
        //fields ::= <[decl: public Step() : void
        //{
        //}]>
      }else 
      {
        fields ::= <[decl: public override TransitionStep() : void
        {
          {..$body}
        }]>
      }
    }
    
    CreateStartMethod() : ClassMember
    {
      <[decl: public Initiate() : void
      {
        {..$init_body}
      }]>
    }
    
    //CreateTranQueue() : void
    //{
    //  fields ::= <[decl: mutable locked : int]>;
    //  fields ::= <[decl: tran_queue : RQueue[Action] = RQueue(32);]>;
    //  fields ::= <[decl: CheckQueue() : void
    //                     {
    //                       mutable val;
    //                       while (tran_queue.DequeIfExist(ref val))
    //                       {
    //                         val()
    //                       }
    //                     }]>
    //}
    
    public Generate() : void
    {      
      //CreateOperators();
      //assert2(false);
      def sets = model.colour_sets.Values.Map(CreateColourSet).Filter(_ != null);
      def sets2 = model.colour_sets.Values.Map(CreateColourSet2).Filter(_ != null);
      def sets = sets + sets2;
      foreach (m in sets) typebuilder.DefineNestedTypeWithSource(m).Compile();
      
      def places = model.places.MapToList(CreatePlace);
      //def vars = model.vars.KeyValuePairs.MapToList(CreateVars);
      
      def time_sched = if (model.IsTimed) CreateTimeMethods() else null;
      CreateStepMethod();
      
      //CreateTranQueue();
      def tostring = CreateToString();
      def start    = CreateStartMethod();
      def cons     = CreateCons();
      
      def members = start :: tostring :: cons :: fields + places;// + vars;
      def members = if (time_sched != null) time_sched :: members else members;
      foreach (m in members) _ = typebuilder.DefineWithSource(m);
    }
    
    public PhaseOne() : void
    {
      //typebuilder.AddImplementedInterface(<[ IDisposable ]>);
      typebuilder.AddImplementedInterface(if (model.IsTimed) <[ TimedPetriNet ]> 
                                          else <[PetriNet]>);
    }
    
    public PhaseTwo() : void
    {
      /*
      [assembly: OperatorAttribute("Nemerle.Core", "*",  false, 260, 261)]
[assembly: OperatorAttribute("Nemerle.Core", "/",  false, 260, 261)]
[assembly: OperatorAttribute("Nemerle.Core", "+",  false, 240, 241)]
      */
      CreateDummyMethod();
      def methods = model.transitions.MapToList(CreateTran);
      def vals = model.ml_decls.Map(CreateVals).Filter(_ != null);
      foreach (m in vals) _ = typebuilder.DefineWithSource(m);
      def decls = model.ml_decls.Map(CreateDecl).Filter(_ != null);
      def decls = decls + methods;
      foreach (m in decls) _ = typebuilder.DefineWithSource(m);
      typebuilder.Compile()
    }
  }
}
