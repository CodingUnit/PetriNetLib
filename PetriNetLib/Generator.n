using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using CommonLib.Macros;

namespace PetriNetLib
{
  /// <summary>
  /// Description of Generator.
  /// </summary>
  class Generator
  {
    model : OutModel;
    proc : PetriNet;
    
    GetTypeExpr(p : ColourSet) : PExpr
    {
        | ColourSet(_, Colour.Simple(type)) => 
              match (type)
              {
                | "string" => <[ string ]>
                | "int"    => <[ int ]>
                | "intinf" => <[ IntInf ]>
                | "real"   => <[ double ]>
                | "time"   => <[ Time ]>
                | "bool"   => <[ bool ]>
                | "unit"   => <[ void ]>
              }
        | ColourSet(_, Product(vals))  => def vals = vals.Map(x => <[ $(TypeFromStr(x)) ]>);
                                          <[ (..$vals) ]>
        | ColourSet(n, Enum)           => <[ $(n : usesite) ]>
        | ColourSet(_, List(t, _))     => 
            def inner = t |> TypeFromStr;
            <[ list[$inner]]>
    }
      
    TypeFromStr(str : string) : PExpr
    {
      | "string" => <[ string ]>
      | "int"    => <[ int ]>
      | "intinf" => <[ IntInf ]>
      | "real"   => <[ double ]>
      | "time"   => <[ Time ]>
      | "bool"   => <[ bool ]>
      | "unit"   => <[ void ]>
      | str      => proc.colour_sets[str] |> GetTypeExpr
      
    }
    
    CreatePlace(place : Place) : ClassMember
    {
      def name = place.name;
      def type = GetTypeExpr(place.colour);
      <[decl: $(name : usesite) : PetriNetModel.Place.[$type] = PetriNetModel.Place()]>
    }
    
    IsTokenExpr(expr : PExpr) : bool
    {
      | <[ $(_ : usesite) ]> => false
      | _                    => true
    }
    
    //class a : IEqualityComparer[PExpr]
    //{
    //  public override GetHashCode() : int
    //  {
    //  }
      
    //  public override Equals(left : PExpr, right : PExpr) : bool
    //  {
    //  }
    //}
    
    //EvalTokenExpr(expr : PExpr) : PExpr
    //{
    //  | <[ $(lit : int)]>            => expr
    //  | <[ $(count : int) ` $expr ]> => expr
    //  | <[ $left %++ $right ]>       => match (left, right)
    //                                    {// int, real, string, tuple,
    //                                      | (<[ $(count : int) ` $expr ]>, <[ $(count2 : int) ` $expr2 ]>) =>
    //                                    }
    //}
    
    GetTokenExpr(expr : PExpr) : list[PExpr]
    {
      | <[ $(count : int) ` $expr ]> => Enumerable.Repeat(expr, count).NToList()
      | <[ $left %++ $right ]>       => GetTokenExpr(left) + GetTokenExpr(right)
      | _                            => [expr]
    }
    
    CreateTranBody(tran : Transition) : PExpr
    {
      def input = tran.InputPlaces;
      def output = tran.OutputPlaces;
      
      def create_check(p, a)
      {
        def name = p.name;
        if (a.expr |> IsTokenExpr)
        {
          def tok = GetTokenExpr(a.expr);
          <[ $(name : usesite).Have(..$tok) ]>
        } else
        {
          <[ $(name : usesite).HaveTokens ]>
        }
      }
      
      def create_run_body(p, a)
      {
        def name = p.name;
        if (a.expr |> IsTokenExpr)
        {
          def expr = GetTokenExpr(a.expr);
          <[ $(name : usesite).GetMany(array[..$expr])]>
        } else
        {
          <[def $(a.expr) = $(name : usesite).Get()]>
        }
      }
      
      def create_out(p, a)
      {
        def name = p.name;
        match (a.expr)
        {
          | <[ 1 ` $e ]>
          | <[ $_(..$_)]> as e                                    
          | <[ $(_ : usesite) ]> as e      => <[ $(name : usesite).Add($e)]>
          | <[ $(_ : int) ` $_ ]> 
          | <[ $_ %++ $_ ]>                => def expr = GetTokenExpr(a.expr);
                                              <[ $(name : usesite).AddMany(array[..$expr])]>
          
        }
      }
      
      def checks = input.Map(create_check);
      def checks = checks.Reduce((x, y) => <[ $x && $y]>);
      def run_body = input.Map(create_run_body);
      def out_body = output.Map(create_out);
      <[ 
         when ($checks)
         {
           {..$run_body}
           {..$out_body}
         }
       ]>
    }
    
    CreateTran(tran : Transition) : ClassMember
    {
      def name = tran.name;
      def body = CreateTranBody(tran);
      <[
         decl: public $(name : usesite)() : void
               {
                 $body
               }
       ]>
    }
    
    CreateVars(name : string, type : ColourSet) : ClassMember
    {
      def type = GetTypeExpr(type);
      <[decl: $(name : usesite) : $type]>
    }
    
    CreateDecl(expr : PExpr) : ClassMember
    {
      | <[ def $(name : usesite) = $val]> => <[decl: $(name : usesite) = $val]>
      | <[
            def $(n : usesite)(..$parms)
            {
              ..$body
            }
          ]>                              => <[decl: $(n : usesite)(..$parms)
                                                     {
                                                       ..$body
                                                     }]>
    }
    
    public Generate() : void
    {
      def fields = model.places.Map(CreatePlace);
      def methods = model.transitions.Map(CreateTran);
      def a = model.vars.KeyValuePairs.Map(CreateVars);
      model.ml_decls.Map(CreateDecls);
    }
  }
}
