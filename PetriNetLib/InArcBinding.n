using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;

using System;
using System.Collections.Generic;
using System.Linq;

namespace PetriNetLib
{
  [Record]
  class InArcBinding
  {
    public place      : Place;

    public transition : Transition;
    public Depends     : list[InArcBinding] {get;set;}
      //public NeedBinding : bool {get;set;}

    public priority : int
    {
        [Memoize]
      get
      {
        if (Depends == null || Depends.IsEmpty()) 0 else Depends.Max(_.priority) + 1
      }
    }

    public name       : string
    {
        [Memoize]
      get
      {
        place.name
      }
    }

    public expr       : PExpr;

    public bind_var : string
    {
        [Memoize]
      get
      {
        match (expr)
        {
          | <[ $(n : usesite) ]> => n
          | _                    => null
        }
      }
    }

      //public before_bind_expr  : PExpr
      //{
      //  [Memoize]
      //  get
      //  {
      //    match (expr)
      //    {
      //      | <[ $(_ : usesite)(..$_) ]> => <[ def $(introduced_var : name) = $expr ]>
      //      | _                          => <[]>
      //    }
      //  }
      //}

    public source_token_peek : PExpr
    {
      [Memoize]
      get
      {
        //if (place.IsTimed)
        //{
        //  def name = $"$(name)_tok";
        //    <[ $(name : usesite) ]>
        //} else
          if (place.IsIndexedContainer)
            <[ $(name : usesite).PeekIndexed() ]> else
            <[ $(name : usesite).Peek() ]>
      }
    }

    source_token_name : string
    {
      [Memoize]
      get
      {
        $"$(name)_tok"
      }
    }
    
    public timed_bind_expr : PExpr
    {
      [Memoize]
      get
      {
        if (place.IsTimed)
        {
            //if (place.IsIndexedContainer) 
              //<[ def ($(name : usesite), $($"$(name)_idx" : usesite)) = $source_token ]> else
          match (expr)
          {
            //| <[ $e %@+ $time ]>   => <[ def $(source_token_name : usesite) = ]>
            | <[ $(n : usesite) ]> => if (place.IsIndexedContainer) 
                                          <[ def ($(source_token_name : usesite), $(idx_name(n)) : usesite)  = $source_token_peek ]> else
                                          <[ def $(source_token_name : usesite) = $source_token_peek ]>
            | _                     => <[]>
          }
          
        } else
        {
          <[]>
        }
      }
    }

    idx_name(name : string) : string
    {
      $"$(name)_idx"
    }
    
    public bind_expr  : PExpr
    {
      [Memoize]
      get
      {
        if (place.IsTimed)
        {
          def time_expr = timed_bind_expr;
          def bind_expr = match (expr)
          {
            
            | <[ $(_ : usesite) ]> => <[ def $expr = $(source_token_name : usesite) ]>
            | _                    => <[]>
          }
          <[ $time_expr; $bind_expr]>
        } else
        match (expr)
        {
//          | <[ () ]>             => <[]>
          | <[ $(n : usesite) ]> => if (place.IsIndexedContainer) 
                                        <[ def ($expr, $(idx_name(n) : usesite)) = $source_token_peek ]> else
                                        <[ def $expr = $source_token_peek ]>
          | _                    => <[]>
        }
      }
    }

      //public introduced_var : Name
      //{
      //  [Memoize]
      //  get
      //  {
      //    match (expr)
      //    {
      //      | <[ $(n : usesite)(..$_) ]> => Macros.NewSymbol(n.Substring(0, 2));
      //      | _                          => null
      //    }
      //  }
      //}

    public check_expr : PExpr
    {
      [Memoize]
      get
      {
        match (expr)
        {
          | <[ () ]>
          | <[ $(_ : usesite)]> => <[ $(name : usesite).HaveTokens]>
          | _                   => def tok = Generator.GetTokenExpr(expr);
                                   <[ $(name : usesite).Have($tok) ]>
        }

      }
    }

    public extract_expr   : PExpr
    {
      [Memoize]
      get
      {
          match (expr)
          {
            //| <[ $e %@+ $time ]>  => <[]>
            | <[ () ]>            => <[ $(name : usesite).Get()]>
            | <[ $(n : usesite)]> => if (place.IsIndexedContainer) 
                                     <[ $(name : usesite).GetIndexed($(idx_name(n) : usesite))]> else 
                                     <[ $(name : usesite).Get($expr)]>
            | _                   => <[ $(name : usesite).Get($expr)]>
          }
      }
    }

  }
}
