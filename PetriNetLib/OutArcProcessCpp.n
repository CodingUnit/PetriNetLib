using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;
using PetriNetModel;

namespace PetriNetLib
{
  /// <summary>
  /// Description of OutArcProcess.
  /// </summary>
  [Record]
  class OutArcProcessCpp
  {

    public place      : Place;
    public transition : Transition;
    public arc        : Arc;
    public gen        : CppGenerator;
    
    public name : string
    {
      [Memoize]
      get
      {
        place.Name
      }
    }
    
    public expr : PExpr
    {
      [Memoize]
      get
      {
        arc.expr
      }
    }

    is_time_expr : bool
    {
      [Memoize]
      get
      {
        match (expr)
        {
          | <[ $_e %@ $_time]>               
          | <[ $_e %@+ $_time]> => true
          | _                   => false
        }
      }
    }
    
    add_token_expr : string
    {
      [Memoize]
      get
      {
        def unfold(e)
        {
          | <[ () ]> => <#unit.instance()#>
          | e        => e |> gen.ConvExpr(_, false)
        }
        
        def add(e)
        {
          | <[ () ]>                       => <#unit.instance()#>
          | <[ $e %@+ $(time : int)]>      => match (global_time)
                                              {
                                                | <[ $(t : int)]> => def time = time + t;     
                                                                     $<#add_time($(unfold(e)), $time)#>
                                              } 
                                              
          | <[ $e %@+ $time]>              => $<#add_time($(unfold(e)), $time + $global_time_str)#>
          | <[ $_ %++ $_ ]> as e           => gen.GetTokenExpr(e)
          | <[ 1 ` $e ]>                   => add(e)
          | <[ $_(..$_)]> as e
          | <[ $(_ : usesite) ]> as e
          | <[ $(_ : int) ` $_ ]> as e     
          | e                              => e |> gen.ConvExpr(_, false)
        }
        
        add(expr)
      }
    }
    
    public global_time_str : string
    {
      [Memoize]
      get
      {
        global_time |> gen.ConvExpr(_, false)
      }
    }
    
    public global_time : PExpr
    {
      [Memoize]
      get
      {
        match (transition.time_expr)
        {
          | <[]>            => <[0]>
          | <[ @Delay($t)]> => t
        }
      }
    }
    
    public place_ena : string
    {
      [Memoize]
      get
      {
        $"pl_$name"
      }
    }
    
    public add_token : string
    {
      [Memoize]
      get
      {
        if (place.IsTimed)
        {
          if (is_time_expr)
          {
            $<#$name.add($add_token_expr);#>
          } else
          {
            $<#$name.add(add_time($add_token_expr, $global_time_str));#>
          }
        } else
        {
          $<#$name.add($add_token_expr);#>
        }
      }
      
    }
  }
}
