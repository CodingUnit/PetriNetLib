using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;
using PetriNetModel;

namespace PetriNetLib
{
  /// <summary>
  /// Description of OutArcProcess.
  /// </summary>
  [Record]
  class OutArcProcessCpp
  {

    public place      : GenPlaceCpp;
    public transition : Transition;
    public arc        : Arc;
    public gen        : CppGenerator;
    
    public name : string
    {
      [Memoize]
      get
      {
        place.Name
      }
    }
    
    public expr : PExpr
    {
      [Memoize]
      get
      {
        arc.expr
      }
    }

    is_time_expr : bool
    {
      [Memoize]
      get
      {
        match (expr)
        {
          | <[ $_e %@ $_time]>               
          | <[ $_e %@+ $_time]> => true
          | _                   => false
        }
      }
    }
    
    add_token_expr : string
    {
      [Memoize]
      get
      {
        def unfold(e)
        {
          | <[ () ]> => <#1#>
          | e        => e |> gen.ConvExpr(_, false)
        }
        
        def add(e)
        {
          | <[ () ]>                       => <#1#>
          | <[ $e %@+ $(time : int)]>      => match (global_time)
                                              {
                                                | <[ $(t : int)]> => def time = time + t;     
                                                                     $<#add_time($(unfold(e)), $time)#>
                                                | _               => null
                                              } 
          | <[ $(_ : int) ` $_ ]> as e     => e |> gen.ConvExpr(_, false)                                    
          | <[ $e %@+ $time]>              => $<#add_time($(unfold(e)), $time + $global_time_str)#>
          | <[ $_ %++ $_ ]> as e           => gen.GetTokenExpr(e)
          | <[ 1 ` $e ]>                   => add(e)
          | <[ $_(..$_)]> as e
          | <[ $(_ : usesite) ]> as e
          | e                              => e |> gen.ConvExpr(_, false)
        }
        
        add(expr)
      }
    }
    
    public global_time_str : string
    {
      [Memoize]
      get
      {
        global_time |> gen.ConvExpr(_, false)
      }
    }
    
    public global_time : PExpr
    {
      [Memoize]
      get
      {
        match (transition.time_expr)
        {
          | <[]>            => <[0]>
          | <[ @Delay($t)]> => t
          | _               => null
        }
      }
    }
    
    public place_ena : string
    {
      [Memoize]
      get
      {
        $"pl_$name"
      }
    }
    
    public add_token : string
    {
      [Memoize]
      get
      {
        if (place.IsTimed)
        {
          if (is_time_expr)
          {
            $<#$name.add($add_token_expr);#>
          } else
          {
            $<#$name.add(add_time($add_token_expr, $global_time_str));#>
          }
        } else
        {
          match (place.DestContainerType)
          {
            | ZeroSingle // имеет 0 или 1 фишку, для отсутствия используется 0 если INT
            | MinusSingle 
            | Var       => $"$(name) = $add_token_expr;"
            | Single    => if (place.IsUnit)
                           {
                             $<#$(name) = $add_token_expr;#>
                           } else
                           {
                             $<#$(name) = $add_token_expr;
                              $(name)_flag = true;#>
                           }
            | _ => $<#$name.add($add_token_expr);#>
          }
          
        }
      }
      
    }
  }
}
