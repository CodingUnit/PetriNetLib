using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;
using PetriNetModel;

namespace PetriNetLib
{
  /// <summary>
  /// Description of OutArcProcess.
  /// </summary>
  [Record]
  class OutArcProcessCpp
  {

    public place      : GenPlaceCpp;
    public transition : GenTranCpp;
    public arc        : Arc;
    public gen        : CppGenerator;
    
    public name : string
    {
      [Memoize]
      get
      {
        place.Name
      }
    }
    
    public expr : PExpr
    {
      [Memoize]
      get
      {
        arc.expr
      }
    }

    is_time_expr : bool
    {
      [Memoize]
      get
      {
        match (expr)
        {
          | <[ $_e %@ $_time]>               
          | <[ $_e %@+ $_time]> => true
          | _                   => false
        }
      }
    }
    
    public IsCopyVar : bool
    {
      [Memoize]
      get
      {
        transition.IsCopyVar(place, arc)
      }
    }
    
    
    add_token_expr : string
    {
      [Memoize]
      get
      {
        //def unfold(e)
        //{
        //  | <[ () ]> => <#1#>
        //  | e        => e |> gen.ConvExpr(_, false)
        //}
        
        def add(e)
        {
          | <[ () ]>                       => <#1#>
          //match (global_time)
                                              //{
                                              //  | <[ $(t : int)]> => def time = time + t;     
                                                                     
                                              //  | _               => null
                                              //} 
          | <[ 1 ` $e ]>                   => add(e)                                    
          | <[ $(_ : int) ` $_ ]> as e     => e |> gen.ConvExpr(_, false)                                    
          | <[ $_ %++ $_ ]> as e           => gen.GetTokenExpr(e)
          
          | <[ $_(..$_)]> as e
          | <[ $(_ : usesite) ]> as e
          | e                              => e |> gen.ConvExpr(_, false)
        }
        
        add(arc.ExprWithoutTime)
      }
    }
    
    public global_time_str : string
    {
      [Memoize]
      get
      {
        global_time |> gen.ConvExpr(_, false)
      }
    }
    
    public global_time : PExpr
    {
      [Memoize]
      get
      {
        match (transition.time_expr)
        {
          | <[]>            => <[0]>
          | <[ @Delay($t)]> => t
          | _               => null
        }
      }
    }
    
    public place_ena : string
    {
      [Memoize]
      get
      {
        $"pl_$name"
      }
    }
    
    public add_token : string
    {
      [Memoize]
      get
      {
        if (place.IsTimed)
        {
          def time_add = if (arc.TimeExpr is <[]>) "" else arc.TimeExpr |> gen.ConvExpr(_, true);
          def time = if (time_add.IsEmpty()) $"\n$(name)_time = time();" else $"\n$(name)_time = time() + $time_add;";
          if (IsCopyVar) time else
          match (place.DestContainerType)
          {
            | ZeroSingle // имеет 0 или 1 фишку, для отсутствия используется 0 если INT
            | MinusSingle 
            | Var       => $"$(name) = $add_token_expr;$time"
            | Single    => if (place.IsUnit)
                           {
                             $<#$(name) = $add_token_expr;$time#>
                           } else
                           {
                             $<#$(name) = $add_token_expr;
                              $(name)_flag = true;$time#>
                           }
            | _ => def expr = if (time_add.IsEmpty()) add_token_expr else $"\nadd_time($add_token_expr, $time_add);";
                   $<#$name.add($expr);#>
          }
          //if (is_time_expr)
          //{
          //  $<#$name.add($add_token_expr);#>
          //} else
          //{
          //  $<#$name.add(add_time($add_token_expr, $global_time_str));#>
          //}
        } else
        {
          if (IsCopyVar) "" else
          if (place.IsFuncPlace)
          {
            $<#$(name)($add_token_expr);#>
          } else
          match (place.DestContainerType)
          {
            | ZeroSingle // имеет 0 или 1 фишку, для отсутствия используется 0 если INT
            | MinusSingle 
            | Var       => $"$(name) = $add_token_expr;"
            | Single    => if (place.IsUnit)
                           {
                             $<#$(name) = $add_token_expr;#>
                           } else
                           {
                             $<#$(name) = $add_token_expr;
                              $(name)_flag = true;#>
                           }
            | _ => $<#$name.add($add_token_expr);#>
          }
          
        }
      }
      
    }
  }
}
