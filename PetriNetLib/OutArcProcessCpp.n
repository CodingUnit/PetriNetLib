using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;
using PetriNetModel;

namespace PetriNetLib
{
  /// <summary>
  /// Description of OutArcProcess.
  /// </summary>
  [Record]
  class OutArcProcessCpp
  {

    public place      : GenPlaceCpp;
    public transition : GenTranCpp;
    public arc        : Arc;
    public gen        : CppGenerator;

    public name : string
    {
      [Memoize]
      get
      {
        place.Name
      }
    }

    public expr : PExpr
    {
      [Memoize]
      get
      {
        arc.expr
      }
    }

    is_time_expr : bool
    {
      [Memoize]
      get
      {
        match (expr)
        {
          | <[ $_e %@ $_time]>               
          | <[ $_e %@+ $_time]> => true
          | _                   => false
        }
      }
    }

    public IsCopyVar : bool
    {
      [Memoize]
      get
      {
        transition.IsCopyVarOut(place, arc)
      }
    }

    add_token_ptr_expr : string * string
    {
      get
      {
        def var = Macros.NewSymbol();
        
        def add(e)
        {
          | <[ () ]>                       => ($<#char $var = 1;
          #>, var.ToString());
          //match (global_time)
                                              //{
                                              //  | <[ $(t : int)]> => def time = time + t;     

                                              //  | _               => null
                                              //} 
          | <[ 1 ` $e ]>                   => add(e)
          
          | <[ $(n : usesite) ]>           => ("", n)
          | <[ $_ %++ $_ ]> as e           => def e = gen.GetTokenExpr(e);
                                              def ty = place.Colour.DestType;
                                              ($<#$ty $var = $e;
                                              #>, $<#$var#>)
          | <[ $(_ : int) ` $_ ]> as e                                         
          | <[ $_(..$_)]> as e             
          | e                              => def e = e |> gen.ConvExprPlaceCtx(_, place, false);
                                              def ty = place.Colour.DestType;
                                              ($<#$ty $var = $e;
                                              #>, $<#$var#>)
        }

        add(arc.ExprWithoutTime)
      }
    }
    
    add_ctx_expr[T](func : void -> T) : string * T
    {
      def res = func();
      def expr = gen.ReadCtxVar();
      if (expr.IsEmpty()) ("", res) else ($<#..$(expr; "\n")
      #>, res)
    }
    
    add_token_expr : string
    {
      get
      {
        //def unfold(e)
        //{
        //  | <[ () ]> => <#1#>
        //  | e        => e |> gen.ConvExpr(_, false)
        //}

        def add(e)
        {
          | <[ () ]>                       => <#1#>
          //match (global_time)
                                              //{
                                              //  | <[ $(t : int)]> => def time = time + t;     

                                              //  | _               => null
                                              //} 
          | <[ 1 ` $e ]>                   => add(e)                                    
          | <[ $(_ : int) ` $_ ]> as e     => e |> gen.ConvExprPlaceCtx(_, place, false)                                    
          | <[ $_ %++ $_ ]> as e           => gen.GetTokenExpr(e)

          | <[ $_(..$_)]> as e
          | <[ $(_ : usesite) ]> as e
          | e                              => e |> gen.ConvExprPlaceCtx(_, place, false)                                    
        }

        add(arc.ExprWithoutTime)
      }
    }

    
    public global_time_str : string
    {
      [Memoize]
      get
      {
        global_time |> gen.ConvExpr(_, false)
      }
    }

    public global_time : PExpr
    {
      [Memoize]
      get
      {
        match (transition.time_expr)
        {
          | <[]>            => <[0]>
          | <[ @Delay($t)]> => t
          | _               => null
        }
      }
    }

    public place_ena : string
    {
      [Memoize]
      get
      {
        $"pl_$name"
      }
    }

    public add_token : string
    {
      [Memoize]
      get
      {
        if (place.IsTimed)
        {
          def time_add = if (arc.TimeExpr is <[]>) "" else arc.TimeExpr |> gen.ConvExpr(_, true);
          def time = if (time_add.IsEmpty()) $"\n$(name)_time = time();" else $"\n$(name)_time = time() + $time_add;";
          if (IsCopyVar) time else
            match (place.DestContainerType)
            {
              | ZeroSingle // имеет 0 или 1 фишку, для отсутствия используется 0 если INT
              | MinusSingle 
              | Var       => $"$(name) = $add_token_expr;$time"
              | Single    => if (place.IsUnit)
                             {
                               $<#$add_ctx_expr$(name) = $add_token_expr;$time#>
                             } else
                             {
                            $<#$add_ctx_expr$(name) = $add_token_expr;
                              $(name)_flag = true;$time#>
                             }
              | _ => def expr = if (time_add.IsEmpty()) add_token_expr else $"\nadd_time($add_token_expr, $time_add);";
                  $<#$add_ctx_expr$name.add($expr);#>
            }
          //if (is_time_expr)
          //{
          //  $<#$name.add($add_token_expr);#>
          //} else
          //{
          //  $<#$name.add(add_time($add_token_expr, $global_time_str));#>
          //}
        } else
        {
          def (ctx, add) = add_ctx_expr(_ => add_token_expr);
          if (IsCopyVar) "" else
            if (place.IsFuncPlace)
            {
              $<#$ctx$(name)($add);#>
            } else
            {
              match (place.port)
              {
                | Some(PortType.Out) => 
                    if (place.Colour.IsComplexType) 
                    $<#$ctx$(name).exec_ref($add);#> else
                    $<#$ctx$(name).exec($add);#>
                | Some(PortType.InOut) => 
                    def parm = place.Colour.ParmType;
                    if (place.Colour.IsComplexType) 
                    $<#$(ctx)bool in = $(name).exec_ret<bool, $parm>($add);#> else
                    $<#$(ctx)bool in = $(name).exec_ret<bool, $parm>($add);#>
                | _ => match (place.DestContainerType)
                       {
                         | ZeroSingle // имеет 0 или 1 фишку, для отсутствия используется 0 если INT
                         | MinusSingle 
                         | Var       => $"$(name) = $add;"
                         | Single    => if (place.IsUnit)
                                        {
                                          $<#$ctx$(name) = $add;#>
                                        } else
                                        {
                                          $<#$ctx$(name) = $add;
                                          $(name)_flag = true;#>
                                        }
                         | _ => def (ctx, (var, add)) = add_ctx_expr(_ => add_token_ptr_expr);
                                               //def (var, add) = add_token_ptr_expr;
                                $<#$ctx$var$name.add((void *)&$add);#>
                       }
              }
              
            }
        }
      }
    }
  }
}
