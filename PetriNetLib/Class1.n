using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections.Immutable;
using CommonLib.Macros;

namespace PetriNetLib
{
  [Lens]
  [Record]
  public class Colour
  {
    public idx  : int;
    public type : Type;
  }
  
  [Record]
  public class Arc
  {
    public colour : Colour;
    public expr   : ArcExpr;
  }
  
  [Record]
  public class TokenVal[T]
  {
  }
  
  [Record]
  public class Token
  {
    public value  : object;//TokenVal[Colour];
    public colour : Colour;
  }
  
  [Record]
  [Lens]
  public class Place
  {
    public idx : int;
    public name : string;
    public colour : Colour;
    public marking : list[Token];
    
    public net : PetriNet;
      
    public override GetHashCode() : int
    {
      idx
    }
  }
  
  [Record]
  public class TokenSet
  {
    public num   : int;
    public token : Token;
  }
  
  [Record]
  [Lens]
  public class Transition
  { 
    public idx : int;
    public name : string;
    public guard : Guard;
    
    public net : PetriNet;
    
    public override GetHashCode() : int
    {
      idx
    }
  }
  
  public class GuardExpr : Guard
  {
  }
  
  [Record]
  public class Guard
  {
    public virtual Eval() : bool {true}
  }
  
  public class GuardFunc : Guard
  {
    public Func : Token -> bool;
  }
  
  public variant ListExpr
  {
    // head :: tail
  }
  
  [Record]
  public variant ArcExpr
  {
    | Constant { val : int; }
    | NumTok { tok : Token; }
    | Var { n : string; }
    | Tuple { tup : list[Var];}
    | ListExpr {expr : ListExpr;}
    | Delay { expr : ArcExpr; delay : ArcExpr; }
    | Func {}
    // record
  }
  
  class ColourSet
  {
    public name : string;
    public type : Colour;
  }
  
  class Declarations
  {
    public vars        : Hashtable[string, Colour];
    public colour_sets : Hashtable[string, ColourSet];
  }
  
  [Lens]
  [Record]
  public class PetriNet
  {
    mutable places      : ImmutableList[Place] = ImmutableList.Create();
    mutable transitions : ImmutableList[Transition] = ImmutableList.Create();
    
    matrix_len         : array[int] = array[];
    input_matrix       : array[3, Arc];//List[List[List[Arc]]];
    output_matrix      : array[3, Arc];
    incidence_matrix   : array[3, int];
    colours            : list[Colour] = [];

    InputTransitionArcs : list[Transition * list[Place * Arc]]
    {
      [Memoize]
      get
      {
        OutputArcs.GroupBy((_, t, _) => t).Map(x => (x.Key, x.Map((p, _, a) => (p, a))));
      }
    }
    
    InputArcs : IEnumerable[Place * Transition * Arc]
    {
      [Memoize]
      get
      {
        foreach (c in Enumerable.Range(0, colours.Length))
          foreach (p in Enumerable.Range(0, places.Count))
            foreach (t in Enumerable.Range(0, transitions.Count))
            {
              def arc = input_matrix[p, t, c];
              when (arc != null)
                yield (places[p], transitions[t], arc)
            }
       }
    }

    OutputArcs : IEnumerable[Place * Transition * Arc]
    {
      [Memoize]
      get
      {
        foreach (c in Enumerable.Range(0, colours.Length))
          foreach (p in Enumerable.Range(0, places.Count))
            foreach (t in Enumerable.Range(0, transitions.Count))
            {
              def arc = output_matrix[p, t, c];
              when (arc != null)
                yield (places[p], transitions[t], arc)
            }
       }
    }
    
    //arcs               : List[List[Arc]] = List();
    //transition_input_matrix  : List[List[int]];
    //transition_output_matrix : List[List[int]];
    //place_arcs               : List[List[Arc]];
    //transition_arcs          : List[List[Arc]];
    
    //place_idx : int;
    //transition_idx : int;
    //colour_idx : int;
    
    //GetEdgesNull(count : int) : List[List[Arc]]
    //{
    //  ListUtils.Init(count, _ => null).ToList()
    //}
    
    //GetEmptyMatrix(count : int) : IEnumerable[List[List[Arc]]]
    //{
    //  Enumerable.Repeat(ListUtils.Init(places.Count, _ => null).ToList(), count)
    //}
    
    BuildMatrix() : PetriNet
    {
      def col    = colours.Length;
      def places = places.Count;
      def tran   = transitions.Count;
      
      
      if (matrix_len.Length == 0 || matrix_len[0] != col || matrix_len[1] != places || matrix_len[2] != tran)
      {
        def net = PetriNet.input_matrix_lens.Set(this, array(col, places, tran)) |>
        PetriNet.output_matrix_lens.Set(_, array(col, places, tran))   |>
        PetriNet.incidence_matrix_lens.Set(_, array(col, places, tran));
      
        for (mutable c = 0; c < col; c++)
          for (mutable p = 0; p < places; p++)
            for (mutable t = 0; t < tran; t++)
            {
              def output = if (output_matrix[c, p, t] != null) 1 else 0; 
              def input = if (input_matrix[c, p, t] != null) 1 else 0; 
              incidence_matrix[c, p, t] = output - input;
            }
        net
      } else this
    }
    
    public AddColour(col : Colour) : PetriNet
    {
      def col = Colour.idx_lens.Set(col, colours.Length);
      //col.idx = colour_idx;
      
      PetriNet.colours_lens.Update(_, col :: _)
    }
    
    public AddPlace(place : Place) : Place
    {
      def place = Place.idx_lens.Set(place, places.Count);
      places = places.Add(place);
      place
    }
    
    public AddTransition(tran : Transition) : Transition
    {
      def tran = Transition.idx_lens.Set(tran, transitions.Count);
      transitions = transitions.Add(tran);
      tran
    }
    
    public AddArc(place : Place, arc : Arc, tran : Transition) : void
    {
      def idx  = place.idx;
      def tidx = tran.idx;
      def cidx = arc.colour.idx;
      output_matrix[cidx, idx, tidx] = arc;
    }
    
    public AddArc(tran : Transition, arc : Arc, place : Place) : void
    {
      def idx  = place.idx;
      def tidx = tran.idx;
      def cidx = arc.colour.idx;
      input_matrix[cidx, idx, tidx] = arc;
    }
    
     public AddToken(place_idx : int, tok : Token) : void
     {
       def set_tok(t)
       {
         Place.marking_lens.Update(t[place_idx], tok :: _) |> t.SetItem(place_idx, _)
       }
       
       ThreadSafeUtils.LockFreeUpdate(ref places, set_tok)
       //places[place_idx] = place;
     }
     
     public AddToken(place : Place, tok : Token) : void
     {
     }
     
     public Step() : void
     {
       def input_places_contains_tokens = InputTransitionArcs.Where((t, a : list[_]) => a.All((p, _) => !p.marking.IsEmpty()));
       def places = input_places_contains_tokens.SelectMany((_, l) => l.Select((p, _ : Arc) => p));
       // забираем токены из входных позиций и передаем в выходные позиции перехода
       //OutputArcs.Where((p, t, a) => !p.marking.IsEmpty());
     }
  }
}
