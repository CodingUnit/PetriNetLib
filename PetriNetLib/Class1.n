using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections.Immutable;
using CommonLib.Macros;

namespace PetriNetLib
{
  [Lens]
  [Record]
  public class Colour
  {
    public idx  : int;
    public type : Type;
  }
  
  [Record]
  public class Arc
  {
    public colour : Colour;
    public expr   : ArcExpr;
  }
  
  [Record]
  public class TokenVal[T]
  {
  }
  
  [Record]
  public class Token
  {
    public value  : object;//TokenVal[Colour];
    public colour : Colour;
    
    public this(val : object)
    {
      value = val;
      colour = Colour(-1, val.GetType());
    }
    
  }
  
  [Record]
  [Lens]
  public class Place
  {
    public idx : int;
    public name : string;
    public colour : Colour;
    public marking : list[Token];
    
    public net : PetriNet;
      
    public RemoveToken() : Place * Token
    {
      match (marking)
      {
        | []           => throw InvalidOperationException()
        | head :: tail => (Place.marking_lens.Set(this, tail), head)
      }
    }
    
    public AddToken(tok : Token) : Place
    {
      Place.marking_lens.Set(this, tok :: marking)
    }
    
    public override GetHashCode() : int
    {
      idx
    }
  }
  
  [Record]
  public class TokenSet
  {
    public num   : int;
    public token : Token;
  }
  
  [Record]
  [Lens]
  public class Transition
  { 
    public idx : int;
    public name : string;
    public guard : Guard;
    
    public net : PetriNet;
    
    public context  : TransitionExecContext;
    
    public override GetHashCode() : int
    {
      idx
    }
  }
  
  public class GuardExpr : Guard
  {
  }
  
  [Record]
  public class Guard
  {
    public virtual Eval() : bool {true}
  }
  
  public class GuardFunc : Guard
  {
    public Func : Token -> bool;
  }
  
  public variant ListExpr
  {
    // head :: tail
  }
  
  public class CondExpr
  {
  }
  
  public variant Oper
  {
    | Mul
    | Div
    | Add
    | Sub
    | Mod
  }
  
  [Record]
  public variant ArcExpr
  {
    | Constant { val : object; }
    | NumTok { num : int; tok : ArcExpr; }
    | Var { n : string; }
    | Tuple { tup : list[ArcExpr];}
    | ListExpr {expr : ListExpr;}
    | Delay { expr : ArcExpr; delay : ArcExpr; }
    | IfThen { expr : CondExpr; then : ArcExpr; els : ArcExpr; }
    | Func { name : string; parms : list[ArcExpr]; }
    | BinaryOperator {left : ArcExpr; op : Oper; right : ArcExpr; }
    // record
  }
  
  public class ColourSet
  {
    public name : string;
    public type : Colour;
  }
  
  public class Declarations
  {
    public vars        : Hashtable[string, Colour];
    public colour_sets : Hashtable[string, ColourSet];
  }
  
  public variant ExecError
  {
    | TokenConstantNotFound { place : Place; val : object }
    | VarNotFound {name : string}
    | TypeTokenNotCompat {incol : Colour; outcol : Colour;place : Place}
  }
  
  [Lens]
  [Record]
  public class TransitionExecContext
  {
    public binding : Hashtable[string, Token];
    public tokens  : list[Token];
    public error   : list[ExecError];
    
    public all_getted_tokens : list[Token]
    {
      get
      {
        []
      }
    }
  }
  
  [Lens]
  [Record]
  public class PetriNet
  {
    mutable places      : ImmutableList[Place] = ImmutableList.Create();
    mutable transitions : ImmutableList[Transition] = ImmutableList.Create();
    public decls : Declarations;
    
    matrix_len         : array[int] = array[];
    input_matrix       : array[3, Arc];//List[List[List[Arc]]];
    output_matrix      : array[3, Arc];
    incidence_matrix   : array[3, int];
    colours            : list[Colour] = [];

    InputTransitionArcs : list[Transition * list[Place * Arc]]
    {
      [Memoize]
      get
      {
        OutputArcs.GroupBy((_, t, _) => t).Map(x => (x.Key, x.Map((p, _, a) => (p, a))));
      }
    }
    
    InputArcs : IEnumerable[Place * Transition * Arc]
    {
      [Memoize]
      get
      {
        foreach (c in Enumerable.Range(0, colours.Length))
          foreach (p in Enumerable.Range(0, places.Count))
            foreach (t in Enumerable.Range(0, transitions.Count))
            {
              def arc = input_matrix[p, t, c];
              when (arc != null)
                yield (places[p], transitions[t], arc)
            }
       }
    }

    TranOutputArcs(tran : Transition) : IEnumerable[Place * Arc]
    {
      InputArcs.Where((_, t, _) => t : object == tran).Select((p, _, a) => (p, a))
    }
    
    OutputArcs : IEnumerable[Place * Transition * Arc]
    {
      [Memoize]
      get
      {
        foreach (c in Enumerable.Range(0, colours.Length))
          foreach (p in Enumerable.Range(0, places.Count))
            foreach (t in Enumerable.Range(0, transitions.Count))
            {
              def arc = output_matrix[p, t, c];
              when (arc != null)
                yield (places[p], transitions[t], arc)
            }
       }
    }
    
    //arcs               : List[List[Arc]] = List();
    //transition_input_matrix  : List[List[int]];
    //transition_output_matrix : List[List[int]];
    //place_arcs               : List[List[Arc]];
    //transition_arcs          : List[List[Arc]];
    
    //place_idx : int;
    //transition_idx : int;
    //colour_idx : int;
    
    //GetEdgesNull(count : int) : List[List[Arc]]
    //{
    //  ListUtils.Init(count, _ => null).ToList()
    //}
    
    //GetEmptyMatrix(count : int) : IEnumerable[List[List[Arc]]]
    //{
    //  Enumerable.Repeat(ListUtils.Init(places.Count, _ => null).ToList(), count)
    //}
    
    BuildMatrix() : PetriNet
    {
      def col    = colours.Length;
      def places = places.Count;
      def tran   = transitions.Count;
      
      
      if (matrix_len.Length == 0 || matrix_len[0] != col || matrix_len[1] != places || matrix_len[2] != tran)
      {
        def net = PetriNet.input_matrix_lens.Set(this, array(col, places, tran)) |>
        PetriNet.output_matrix_lens.Set(_, array(col, places, tran))   |>
        PetriNet.incidence_matrix_lens.Set(_, array(col, places, tran));
      
        for (mutable c = 0; c < col; c++)
          for (mutable p = 0; p < places; p++)
            for (mutable t = 0; t < tran; t++)
            {
              def output = if (output_matrix[c, p, t] != null) 1 else 0; 
              def input = if (input_matrix[c, p, t] != null) 1 else 0; 
              incidence_matrix[c, p, t] = output - input;
            }
        net
      } else this
    }
    
    public AddColour(col : Colour) : PetriNet
    {
      def col = Colour.idx_lens.Set(col, colours.Length);
      //col.idx = colour_idx;
      
      PetriNet.colours_lens.Update(_, col :: _)
    }
    
    public AddPlace(place : Place) : Place
    {
      def place = Place.idx_lens.Set(place, places.Count);
      places = places.Add(place);
      place
    }
    
    public AddTransition(tran : Transition) : Transition
    {
      def tran = Transition.idx_lens.Set(tran, transitions.Count);
      transitions = transitions.Add(tran);
      tran
    }
    
    public AddArc(place : Place, arc : Arc, tran : Transition) : void
    {
      def idx  = place.idx;
      def tidx = tran.idx;
      def cidx = arc.colour.idx;
      output_matrix[cidx, idx, tidx] = arc;
    }
    
    public AddArc(tran : Transition, arc : Arc, place : Place) : void
    {
      def idx  = place.idx;
      def tidx = tran.idx;
      def cidx = arc.colour.idx;
      input_matrix[cidx, idx, tidx] = arc;
    }
    
     public AddToken(place_idx : int, tok : Token) : void
     {
       def set_tok(t)
       {
         Place.marking_lens.Update(t[place_idx], tok :: _) |> t.SetItem(place_idx, _)
       }
       
       ThreadSafeUtils.LockFreeUpdate(ref places, set_tok)
       //places[place_idx] = place;
     }
     
     public AddToken(place : Place, tok : Token) : void
     {
       
     }
     
     TypeCompatible(col : Colour, col_out : Colour) : bool
     {
       false
     }
     
     RemoveTokens(places : list[Place * Arc]) : TransitionExecContext * list[Place]
     {
       mutable tokens = [];
       mutable err = [];
       mutable binding = [];
       
       def get_tokens(place, arc) : list[Token]
       {
         def marking = place.marking;
         match (arc.expr)
         {
           | ArcExpr.Constant(v) => if (marking.Find(x => x.value.Equals(v)) is Some(tok))
                                    {
                                      tokens ::= tok;
                                      marking.Remove(tok)
                                    } else
                                    {
                                      err ::= ExecError.TokenConstantNotFound(place, v);
                                      marking
                                    }
           | Var(n)              => if (decls.vars.Contains(n))
                                    {
                                      def type = decls.vars[n];
                                      if (TypeCompatible(place.colour, type))
                                      {
                                        binding ::= (n, marking.Head);
                                        marking.Tail
                                      } else
                                      {
                                        err ::= ExecError.TypeTokenNotCompat(place.colour, type, place);
                                        marking
                                      }
                                    } else
                                    {
                                      err ::= ExecError.VarNotFound(n);
                                      marking
                                    }
           | NumTok(n, Constant(t)) => def tok = marking.Filter(x => x.value.Equals(t));
                                       if (tok.Length >= n)       
                                       {
                                         def tok = tok.Take(n);
                                         tokens += tok.NToList();
                                         marking.Except(tok).NToList()
                                       } else
                                       {
                                         err ::= ExecError.TokenConstantNotFound(place, t);
                                         marking
                                       }
           | _                        => throw InvalidOperationException("unimplemented expression")
           //| Tuple(t)               => 
    //       | Constant { val : object; }
    //| NumTok { num : int; tok : ArcExpr; }
    //| Var { n : string; }
    //| Tuple { tup : list[ArcExpr];}
    //| ListExpr {expr : ListExpr;}
    //| Delay { expr : ArcExpr; delay : ArcExpr; }
    //| IfThen { expr : CondExpr; then : ArcExpr; els : ArcExpr; }
    //| Func { name : string; parms : list[ArcExpr]; }
         }
       }
       
       def new_marking = places.Map(x => (x[0], get_tokens(x)));
       def places = new_marking.Map(Place.marking_lens.Set);
       (TransitionExecContext(Hashtable(binding), tokens, err), places)
     }
     
     AddTokens(tran_ctx : TransitionExecContext, places : IEnumerable[Place * Arc]) : list[Place]
     {
       mutable tok = tran_ctx.tokens;
       mutable binding = tran_ctx.binding;
       
       def eval(e)
       {
         | ArcExpr.Constant(c) => c
         | Var(n)              => binding[n].value
       }
       
       def add_tok(p, a)
       {
         def res_tok = match (a.expr)
         {
           | ArcExpr.Constant(c) => c |> Token |> Some
           | Var(n)              => if (binding.Contains(n))
                                    {
                                      binding[n] |> Some
                                    } else
                                    {
                                      None()
                                    }
           | BinaryOperator(l, o, r) => def l = eval(l);
                                        def r = eval(r);
                                        def res = match (o)
                                        {
                                          | Oper.Mul => match (l, r)
                                                        {
                                                          | (l is int, r is int) => (l * r) |> Some
                                                          | _                    => None()
                                                        }
                                        }
                                        res.Map(Token)
        }                                        
       }
       
       places.Map(add_tok)
     }
     
     public Step() : void
     {
       def input_places_contains_tokens = InputTransitionArcs.Where((t, a : list[_]) => a.All((p, _) => !p.marking.IsEmpty()));
       def places = input_places_contains_tokens.SelectMany((_, l) => l.Select((p, _ : Arc) => p));
       foreach ((t, p) in input_places_contains_tokens)
       {
         def (tran_ctx, places) = RemoveTokens(p);
         def out_acs = TranOutputArcs(t);
         
         //t.ChangeContext()
       }
       // забираем токены из входных позиций и передаем в выходные позиции перехода
       //OutputArcs.Where((p, t, a) => !p.marking.IsEmpty());
     }
  }
}
