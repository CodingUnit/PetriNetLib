using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Builtins;
using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using CommonLib.Macros;
using PetriNetModel;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace PetriNetLib
{
  using CommonLib.Macros.LensUtils;

  /*
  - вводится понятие переходов функций они действую совместно со своими позициями, когда вызывается 
    функция, то вызывается переход и сеть срабатывает, фишки выходят в позицию как результат функции
    для правильной работы нужно чтобы эта функция могла блокировать сеть на время своей работы, 
    если другой переход срабатывает во время вызова функции, то функция должна вернуть
    переход к его начальному состоянию, для этого переходы которые может прерывать функция,
    те с пересекающимися позициями, должны сохранять свое состояние до перехода и надо восстанавливать
    это состояние из перехода функции, тогда сеть должна функционировать правильно,
    после того как функция сработала и фишки извлечены можно запустить отложенный переход который был 
    прерван, если в момент сохранения состояния вызывается переход функции, то переход срабатывает, а состояние
    должно сохранятся снова сначала после изменения состояния функции-перехода
  */
  /// <summary>
  /// Description of Generator.
  /// </summary>
  partial class CppGenerator
  {
    [Accessor]
    model       : OutModel;
    [Accessor]
    proc        : PetriNetProcessor;
    converter   : Converter;
    typer       : Typer;
    typebuilder : TypeBuilder;
    gen         : Generator;
    colours     : Hashtable[string, GenColourCpp] = Hashtable();
    [Accessor]
    places      : array[GenPlaceCpp];
    [Accessor]
    transitions : array[GenTranCpp];

    PlacesWithGroup : list[GenPlaceCpp]
    {
      [Memoize]
      get
      {
        places.Filter(x => !CommonLib.Macros.ListUtils.ElementsEqual(x.OutputTransitions.Where((x, _) => x.IsUnnamed).Map((x, _) => x.priority), _ == _))
      }
    }
    
    internal CreateArray(expr : list[PExpr]) : string
    {
      def ty = Typer(gen.TypingMethod);
      def te = ty.TypeExpr(<[ [..$expr] ]>);
      def ty = te.ty;
      def len = expr.Length;
      def (type, n, ty) = match (ty)
                           {
                             | FixedType.Class(_, [args]) => def byte = typer.BindType(<[ byte ]>);
                                        if (args.TryRequire(byte))
                                        {

                                          if (len <= 10)
                                          {
                                            ($"byte$len", false, "u8")
                                          } else
                                          {
                                            ("byten", true, "u8")
                                          }
                                        } else (null, false, null)
                            | _ => throw InvalidOperationException()
                                        //if (args.TryRequire(integer))
                                        //{
                                        //} else
                                        //if (args.TryRequire(uinteger))
                                        //{
                                        //} else
                                        //if (args.TryRequire(longint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(ulongint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(shortint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(ushortint))
                                        //{
                                        //}
                           }
      //mutable lst = [];
      def expr = expr.Map(ConvExpr(_, false));
      //{..$(expr; ",")}
      def var = Macros.NewSymbol();
      if (n)
      {
        ctx ::= $<#$ty $var[] = {..$(expr;", ")};#>;
        $<#$type($var, $len)#>
      } else
      {
        ctx ::= $<#$ty $var[] = {..$(expr;", ")};#>;
        $<#$type($var)#>
      }
    }


    
    CreatePlaces() : string
    {
      mutable gen_idx = 0;
      foreach (p in places)
      {
        when (!p.IsFuncPlace)
        {
          p.gen_idx = gen_idx;
          gen_idx++;    
        }
      }
        
      def enums = places.Where(x => !x.IsFuncPlace).Map(x => $<#pl_$(x.Name) = 0x$((1 << x.gen_idx).ToString("X"))#>);
      $<#typedef enum
         {
           ..$(enums;",\n")
         } tplace;#>
    }
    
    CreateFuncPlace(place : GenPlaceCpp) : string
    {
      def name = place.Name;
        //def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
      def tran = place.FuncTran;
      def type = place.Colour.VarSpec;
      $<#void $name($(type)param)
      {
        $(tran.Body)
      }
      #>
    }
    
    CreatePlace(place : GenPlaceCpp) : string
    {
      
      // TODO: transparent place
      def name = place.Name;
        //def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
      def type = place.Colour.DestType;
      if (place.IsFuncPlace) 
      {
        null
      } else
      {
        
        
        def dtype = place.DestContainerType;
        def dest_cont = match (dtype)
                         {
                           | TDestCont.MultiSet  => "multi_set"//cpp("type: multi_set")
                           | RandomEnumerable    => "random_array"//cpp("type: random_array")
                           | SortedSet           => "sorted_array"//cpp("type: sorted_array")
                           | TokenQueue          => "token_queue"//cpp("type: token_queue")
                           | TimedSimpleMultiset => "timed_heap"//cpp("type: timed_heap")
                           | ZeroSingle
                           | MinusSingle
                           | Var
                           | Single              => type
                           | ReqContainer        => "req_tokens"
                         }
        def flag = match (dtype)
        {
          | Single              => if (place.Colour.IsUnit) "" else $"$(name)_flag"
          | _                   => ""
        }
        def time = if (place.IsTimed) $"\nu32 $(name)_time;" else "";
        def deflt = match (dtype)
        {
          | ZeroSingle  => " = 0"
          | MinusSingle => " = -1"
          | _           => ""
        }
        def flag = if (flag.IsEmpty()) "" else $"\nbool $flag = false;";
        $<#$dest_cont $name$deflt;$flag$time#>
      }
      //cpp(<#decl: $(dest_cont : type) $name;#>)
      //if (place.IsTimed)
      //<[decl: $(name : usesite) : PetriNetModel.TimedPlace.[$type] = PetriNetModel.TimedPlace($(name : string), $dest_cont)]> else
      //<[decl: $(name : usesite) : PetriNetModel.Place.[$type] = PetriNetModel.Place($(name : string), $dest_cont)]>
    }

    
    internal TypeOfVar(name : string) : string
    {
      match (model.vars.Find(x => x.Key == name))
      {
        | Some(x) => def col = colours[x.Value.name];
                     col.VarSpec
        | _       => ""
      }
    }

    internal ConvExpr(expr : PExpr, statement : bool = false) : string
    {
      when (statement) ctx = [];
      match (expr)
      {
        | <[ true ]>                      => "true"
        | <[ false ]>                     => "false"
        | <[ {$seq} ]>                    => ConvExpr(seq, true)
        | <[ {..$seq} ]> when (statement) => match (seq)
            {
              | []  => ""
              | seq => def seq = seq.Map(ConvExpr(_, true));
                                                        $<#..$(seq;";\n")#>
            }
        | <[ $n ` $t]>          => $<#token_iter_utils.repeat($(ConvExpr(t)), $(ConvExpr(n)))#>
        | <[ $a %++ $b]>        => $<#token_iter_utils.concat($(ConvExpr(a)), $(ConvExpr(b)))#>
        | <[]>                  => ""
        | <[ ! $e]>             => $<#!$(ConvExpr(e))#>
        | <[ $a > $b]>          => $<#$(ConvExpr(a)) > $(ConvExpr(b))#>
        | <[ $a < $b]>          => $<#$(ConvExpr(a)) < $(ConvExpr(b))#>
        | <[ $a <= $b]>         => $<#$(ConvExpr(a)) <= $(ConvExpr(b))#>
        | <[ $a >= $b]>         => $<#$(ConvExpr(a)) >= $(ConvExpr(b))#>
        | <[ $a != $b]>         => $<#$(ConvExpr(a)) != $(ConvExpr(b))#>
        | <[ $a == $b]>         => $<#$(ConvExpr(a)) == $(ConvExpr(b))#>
        | <[ $a + $b]>          => $<#$(ConvExpr(a)) + $(ConvExpr(b))#>
        | <[ $a / $b]>          => $<#$(ConvExpr(a)) / $(ConvExpr(b))#>
        | <[ $a * $b]>          => $<#$(ConvExpr(a)) * $(ConvExpr(b))#>
        | <[ $(n : usesite)]>   => $<#$n#>
        | <[ Enumerable.Repeat($tok, $n) ]> => $<#token_iter_utils.repeat($(ConvExpr(tok)), $(ConvExpr(n)))#>
        | <[ $(e1).Concat($e2) ]> => $<#token_iter_utils.concat($(ConvExpr(e1)), $(ConvExpr(e2))#>
        //| <[ $func(..$parms) ]> when (parms.All(x => x is PExpr.Assign)) =>


        | <[ $func(..$parms) ]> => def func = ConvFunc(func.ToString());
                                   if (parms.All(x => x is PExpr.Assign)) 
                                   {
                                     def get_rec_parm(x)
                                     {
                                       | <[$_ = $v]> => v |> ConvExpr(_, false)
                                       | _                     => throw InvalidOperationException()
                                     }

                                     
                                     def parms = parms.Map(get_rec_parm);
                                     $<#$func(..$(parms; ","))#>
                                   } else
                                   {
                                     def parms = parms.Map(ConvExpr(_, false));
                                     $<#$func(..$(parms; ","))#>
                                   }
        | <[ $(_ : int)]> as e
        | <[ $(_ : long)]> as e
        | <[ $(_ : short)]> as e
        | <[ $(_ : ushort)]> as e
        | <[ $(_ : byte)]> as e => $<#$e#>
        | <[ $(n : string)]>    => $<#$n#>
        | <[ (..$e) ]>          => match (e)
            {
              | [e]                  => ConvExpr(e)
              | [e1, e2]             => $<#tuple2($(ConvExpr(e1)), $(ConvExpr(e2)))#>
              | [e1, e2, e3]         => $<#tuple3($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)))#>
              | [e1, e2, e3, e4]     => $<#tuple4($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)), $(ConvExpr(e4)))#>
              | [e1, e2, e3, e4, e5] => $<#tuple5($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)), $(ConvExpr(e4)), $(ConvExpr(e5)))#>
              | _                     => throw InvalidOperationException()
            }

        | <[()]>                 => <#1#>
        | <[$o.$m]>              => $<#$(ConvExpr(o)).$m#>
        | <[ if ($a) $b else $c]> when statement => $<#if ($(ConvExpr(a))) $(ConvExpr(b)) else $(ConvExpr(c))#>
        | <[ if ($a) $b else $c]> when !statement => $<#$(ConvExpr(a)) ? $(ConvExpr(b)) : $(ConvExpr(c))#>
        | <[ array[..$val] ]>   => CreateArray(val)
        | <[ [..$e]]>           => CreateArray(e)
        | <[ $e : $t]>          => $<#($(ConvExpr(t)))$(ConvExpr(e))#>
        | _                     => throw InvalidOperationException()
      }      
    }

    CreateGlobRef(name : string, val : PExpr) : string
    {
      def ty = Typer(gen.TypingMethod);
      def te = ty.TypeExpr(val);

      def type = ConvType(te);
      def val = ConvExpr(val, true);
      //<[decl: mutable $(name : usesite) : $(te.ty : typed) = $val]>
      //cpp("decl: $(type : type) $name = $val;")
      $"$type $name = $val;"
    }

    CreateVals(expr : PExpr) : string
    {
      | <[ def $(name : usesite) = $val]> => 
          def type = typer.TypeExpr(val);
          //def ty = type.ty;
          def type = type |> ConvType;
          def val = ConvExpr(val, false);
          //<[ decl: $(name : usesite) : $(ty : typed) = $val ]>
          //cpp("decl: $(type : type) $name = $val;")
          $"static const $type $name = $val;"
      | _ => null
    }

    ProcessFun(expr : PExpr) : PExpr
    {


      def proc_parms(p, t, b)
      {
        def proc_parm(p, (parm, e))
        {
          def (p, e) = match (p)
                        {
                          | <[parameter: $(n : usesite) : Index.[$(type : usesite)]]> => 
                              match (model.GetIndex(type))
                              {
                                | Some((t, _)) => (<[parameter: $(n : usesite) : $(t : usesite)]> :: parm, e)
                                | _            => (parm, e)
                              }
                          | p => (p :: parm, e)  
                        }

          def e = if (t is Some(t))      
                    match (e)
                    {
                      | [] => e
                      | lst => def (last, e : list[PExpr]) = lst.PartitionLast();
                  def last = match (last)
                  {
                    | <[ {(..$e)} ]>
                    | <[(..$e)]> when e.All(x => x is PExpr.Assign) => <[ $t(..$e)]>
                    | e => e
                  }
                  e + [last]
                    } else e;

          (p, e)
        }

        def expr = <[ {..$b} ]>;
        def (p, expr) = p.Fold(([], expr :: []), proc_parm);
        (p.Rev(), expr)
      }

      match (expr)
      {
        | <[ def $(n : usesite)(..$parms) { ..$body } ]> => 

          def (parms, expr) = proc_parms(parms, None(), body);

          <[ def $(n : usesite)(..$parms) { ..$expr } ]>

        | <[ def $(n : usesite)(..$parms) : $t { ..$body } ]> => 

          def (parms, expr) = proc_parms(parms, Some(t), body);

          <[ def $(n : usesite)(..$parms) : $t { ..$expr } ]>

        | _                     => throw InvalidOperationException()
      }
    }

    CreateDecl(expr : PExpr) : string
    {
      | <[ def $(n : usesite)(..$_) { ..$_ } ]> => 

          if (n.StartsWith("FUNC_")) null else
          if (n.StartsWith("EXT_"))
          {
            def n = n.Substring(4);
            $<#function $n;#>
          } else
          {
            def func = ProcessFun(expr);
            def ty = Typer(gen.TypingMethod);
            def te = ty.TypeExpr(func);
          //def type = te |> ConvType;
            match (func)
            {
              | <[ def $(n : usesite)(..$parms) { ..$expr } ]> =>
                  match (te)
                  {
                    | TExpr.DefFunctionsIn(h :: _, _) => def ret = h.ReturnType |> ConvType;
                                                      def expr = expr.Map(ConvExpr(_, true));
                                                      def (last, expr) = expr.PartitionLast();
                                                      def parms = parms.Map(ConvParm);
                                                      $<#$ret $n(..$(parms; ","))
                                                       {..$(expr;";\n")
                                                         return $last;
                                                       }
                                                       #>
                                                      //<[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                      //  {
                                                      //    ..$expr
                                                      //  }]>
                     | _                     => throw InvalidOperationException()                                  
                  }
               | _                     => throw InvalidOperationException()
            }
          }
      | <[ def $(n : usesite)(..$_) : $_t { ..$_ } ]> => 

          if (n.StartsWith("FUNC_")) null else
          if (n.StartsWith("EXT_"))
          {
            def n = n.Substring(4);
            $<#function $n;#>
          } else
          {
            def func = ProcessFun(expr);
            match (func)
            {
              | <[ def $(n : usesite)(..$parms) : $t { ..$expr } ]> =>
                  def ret = t.ToString();//FinalType(t.ToString());

                  def expr = expr.Map(ConvExpr(_, true));
                  def expr = if (ctx.IsEmpty()) expr else $<#..$(ctx;"\n")#> :: expr;
                  def (last, expr) = expr.PartitionLast();
                  def parms = parms.Map(ConvParm);
                  $<#$ret $n(..$(parms; ","))
                    {..$(expr;";\n")
                      return $last;
                    }
                    #>
              | _                     => throw InvalidOperationException()                                       //<[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                      //  {
                                                      //    ..$expr
            }                                           //  }]>
          }
      | _ => null
    }

    CreateColourSet(col : GenColourCpp) : string
    {
      match (col.Colour)
      {
        | ColourSet(n, Colour.Product(vals))   => def fnames = vals.MapI((i, t) => ($"field$(i + 1)", t));
                                                  def ctor = fnames.Map(ConvParm);
                                                  def ftypes = fnames.Map((n, t) => (n, colours[t].DestType));
                                                  def fields = ftypes.Map((n, t) => $"$t $n;");
                                                  def ctorbody = fnames.Map((f, _) => $"this->$f = $f;");
                                                  $<#struct $n
                                                        {
                                                          $n(..$(ctor;", ")) 
                                                          {
                                                            ..$(ctorbody;"\n")
                                                          }

                                                          ..$(fields;"\n")
                                                        };#>

                                                  //CTypeDecl.Decl(CTree.Decl([CSpec.Typedef()], CType.Class(n), [CDecl.Id(CName.String(new_name), None())]))
        | ColourSet(n, Colour.Record(vals))     => 
                                                  def ctor = vals.Map(ConvParm);
                                                  def ftypes = vals.Map((n, t) => (n, colours[t].DestType));
                                                  def fields = ftypes.Map((n, t) => $"$t $n;");
                                                  def ctorbody = vals.Map((f, _) => $"this->$f = $f;");
                                                  $<#struct $n
                                                        {
                                                          $n(..$(ctor;", ")) 
                                                          {
                                                            ..$(ctorbody;"\n")
                                                          }
                                                          ..$(fields;"\n")
                                                        };#>
        | ColourSet(n, Colour.Index(_mn, _mx, i)) =>   $<#typedef $n int;;
                                                     typedef $i int;#>;
        //def name = Macros.UseSiteSymbol(n);
                                                  //def mods = AttributesAndModifiers(NemerleModifiers.Private, []);
                                                  //def al = TopDeclaration.Alias(name, mods, Typarms.Empty, <[ $(new_name : usesite) ]>);
                                                  //al |> ClassMember.TypeDeclaration.TypeDeclaration;
                                                  // cpp("typedef $n $new_name")
            //$"typedef $n $new_name;"
        //| ColourSet(n, Colour.Unit(Some(t))) => 
        | ColourSet(n, Colour.Unit(Some(t))) => $<#typedef $t $n;
                                                   typedef char $t;
                                                  #>

        | ColourSet("REAL", Colour.Simple(_t))  => null
        | ColourSet(n, Colour.Simple)
        | ColourSet(n, Colour.Integer) => def t = col.DestType;
                                          $<#typedef $t $n;#>   
        | ColourSet(n, Colour.Alias(t))
        | ColourSet(n, Colour.Unit) with t = "char"                                                       
                                          => $<#typedef $t $n;#> 
        
        | ColourSet(n, Colour.Enum(vals)) => //def vals = vals.Map(x => $"$x");
                                            $<#    enum $n
                                                   {
                                                     ..$vals;
                                                   };#>
        | ColourSet(n, Colour.Timed(c))   => CreateColourSet(ColourSet(n, c) |> GenColourCpp(_, this))

        | _                               => null
      }
    }    

    CreateInitMarking(place : GenPlaceCpp) : string
    {
      def combine(e1, e2)
      {
        | (<[Enumerable.Repeat($tok, $(n : int))]>, <[Enumerable.Repeat($tok2, $(n2 : int))]>) when (tok.Equals(tok2)) 
            => <[Enumerable.Repeat($tok, $(n2 + n))]>
        | (<[Enumerable.Repeat($(tok : int), $(n : int))]>, <[Enumerable.Repeat($(tok2 : int), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : int)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : string), $(n : int))]>, <[Enumerable.Repeat($(tok2 : string), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : string)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : double), $(n : int))]>, <[Enumerable.Repeat($(tok2 : double), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : double)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>       
        | _  //(<[Enumerable.Repeat($_, $(_ : int))]>, <[Enumerable.Repeat($_, $(_ : int))]>)                         
            => <[ $e1.Concat($e2)]> 
      }

      def unfold(expr)
      {
        | <[ () ]> => <[ 1 ]>
        | e        => e
      }

      def fold(expr) : PExpr
      {
        //| <[ {..$e} ]>   => e.Fold(acc, fold)
        | <[ 1 ` $tok %@ $time ]>             => def time = time |> ConvExpr(_, false);
                                                def tok = unfold(tok);
                                                <[at_time($tok, $time)]>
        | <[ 1 ` $tok]>                       => <[$(unfold(tok))]>
        | <[ $(n : int) ` $tok %@ $time ]>    => <[IEnumerable.Repeat(at_time($(unfold(tok)), $time), $n)]>
        | <[ $(n : int) ` $tok]>              => <[IEnumerable.Repeat($(unfold(tok)), $n)]>
        | <[ $l %++ $r]>                      => <[$(combine(fold(l), fold(r)))]>
        | e                                   => unfold(e)
      }

      if (place.init_mark == null) null else
      {
        def markexpr = fold(place.init_mark);
        def mark = markexpr |> ConvExpr(_, false);
        def name = place.Name;
        
        
        def mark = if (place.IsTimed) 
        {
          match (place.DestContainerType)
          {
            | TDestCont.MinusSingle
            | TDestCont.Single     
            | TDestCont.ZeroSingle
            | TDestCont.Var         => place.InitMarkWithoutTime |> ConvExpr(_, false)
            | _                     => $"add_time($mark, 0);"
          }
          
        } else mark;
        
        def time = if (place.IsTimed) 
        {
          match (place.DestContainerType)
          {
            | TDestCont.MinusSingle
            | TDestCont.Single     
            | TDestCont.ZeroSingle
            | TDestCont.Var         => $"\n$(name)_time = $(place.InitTime);"
            | _                     => ""
          }
        } else "";
        //<[ $(name : usesite).Add($mark)]>
        if (markexpr is <[]>)
        {
          match (place.DestContainerType)
          {
            | TDestCont.MinusSingle => $"$(name) = -1;"
            | TDestCont.Single      => if (place.IsUnit)
                                       {
                                         $"$(name) = 0;"
                                       } else $"$(name)_flag = false;"
            | TDestCont.ZeroSingle  => $"$(name) = 0;"
            | _                     => mark
          }
        } else 
        match (place.DestContainerType)
        {
          
          | TDestCont.Single      => $<#$name = $mark;
                                       $(name)_flag = true;$time#>;
          | TDestCont.Var
          | TDestCont.ZeroSingle
          | TDestCont.MinusSingle
                                  => $"$name = $mark;$time"
          | _                     => $"$name.add($mark);"
        }
        
      }
    }

    //CreateToString() : void
    //{
    //  def strings = model.places.Map(x => <[ $(x.name : usesite).ToString() ]>);
    //  fields ::= <[decl: public override ToString() : string 
    //  { 
    //    def str = array[..$strings];
    //    string.Join(";\n", str)
    //  }]>
    //}


    CreateCons() : void
    {
      def marking = places.MapToList(CreateInitMarking).Filter(x => x != null && !x.IsEmpty());
      public_fields ::= if (model.IsTimed || model.IsHaveImmediateTransitions) 
      $<#$Name(int time_step = 15) 
      { 
        $Base(time_step);
        ..$(marking;"\n")
        ..$(cons_expr;"\n")
      }#>; 
                        else $<#$Name(int time_step = 15) 
      { 
        ..$(marking;"\n")
        ..$(cons_expr;"\n")
      }#>;//<[decl: public this() { {..$marking} {..$cons_expr} }]>;
    }

    CreateTimeMethods() : void
    {
      //def body = transitions.Where(_.IsTimed).Map(x => <[ $(x.Name : usesite)() ]>);
      def time_delay(p)
      {
        def time = match (p.DestContainerType)
        {
          | TDestCont.MinusSingle
          | TDestCont.ZeroSingle
          | TDestCont.Single
          | TDestCont.Var    => 
                                $"$(p.Name)_time"
          | _                => $"$(p.Name).next_token_delay()"
        }
        def arc_dl = p.OutputTransitions.Where((_, a : Arc) => a.ArcDelay.HasValue);
        def min_delay = if (arc_dl.Count() == 0) "" else
                        if (arc_dl.Count() == 1) arc_dl.First()[1].ArcDelay.Value |> ConvExpr(_, false) else
                        if (arc_dl.All((_, a) => a.ArcDelay.Value is <[ $(_ : int)]>)) arc_dl.Min((_, a) => if (a.ArcDelay.Value is <[ $(x : int) ]>) x else 0).ToString();
                        else 
                        {
                          def delay = arc_dl.Select((_, a : Arc) => a.ArcDelay.Value |> ConvExpr(_, false));
                          def min = delay.Select((x, i) => $<#int x$i = $x;
                                                           if (min_delay > x$i) min_delay = x$i;#>);
                          $<#u32 min_delay = 0xFFFFFFFF;
                          ..$(min; "\n")
                          #>                                          
                        };
        def arc_delay = if (!min_delay.IsEmpty()) " + " + min_delay else "";
        (p, $"$time$arc_delay", !arc_delay.IsEmpty())
      }
      
      def next = places.Where(_.IsTimed).Map(time_delay);

      def tran = places.Where(_.IsTimed).Map(x => x.OutputGenTransitions.Where(x => x.IsUnnamed).Map(x => $"tr_$(x.Name)"));
      def time_body = match (next)
                       {
                         | []    => ""
                         | [(_, one, _)] => one
                         | lst   => def next = lst.ZipLazy(tran).Map(((_, x, _), t) => 
                         {
                           $<# time = $x;
                               if (min > time) 
                               {
                                 min = time;
                                 ..$(t.Map(x => $"tr = $x"); "\n");
                               } else
                               if (min == time)
                               {
                                 ..$(t.Map(x => $"tr |= $x"); "\n");
                               }#>
                         });
                          $<#
                                  u32 min = 0xFFFFFFFF, time;
                                  ..$(next;"\n");
                              #>
                       }
      private_fields ::= $<#u32 get_next_time(u32 &res_tr)
                      {
                        u32 tr = 0;
                        $time_body;
                        res_tr = tr;
                        return min;
                      }#>;
      
    }

    //CreateStepMethod() : void
    //{
    //  def body = model.transitions.Where(x => x.IsImmediate && !x.IsTimed).Map(x => $<#$(x.Name)()#>);
    //  when (!body.IsEmpty())
    //    public_fields ::= $<#void step()
    //  {
    //    ..$(body; "\n")
    //  }#>
    //}

    CreateStartMethod() : void
    {
      //fields ::= []
      /*cpp(<#decl: void Initiate()
                      {
                        ..$init_body;
                      })*/
    }

    CreateEvents() : void
    {
      when (proc.Flags.HasFlag(PetriNetFlags.Events))
      {
        foreach (_t in transitions)
        {
          //def name = t.Name;
          //def evt = $"evt_$name";
          //fields ::= $<#decl: public event $(evt : usesite) : Action#>;
          //fields ::= <[decl: $($"On$name" : usesite)() : void
          //            {
          //              $(evt : usesite)?.Invoke()
          //            } ]>;
        }
      }
    }

    

    Define(decl : IEnumerable[string], pub : bool = false) : void
    {
      if (pub)
      {
        foreach (d in decl) 
        {
          public_fields ::= d;
          //public_fields ::= "\n"
        }
      } else
      {
        foreach (d in decl)
        {
          private_fields ::= d;
          //private_fields ::= "\n"
        }
      }
    }

    Define(decl : string) : void
    {
      private_fields ::= decl;
      //private_fields ::= "\n"
      //def ty = CTree.Type.type_lens >> CComplexType.Class.decls_lens;
      //main_class = ty.Update(main_class, x => x.Append(decl));
      //(main_class.type :> CComplexType.Class).
    }


    public PhaseOne() : void
    {
    }

    public Generate() : void
    {      
      //CreateOperators();
      //assert2(false);
      
    // создаем типы генерации из цветов
      foreach (c in model.colour_sets)
      {
        colours.Add(c.Key, c.Value |> GenColourCpp(_, this))
      }

      def places_enum = CreatePlaces();
      Define(places_enum);
      def sets = colours.Values.Map(x => CreateColourSet(x) + "\n").Filter(_ != null);
      Define(sets);//typebuilder.DefineNestedTypeWithSource(m).Compile();

      def places = places.Map(CreatePlace).Filter(_ != null);      
      
      
      
      //CreateStepMethod();

      CreateEvents();
      //CreateTranQueue();
      //CreateToString();
      CreateStartMethod();
      

      Define(places + ["\n"])//_ = typebuilder.DefineWithSource(m);
    }
    
    public PhaseTwo() : void
    {
      //CreateDummyMethod();
      CreateCons();
      CreateTransitions();
      def methods = CreateGroupTransitions();
      def methods = methods + transitions.Where(x => !x.IsPartOfFuncPlace).MapToList(CreateTran);
      def methods = methods + places.Where(x => x.IsFuncPlace).MapToList(CreateFuncPlace);
      def vals = model.ml_decls.Map(CreateVals).Filter(_ != null);
      Define(vals + ["\n"]);//_ = typebuilder.DefineWithSource(m);
      def decls = model.ml_decls.Map(CreateDecl).Filter(_ != null);
      def (ext, decls) = decls.Partition(x => x.StartsWith("function"));
      def globrefs = model.glob_refs.KeyValuePairs.MapToList(CreateGlobRef);
      Define(globrefs);//_ = typebuilder.DefineWithSource(m);
      Define(methods, true);
      Define(decls);
      when (model.IsTimed) CreateTimeMethods();
      Define(ext, true);
      System.IO.File.WriteAllText(file, main_class)
      //typebuilder.Compile()
    }
  }
}