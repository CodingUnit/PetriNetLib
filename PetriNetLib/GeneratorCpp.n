using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Builtins;
using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using CommonLib.Macros;
using PetriNetModel;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;
using CppParserPrinter;
using CppMacro;

namespace PetriNetLib
{
  using CommonLib.Macros.LensUtils;

  /*
  - то их можно запаковать в слово или несколько слов переходы и позиции, наличие токенов и разрешенность
    создается переменная places в которой бит показывает одной позиции наличие токена
    создается переменная ena в которой каждый бит означает включенность перехода 
    при добавлении токена бит устанавливается в places в 1
    при удалении токена проверяется на пустоту и если пусто то сбрасывается в 0
    бит ena = 1 в битах позиций, например ena = places & (A|B) == (A|B) << 16
    биты из разрешенных переходов быстро определяется первый установленный и его позиция и
  */
  /// <summary>
  /// Description of Generator.
  /// </summary>
  partial class CppGenerator
  {
    [Accessor]
    model       : OutModel;
    [Accessor]
    proc        : PetriNetProcessor;
    converter   : Converter;
    typer       : Typer;
    typebuilder : TypeBuilder;
    gen         : Generator;
    colours     : Hashtable[string, GenColour] = Hashtable();
    
    ColourFromStr(type : string) : GenColour
    {
      //| "string" => "char *"//cpp("type: char *")
      //| "int"    => "int"//cpp("type: int")
      //| "intinf" => "long long"//cpp("type: int")
      //| "real"   => "float"//cpp("type: float")
      //| "time"   => "int"//cpp("type: int")
      //| "bool"   => "bool"//cpp("type: bool")
      //| "unit"   => "char"//cpp("type: Unit")
      if (colours.ContainsKey(type))
      {
        colours[type]
      } else//GetTypeExpr
      {
        throw InvalidOperationException("colour not found")
      }
    }

    internal CreateArray(expr : list[PExpr]) : string
    {
      def ty = Typer(gen.TypingMethod);
      def te = ty.TypeExpr(<[ [..$expr] ]>);
      def ty = te.ty;
      def len = expr.Length;
      def (type, n, ty) = match (ty)
                           {
                             | FixedType.Class(_, [args]) => def byte = typer.BindType(<[ byte ]>);
                                        if (args.TryRequire(byte))
                                        {

                                          if (len <= 10)
                                          {
                                            ($"byte$len", false, "u8")
                                          } else
                                          {
                                            ("byten", true, "u8")
                                          }
                                        } else (null, false, null)
                                        //if (args.TryRequire(integer))
                                        //{
                                        //} else
                                        //if (args.TryRequire(uinteger))
                                        //{
                                        //} else
                                        //if (args.TryRequire(longint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(ulongint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(shortint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(ushortint))
                                        //{
                                        //}
                           }
      //mutable lst = [];
      def expr = expr.Map(ConvExpr(_, false));
      //{..$(expr; ",")}
      def var = Macros.NewSymbol();
      if (n)
      {
        ctx ::= $<#$ty $var[] = {..$(expr;", ")};#>;
        $<#$type($var, $len)#>
      } else
      {
        ctx ::= $<#$ty $var[] = {..$(expr;", ")};#>;
        $<#$type($var)#>
      }
    }


    CreateTranBody(tran : Transition) : string
    {
      def input  = tran.InputPlaces;
      def output = tran.OutputPlaces;
      def name   = tran.Name;
      //def map    = Hashtable();

      def input = input.Map((x, a) => InArcBindingCpp(x, this, tran, [], a));

      foreach (i in input)
      {
        match (i.expr)
        {
          | <[ $_(..$p) ]> => foreach (p in p)
                                {
                                  | <[ $(n : usesite)]> => match (input.Find(x => x.bind_var == n))
                                      {
                                        | Some(x) => i.Depends ::= x;
                                        | _       => ()
                                      }
                                  | _                   => ()
                                }
          | _ => ()
        }
        //map[i.name] = i;
      }

      def input    = input.Sort((x, y) => y.priority - x.priority); 
      def add_proc = output.Map((p, a) => OutArcProcessCpp(p, tran, a, this));

      def extract = input.Map(_.extract_expr);
      def add_body = add_proc.Map(_.add_token);
      def code = tran.code_segment |> ConvExpr(_, true) ?? "";
      def body = extract + (code :: add_body);
      def body = if (tran.guard is <[]>) body else 
                  {
                    def guard = tran.guard |> ConvExpr(_, false);
                    $<#if ($guard) 
                    {
                      ..$(body;"\n")
                    }#> :: [];
                  }

      def tran_evt = if (proc.Flags.HasFlag(PetriNetFlags.Events)) $<#On$name()#> else "";

      def fold(x, a)
      {
        if (a : object == null)
        {
          if (x.check_expr.IsEmpty())
            $<#  
              $(x.bind_expr)
              ..$(body;"\n")
              $tran_evt
            #>
          else
          $<#  
              if ($(x.check_expr))
              {
                $(x.bind_expr)
                ..$(body; "\n")
                $tran_evt
              }
          #>
        } else
        {
          if (x.check_expr.IsEmpty())
          $<#  
              $(x.bind_expr)
              $a
              #>
          else
          $<#  
              if ($(x.check_expr))
              {
                $(x.bind_expr)
                $a
              }
          #>
        }
      }


      //def input = eval(input, []);

      input.Fold(null, fold)
    }

    CreatePlace(place : Place) : string
    {
      def name = place.Name;
      //def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
      def type = (place.colour |> GenColour(_, this)).DestType;
      def dest_cont = match (place.DestContainerType)
                       {
                         | TDestCont.MultiSet  => "multi_set"//cpp("type: multi_set")
                         | RandomEnumerable    => "random_array"//cpp("type: random_array")
                         | SortedSet           => "sorted_array"//cpp("type: sorted_array")
                         | TokenQueue          => "token_queue"//cpp("type: token_queue")
                         | TimedSimpleMultiset => "timed_heap"//cpp("type: timed_heap")
                       }
      $<#$dest_cont $name;#>
      //cpp(<#decl: $(dest_cont : type) $name;#>)
      //if (place.IsTimed)
      //<[decl: $(name : usesite) : PetriNetModel.TimedPlace.[$type] = PetriNetModel.TimedPlace($(name : string), $dest_cont)]> else
      //<[decl: $(name : usesite) : PetriNetModel.Place.[$type] = PetriNetModel.Place($(name : string), $dest_cont)]>
    }


    CreateTran(tran : Transition) : string
    {
      def name = tran.Name;

      def body = CreateTranBody(tran);      
      //cpp(<#
        $<#void $name()
            {
              if (lock($name))
              {
                $body;
                unlock();
              }
            }
          #>//)
    }

    internal TypeOfVar(name : string) : string
    {
      match (model.vars.Find(x => x.Key == name))
      {
        | Some(x) => def col = x.Value |> GenColour(_, this);
                     col.DestType
        | _       => ""
      }
    }



    
    internal ConvExpr(expr : PExpr, statement : bool = false) : string
    {
      when (statement) ctx = [];
      match (expr)
      {
        | <[ true ]>                      => "true"
        | <[ false ]>                     => "false"
        | <[ {$seq} ]>                    => ConvExpr(seq, true)
        | <[ {..$seq} ]> when (statement) => match (seq)
            {
              | []  => ""
              | seq => def seq = seq.Map(ConvExpr(_, true));
                                                        $<#..$(seq;";\n")#>
            }
        | <[ $n ` $t]>          => $<#token_iter_utils.repeat($(ConvExpr(t)), $(ConvExpr(n)))#>
        | <[ $a %++ $b]>        => $<#token_iter_utils.concat($(ConvExpr(a)), $(ConvExpr(b)))#>
        | <[]>                  => ""
        | <[ $a != $b]>         => $<#$(ConvExpr(a)) != $(ConvExpr(b))#>
        | <[ $a == $b]>         => $<#$(ConvExpr(a)) == $(ConvExpr(b))#>
        | <[ $a + $b]>          => $<#$(ConvExpr(a)) + $(ConvExpr(b))#>
        | <[ $a * $b]>          => $<#$(ConvExpr(a)) * $(ConvExpr(b))#>
        | <[ $(n : usesite)]>   => $<#$n#>
        | <[ Enumerable.Repeat($tok, $n) ]> => $<#token_iter_utils.repeat($(ConvExpr(tok)), $(ConvExpr(n)))#>
        | <[ $(e1).Concat($e2) ]> => $<#token_iter_utils.concat($(ConvExpr(e1)), $(ConvExpr(e2))#>
        //| <[ $func(..$parms) ]> when (parms.All(x => x is PExpr.Assign)) =>


        | <[ $func(..$parms) ]> => def func = ConvFunc(func.ToString());
                                   if (parms.All(x => x is PExpr.Assign)) 
                                   {
                                     def get_rec_parm(x)
                                     {
                                       | <[$_ = $v]> => v |> ConvExpr(_, false)
                                     }

                                     
                                     def parms = parms.Map(get_rec_parm);
                                     $<#$func(..$(parms; ","))#>
                                   } else
                                   {
                                     def parms = parms.Map(ConvExpr(_, false));
                                     $<#$func(..$(parms; ","))#>
                                   }
        | <[ $(_ : int)]> as e
        | <[ $(_ : long)]> as e
        | <[ $(_ : short)]> as e
        | <[ $(_ : ushort)]> as e
        | <[ $(_ : byte)]> as e => $<#$e#>
        | <[ $(n : string)]>    => $<#$n#>
        | <[ (..$e) ]>          => match (e)
            {
              | [e]                  => ConvExpr(e)
              | [e1, e2]             => $<#tuple2($(ConvExpr(e1)), $(ConvExpr(e2)))#>
              | [e1, e2, e3]         => $<#tuple3($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)))#>
              | [e1, e2, e3, e4]     => $<#tuple4($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)), $(ConvExpr(e4)))#>
              | [e1, e2, e3, e4, e5] => $<#tuple5($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)), $(ConvExpr(e4)), $(ConvExpr(e5)))#>
            }

        | <[()]>                 => <#'u'#>
        | <[$o.$m]>              => $<#$(ConvExpr(o)).$m#>
        | <[ if ($a) $b else $c]> when statement => $<#if ($(ConvExpr(a))) $(ConvExpr(b)) else $(ConvExpr(c))#>
        | <[ if ($a) $b else $c]> when !statement => $<#$(ConvExpr(a)) ? $(ConvExpr(b)) : $(ConvExpr(c))#>
        | <[ array[..$val] ]>   => CreateArray(val)
        | <[ [..$e]]>           => CreateArray(e)
        | <[ $e : $t]>          => $<#($(ConvExpr(t)))$(ConvExpr(e))#>
      }      
    }

    CreateGlobRef(name : string, val : PExpr) : string
    {
      def ty = Typer(gen.TypingMethod);
      def te = ty.TypeExpr(val);

      def type = ConvType(te);
      def val = ConvExpr(val, true);
      //<[decl: mutable $(name : usesite) : $(te.ty : typed) = $val]>
      //cpp("decl: $(type : type) $name = $val;")
      $"$type $name = $val;"
    }

    CreateVals(expr : PExpr) : string
    {
      | <[ def $(name : usesite) = $val]> => 
          def type = typer.TypeExpr(val);
          //def ty = type.ty;
          def type = type |> ConvType;
          def val = ConvExpr(val, false);
          //<[ decl: $(name : usesite) : $(ty : typed) = $val ]>
          //cpp("decl: $(type : type) $name = $val;")
          $"static const $type $name = $val;"
      | _ => null
    }

    ProcessFun(expr : PExpr) : PExpr
    {


      def proc_parms(p, t, b)
      {
        def proc_parm(p, (parm, e))
        {
          def (p, e) = match (p)
                        {
                          | <[parameter: $(n : usesite) : Index.[$(type : usesite)]]> => 
                              match (model.GetIndex(type))
                              {
                                | Some((t, _)) => (<[parameter: $(n : usesite) : $(t : usesite)]> :: parm, e)
                                | _            => (parm, e)
                              }
                          | p => (p :: parm, e)  
                        }

          def e = if (t is Some(t))      
                    match (e)
                    {
                      | [] => e
                      | lst => def (last, e : list[PExpr]) = lst.PartitionLast();
                  def last = match (last)
                  {
                    | <[ {(..$e)} ]>
                    | <[(..$e)]> when e.All(x => x is PExpr.Assign) => <[ $t(..$e)]>
                    | e => e
                  }
                  e + [last]
                    } else e;

          (p, e)
        }

        def expr = <[ {..$b} ]>;
        def (p, expr) = p.Fold(([], expr :: []), proc_parm);
        (p.Rev(), expr)
      }

      match (expr)
      {
        | <[ def $(n : usesite)(..$parms) { ..$body } ]> => 

          def (parms, expr) = proc_parms(parms, None(), body);

          <[ def $(n : usesite)(..$parms) { ..$expr } ]>

        | <[ def $(n : usesite)(..$parms) : $t { ..$body } ]> => 

          def (parms, expr) = proc_parms(parms, Some(t), body);

          <[ def $(n : usesite)(..$parms) : $t { ..$expr } ]>


      }
    }

    CreateDecl(expr : PExpr) : string
    {
      | <[ def $(n : usesite)(..$_) { ..$_ } ]> => 

          if (n.StartsWith("FUNC_")) null else
          if (n.StartsWith("EXT_"))
          {
            def n = n.Substring(4);
            $<#function $n;#>
          } else
          {
            def func = ProcessFun(expr);
            def ty = Typer(gen.TypingMethod);
            def te = ty.TypeExpr(func);
          //def type = te |> ConvType;
            match (func)
            {
              | <[ def $(n : usesite)(..$parms) { ..$expr } ]> =>
                  match (te)
                  {
                    | TExpr.DefFunctionsIn(h :: _, _) => def ret = h.ReturnType |> ConvType;
                                                      def expr = expr.Map(ConvExpr(_, true));
                                                      def (last, expr) = expr.PartitionLast();
                                                      def parms = parms.Map(ConvParm);
                                                      $<#$ret $n(..$(parms; ","))
                                                       {..$(expr;";\n")
                                                         return $last;
                                                       }
                                                       #>
                                                      //<[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                      //  {
                                                      //    ..$expr
                                                      //  }]>
                  }
            }
          }
      | <[ def $(n : usesite)(..$_) : $_t { ..$_ } ]> => 

          if (n.StartsWith("FUNC_")) null else
          if (n.StartsWith("EXT_"))
          {
            def n = n.Substring(4);
            $<#function $n;#>
          } else
          {
            def func = ProcessFun(expr);
            match (func)
            {
              | <[ def $(n : usesite)(..$parms) : $t { ..$expr } ]> =>
                  def ret = t.ToString();//FinalType(t.ToString());

                  def expr = expr.Map(ConvExpr(_, true));
                  def expr = if (ctx.IsEmpty()) expr else $<#..$(ctx;"\n")#> :: expr;
                  def (last, expr) = expr.PartitionLast();
                  def parms = parms.Map(ConvParm);
                  $<#$ret $n(..$(parms; ","))
                    {..$(expr;";\n")
                      return $last;
                    }
                    #>
                                                      //<[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                      //  {
                                                      //    ..$expr
            }                                           //  }]>
          }
      | _ => null
    }

    CreateColourSet(col : GenColour) : string
    {
      match (col.Colour)
      {
        | ColourSet(n, Colour.Product(vals))   => def fnames = vals.MapI((i, t) => ($"field$(i + 1)", t));
                                                  def ctor = fnames.Map(ConvParm);
                                                  def ftypes = fnames.Map((n, t) => (n, ColourFromStr(t).DestType));
                                                  def fields = ftypes.Map((n, t) => $"$t $n;");
                                                  def ctorbody = fnames.Map((f, _) => $"this->$f = $f;");
                                                  $<#struct $n
                                                        {
                                                          $n(..$(ctor;", ")) 
                                                          {
                                                            ..$(ctorbody;"\n")
                                                          }

                                                          ..$(fields;"\n")
                                                        };#>

                                                  //CTypeDecl.Decl(CTree.Decl([CSpec.Typedef()], CType.Class(n), [CDecl.Id(CName.String(new_name), None())]))
        | ColourSet(n, Colour.Record(vals))     => 
                                                  def ctor = vals.Map(ConvParm);
                                                  def ftypes = vals.Map((n, t) => (n, ColourFromStr(t).DestType));
                                                  def fields = ftypes.Map((n, t) => $"$t $n;");
                                                  def ctorbody = vals.Map((f, _) => $"this->$f = $f;");
                                                  $<#struct $n
                                                        {
                                                          $n(..$(ctor;", ")) 
                                                          {
                                                            ..$(ctorbody;"\n")
                                                          }
                                                          ..$(fields;"\n")
                                                        };#>
        | ColourSet(n, Colour.Index(_mn, _mx, i)) =>   $<#typedef $n int;;
                                                     typedef $i int;#>;
        //def name = Macros.UseSiteSymbol(n);
                                                  //def mods = AttributesAndModifiers(NemerleModifiers.Private, []);
                                                  //def al = TopDeclaration.Alias(name, mods, Typarms.Empty, <[ $(new_name : usesite) ]>);
                                                  //al |> ClassMember.TypeDeclaration.TypeDeclaration;
                                                  // cpp("typedef $n $new_name")
            //$"typedef $n $new_name;"
        //| ColourSet(n, Colour.Unit(Some(t))) => 
        | ColourSet(n, Colour.Unit(Some(t))) => $<#typedef $t $n;
                                                   typedef char $t;
                                                  #>

        | ColourSet(n, Colour.Integer) => def t = col.DestType;
                                          $<#typedef $t $n;#>   
        | ColourSet(n, Colour.Alias(t))
        | ColourSet(n, Colour.Unit) with t = "char"                                                       
        | ColourSet(n, Colour.Simple(t))  => $<#typedef $t $n;#>
        | ColourSet(n, Colour.Enum(vals)) => //def vals = vals.Map(x => $"$x");
                                            $<#    enum $n
                                                   {
                                                     ..$vals;
                                                   };#>
        | ColourSet(n, Colour.Timed(c))   => CreateColourSet(ColourSet(n, c) |> GenColour(_, this))

        | _                               => null
      }
    }    

    CreateInitMarking(place : Place) : string
    {
      def combine(e1, e2)
      {
        | (<[Enumerable.Repeat($tok, $(n : int))]>, <[Enumerable.Repeat($tok2, $(n2 : int))]>) when (tok.Equals(tok2)) 
            => <[Enumerable.Repeat($tok, $(n2 + n))]>
        | (<[Enumerable.Repeat($(tok : int), $(n : int))]>, <[Enumerable.Repeat($(tok2 : int), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : int)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : string), $(n : int))]>, <[Enumerable.Repeat($(tok2 : string), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : string)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : double), $(n : int))]>, <[Enumerable.Repeat($(tok2 : double), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : double)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>       
        | _  //(<[Enumerable.Repeat($_, $(_ : int))]>, <[Enumerable.Repeat($_, $(_ : int))]>)                         
            => <[ $e1.Concat($e2)]> 
      }

      def unfold(expr)
      {
        | <[ () ]> => <[()]>
        | e        => e
      }

      def fold(expr) : PExpr
      {
        //| <[ {..$e} ]>   => e.Fold(acc, fold)
        | <[ 1 ` $tok %@ $time ]>             => def time = time |> ConvExpr(_, false);
                                                def tok = unfold(tok);
                                                <[at_time($tok, $time)]>
        | <[ 1 ` $tok]>                       => <[$(unfold(tok))]>
        | <[ $(n : int) ` $tok %@ $time ]>    => <[IEnumerable.Repeat(at_time($(unfold(tok)), $time), $n)]>
        | <[ $(n : int) ` $tok]>              => <[IEnumerable.Repeat($(unfold(tok)), $n)]>
        | <[ $l %++ $r]>                      => <[$(combine(fold(l), fold(r)))]>
        | e                                   => unfold(e)
      }

      if (place.init_mark == null) null else
      {
        def mark = fold(place.init_mark);
        def mark = mark |> ConvExpr(_, false);
        def mark = if (place.IsTimed) $"add_time($mark, 0);" else mark;
        def name = place.name;
        //<[ $(name : usesite).Add($mark)]>
        $"$name.add($mark);"
      }
    }

    //CreateToString() : void
    //{
    //  def strings = model.places.Map(x => <[ $(x.name : usesite).ToString() ]>);
    //  fields ::= <[decl: public override ToString() : string 
    //  { 
    //    def str = array[..$strings];
    //    string.Join(";\n", str)
    //  }]>
    //}


    CreateCons() : void
    {
      def marking = model.places.MapToList(CreateInitMarking).Filter(_ != null);
      public_fields ::= if (model.IsTimed || model.IsHaveImmediateTransitions) 
      $<#$Name(int time_step = 15) 
      { 
        $Base(time_step);
        ..$(marking;"\n")
        ..$(cons_expr;"\n")
      }#>; 
                        else $<#$Name(int time_step = 15) 
      { 
        ..$(marking;"\n")
        ..$(cons_expr;"\n")
      }#>;//<[decl: public this() { {..$marking} {..$cons_expr} }]>;
    }

    CreateTimeMethods() : void
    {
      def body = model.transitions.Where(_.IsTimed).Map(x => <[ $(x.Name : usesite)() ]>);
      def next = model.places.Where(_.IsTimed).Map(x => $"$(x.name).NextTokenDelay");

      def time_body = match (next)
                       {
                         | []    => "return 0xFFFFFFFF;"
                         | [one] => one
                         | lst   => def next = lst.Map(x => $<#min = math_utils::min(min, $x); #>);
                          $<#
                                  int min = 0xFFFFFFFF;
                                  ..$(next;"\n");
                                  return min;
                              #>
                       }
      private_fields ::= $<#int get_next_time()
                      {
                        $time_body;
                      }#>;
      private_fields ::= $<#void time_step()
                      {
                        ..$body;
                      }#>
    }

    CreateStepMethod() : void
    {
      def body = model.transitions.Where(x => x.IsImmediate && !x.IsTimed).Map(x => $<#$(x.Name)()#>);
      when (!body.IsEmpty())
        public_fields ::= $<#void step()
      {
        ..$(body; "\n")
      }#>
    }

    CreateStartMethod() : void
    {
      //fields ::= []
      /*cpp(<#decl: void Initiate()
                      {
                        ..$init_body;
                      })*/
    }

    CreateEvents() : void
    {
      when (proc.Flags.HasFlag(PetriNetFlags.Events))
      {
        foreach (t in model.transitions)
        {
          def name = t.Name;
          def evt = $"evt_$name";
          //fields ::= $<#decl: public event $(evt : usesite) : Action#>;
          //fields ::= <[decl: $($"On$name" : usesite)() : void
          //            {
          //              $(evt : usesite)?.Invoke()
          //            } ]>;
        }
      }
    }

    public Generate() : void
    {      
      //CreateOperators();
      //assert2(false);
    // создаем типы генерации из цветов
      foreach (c in model.colour_sets)
      {
        colours.Add(c.Key, c.Value |> GenColour(_, this))
      }

      def sets = colours.Values.Map(x => CreateColourSet(x) + "\n").Filter(_ != null);
      Define(sets);//typebuilder.DefineNestedTypeWithSource(m).Compile();

      def places = model.places.MapToList(CreatePlace);      

      when (model.IsTimed) CreateTimeMethods();
      CreateStepMethod();

      CreateEvents();
      //CreateTranQueue();
      //CreateToString();
      CreateStartMethod();
      CreateCons();

      def members = places;
      Define(members)//_ = typebuilder.DefineWithSource(m);
    }

    Define(decl : list[string], pub : bool = false) : void
    {
      if (pub)
      {
        foreach (d in decl) 
        {
          public_fields ::= d;
          //public_fields ::= "\n"
        }
      } else
      {
        foreach (d in decl)
        {
          private_fields ::= d;
          //private_fields ::= "\n"
        }
      }
    }

    Define(decl : string) : void
    {
      private_fields ::= decl;
      //private_fields ::= "\n"
      //def ty = CTree.Type.type_lens >> CComplexType.Class.decls_lens;
      //main_class = ty.Update(main_class, x => x.Append(decl));
      //(main_class.type :> CComplexType.Class).
    }


    public PhaseOne() : void
    {
      //def name = proc.Name;

      //main_class = cpp(<#class $name : public $(bas : type)
      //                {
      //                };#>);
      //printer.
      //typebuilder.AddImplementedInterface(<[ IDisposable ]>);
      //typebuilder.AddImplementedInterface(if (model.IsTimed) <[ TimedPetriNet ]> 
      //                                    else <[PetriNet]>);
    }

    public PhaseTwo() : void
    {
      //CreateDummyMethod();
      def methods = model.transitions.MapToList(CreateTran);
      def vals = model.ml_decls.Map(CreateVals).Filter(_ != null);
      Define(vals);//_ = typebuilder.DefineWithSource(m);
      def decls = model.ml_decls.Map(CreateDecl).Filter(_ != null);
      def (ext, decls) = decls.Partition(x => x.StartsWith("function"));
      def globrefs = model.glob_refs.KeyValuePairs.MapToList(CreateGlobRef);
      Define(globrefs);//_ = typebuilder.DefineWithSource(m);
      Define(methods, true);
      Define(decls);
      Define(ext, true);
      System.IO.File.WriteAllText(file, main_class)
      //typebuilder.Compile()
    }
  }
}