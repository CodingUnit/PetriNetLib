using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Builtins;
using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using CommonLib.Macros;
using PetriNetModel;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace PetriNetLib
{
  using CommonLib.Macros.LensUtils;

  /*
  - вводится понятие переходов функций они действую совместно со своими позициями, когда вызывается 
    функция, то вызывается переход и сеть срабатывает, фишки выходят в позицию как результат функции
    для правильной работы нужно чтобы эта функция могла блокировать сеть на время своей работы, 
    если другой переход срабатывает во время вызова функции, то функция должна вернуть
    переход к его начальному состоянию, для этого переходы которые может прерывать функция,
    те с пересекающимися позициями, должны сохранять свое состояние до перехода и надо восстанавливать
    это состояние из перехода функции, тогда сеть должна функционировать правильно,
    после того как функция сработала и фишки извлечены можно запустить отложенный переход который был 
    прерван, если в момент сохранения состояния вызывается переход функции, то переход срабатывает, а состояние
    должно сохранятся снова сначала после изменения состояния функции-перехода
  */
  /// <summary>
  /// Description of Generator.
  /// </summary>
  partial class CppGenerator
  {
    [Accessor]
    model       : OutModel;
    [Accessor]
    proc        : PetriNetProcessor;
    converter   : Converter;
    typer       : Typer;
    typebuilder : TypeBuilder;
    gen         : Generator;
    colours     : Hashtable[string, GenColourCpp] = Hashtable();
    places      : array[GenPlaceCpp];
    

    internal CreateArray(expr : list[PExpr]) : string
    {
      def ty = Typer(gen.TypingMethod);
      def te = ty.TypeExpr(<[ [..$expr] ]>);
      def ty = te.ty;
      def len = expr.Length;
      def (type, n, ty) = match (ty)
                           {
                             | FixedType.Class(_, [args]) => def byte = typer.BindType(<[ byte ]>);
                                        if (args.TryRequire(byte))
                                        {

                                          if (len <= 10)
                                          {
                                            ($"byte$len", false, "u8")
                                          } else
                                          {
                                            ("byten", true, "u8")
                                          }
                                        } else (null, false, null)
                            | _ => throw InvalidOperationException()
                                        //if (args.TryRequire(integer))
                                        //{
                                        //} else
                                        //if (args.TryRequire(uinteger))
                                        //{
                                        //} else
                                        //if (args.TryRequire(longint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(ulongint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(shortint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(ushortint))
                                        //{
                                        //}
                           }
      //mutable lst = [];
      def expr = expr.Map(ConvExpr(_, false));
      //{..$(expr; ",")}
      def var = Macros.NewSymbol();
      if (n)
      {
        ctx ::= $<#$ty $var[] = {..$(expr;", ")};#>;
        $<#$type($var, $len)#>
      } else
      {
        ctx ::= $<#$ty $var[] = {..$(expr;", ")};#>;
        $<#$type($var)#>
      }
    }


    CreateTranBody(tran : Transition) : string
    {
      def input  = tran.InputPlaces;
      def output = tran.OutputPlaces;
      def name   = tran.Name;
      //def map    = Hashtable();

      def input = input.Map((x, a) => InArcBindingCpp(places[x.idx], this, tran, [], a));

      foreach (i in input)
      {
        match (i.expr)
        {
          | <[ $_(..$p) ]> => foreach (p in p)
                                {
                                  | <[ $(n : usesite)]> => match (input.Find(x => x.bind_var == n))
                                      {
                                        | Some(x) => i.Depends ::= x;
                                        | _       => ()
                                      }
                                  | _                   => ()
                                }
          | _ => ()
        }
        //map[i.name] = i;
      }

      def input    = input.Sort((x, y) => y.priority - x.priority); 
      def add_proc = output.Map((p, a) => OutArcProcessCpp(places[p.idx], tran, a, this));

      def extract = input.Map(_.extract_expr);
      def add_body = add_proc.Map(_.add_token);
      def code = (tran.code_segment |> ConvExpr(_, true)) + ";" ?? "";
      
      //def combine(x, a)
      //{
      //  def expr = x.check_explicit_expr;
      //  match (expr.IsEmpty(), a.IsEmpty())
      //  {
      //    | (true, true)   => ""
      //    | (false, true)  => expr
      //    | (true, false)  => a
      //    | (false, false) => $"$expr && $a"
      //  }
      //}
      //def mask_for_places(pl)
      //{
      //  pl.Fold("", (x, a) => if (a.IsEmpty()) $"pl_$(x.Name)" else $"pl_$(x.Name) | $a");
      //}
      
      //def check_in = input.Fold("", combine);
      //def check_in = if (check_in.IsEmpty()) "true" else check_in;
      //def rem_mask = input.Select(x => x.place) |> mask_for_places;
      //def add_mask = output.Select(x => x[0]) |> mask_for_places;//Fold("", ((x, _), a) => if (a.IsEmpty()) $"pl_$(x.Name)" else $"pl_$(x.Name) | $a");
      
      //def ena = $<#places_ena($check_in, $rem_mask, $add_mask);#>;
      def out_tran = tran.OutputPlaces.SelectMany((x : Place, _) => x.OutputTransitions.Select((x : Transition, _) => x)).NToList();
      def participate_tran = out_tran;
      
      def tr_pl_mask = participate_tran.Where(_.IsImmediate).Map(x => $"tr_$(x.Name)");//, x.InputPlaces.Select(x => x[0]) |> mask_for_places));
      def tr_comp_mask = if (tran.IsImmediate && !tran.IsPartOfGroupTransition) $"tr_$(tran.Name)" else "0";
      //def tr_ena = tr_pl_mask.Map((t, p) => $<#tr_ena |= ((places & ($p)) == ($p)) * $t;#>);
      def tr_mask = tr_pl_mask.Fold("", (t, a) => if (a.IsEmpty()) t else $"$t | $a");
      def tr_mask = if (tr_mask.IsEmpty()) "0" else tr_mask;
      def tr_ena = $"tran_ena($tr_mask, $tr_comp_mask);";
      //def tr = "ttran ena_tr = (ttran)0;";
      def body = extract + (code :: add_body) + [tr_ena] + ["return true;"];
      def body = body.Filter(x => !x.IsEmpty());
      def body = if (tran.guard is <[]>) body else //tran_ena($t, $p);
                  {
                    def guard = tran.guard |> ConvExpr(_, false);
                    $<#if ($guard) 
                    {
                      ..$(body;"\n")
                    }#> :: [];
                  }

      def tran_evt = if (proc.Flags.HasFlag(PetriNetFlags.Events)) $<#On$name()#> else "";

      def fold(x, a)
      {
        if (a : object == null)
        {
          def expr = x.bind_expr :: body + [tran_evt];
          def expr = expr.Filter(x => !x.IsEmpty());
          def expr = $<#..$(expr;"\n")#>;
          if (x.check_expr.IsEmpty())
          {
            $<#$expr#>
          }
          else
          {
            $<# if ($(x.check_expr))
                {
                  $expr
                }#>
          }
        } else
        {
          def expr = [x.bind_expr] + [a];
          def expr = expr.Filter(x => !x.IsEmpty());
          def expr = $<#..$(expr;"\n")#>;
          if (x.check_expr.IsEmpty())
            expr
          else
            $<# if ($(x.check_expr))
              {
                $expr
              }#>
        }
      }


      //def input = eval(input, []);

      input.Fold(null, fold)
    }    
    
    CreateGroupTransitions() : void
    {
      def places = places.Where(x => !CommonLib.Macros.ListUtils.ElementsEqual(x.OutputTransitions.Where((x, _) => x.IsUnnamed).Map((x, _) => x.priority), _ == _));
      foreach (p in places)
      {
        def tran = p.OutputTransitions.Where((x, _) => x.IsUnnamed).NToList();
        def sorted = tran.Sort(((x, _), (y, _)) => x.priority.CompareTo(y.priority)).Rev();
        def group = sorted.Fold("return;", ((x, _), a) => $"if (!$(x.Name)()) \n$a");
        def name = tran.Map((x, _) => x.UnnamedIdx);
        def name = name.Fold("", (x, a) => $"$x$a");
        def tr_comp = $"tr_GroupTransition$name";
        private_fields ::= $<#void GroupTransition$name()
                              {
                                $group
                                tran_ena(0, $tr_comp);
                              }#>;
      }
    }
    
    CreatePlaces() : string
    {
      mutable gen_idx = 0;
      foreach (p in places)
      {
        when (!p.IsTransparent)
        {
          p.gen_idx = gen_idx;
          gen_idx++;    
        }
      }
        
      def enums = places.Where(x => !x.IsTransparent).Map(x => $<#pl_$(x.Name) = 0x$((1 << x.gen_idx).ToString("X"))#>);
      $<#typedef enum
         {
           ..$(enums;",\n")
         } tplace;#>
    }
    
    CreatePlace(place : GenPlaceCpp) : string
    {
      
      // TODO: transparent place
      if (place.IsTransparent) null else
      {
        
        def name = place.Name;
        //def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
        def type = place.Colour.DestType;
        def dtype = place.DestContainerType;
        def dest_cont = match (dtype)
                         {
                           | TDestCont.MultiSet  => "multi_set"//cpp("type: multi_set")
                           | RandomEnumerable    => "random_array"//cpp("type: random_array")
                           | SortedSet           => "sorted_array"//cpp("type: sorted_array")
                           | TokenQueue          => "token_queue"//cpp("type: token_queue")
                           | TimedSimpleMultiset => "timed_heap"//cpp("type: timed_heap")
                           | ZeroSingle
                           | MinusSingle
                           | Var
                           | Single              => type
                           | ReqContainer        => "req_tokens"
                         }
        def flag = match (dtype)
        {
          | Single              => if (place.Colour.IsUnit) "" else $"$(name)_flag"
          | _                   => ""
        }
        def deflt = match (dtype)
        {
          | ZeroSingle  => " = 0"
          | MinusSingle => " = -1"
          | _           => ""
        }
        def flag = if (flag.IsEmpty()) "" else $"\nbool $flag = false;";
        $<#$dest_cont $name$deflt;$flag#>
      }
      //cpp(<#decl: $(dest_cont : type) $name;#>)
      //if (place.IsTimed)
      //<[decl: $(name : usesite) : PetriNetModel.TimedPlace.[$type] = PetriNetModel.TimedPlace($(name : string), $dest_cont)]> else
      //<[decl: $(name : usesite) : PetriNetModel.Place.[$type] = PetriNetModel.Place($(name : string), $dest_cont)]>
    }

    CreateTransitions() : void
    {
      def func = $<#      
      tran_func get_transition(int n) const
	    {
		    return tran_funcs[n];
	    }
      #>;
      protected_fields ::= func;
      def tran = model.transitions.Sort(x => x.priority).Map(x => x.Name);
      private_fields ::= $<#tran_func tran_funcs[] = {..$(tran;",\n")
      };#>;
      
      def tran = model.transitions.Select((x, i) => $<#tr_$(x.Name) = 0x$((1 << i).ToString("X"))#>);
      private_fields ::= $<#typedef enum 
      {
        ..$(tran;",\n")
      } ttran;#>
    }
    
    CreateTran(tran : Transition) : string
    {
      def name = tran.Name;

      def body = CreateTranBody(tran);      
      //def places = tran.InputPlaces.Map((x, _) => x.gen_idx);
      def places_participate = tran.InputPlaces + tran.OutputPlaces;
      def places = places_participate.Fold("", ((x, _), a) => if (a.IsEmpty()) $"pl_$(x.Name)" else $"pl_$(x.Name) | $a");
      //def rem = tran.InputPlaces.Fold("", ((x, _), a) => if (a.IsEmpty()) $"pl_$(x.Name)" else $"pl_$(x.Name) | $a");
      //cpp(<#
      def tr = if (tran.PartOfGroup is Some(g)) $"tr_GroupTransition$g" else $"tr_$(tran.Name)";
        $<#bool $name()
            {
              if (lock($places, $tr))
              {
                $body;
                unlock($places);
              }
              return false;
            }
          #>//)
    }

    internal TypeOfVar(name : string) : string
    {
      match (model.vars.Find(x => x.Key == name))
      {
        | Some(x) => def col = colours[x.Value.name];
                     col.DestType
        | _       => ""
      }
    }

    internal ConvExpr(expr : PExpr, statement : bool = false) : string
    {
      when (statement) ctx = [];
      match (expr)
      {
        | <[ true ]>                      => "true"
        | <[ false ]>                     => "false"
        | <[ {$seq} ]>                    => ConvExpr(seq, true)
        | <[ {..$seq} ]> when (statement) => match (seq)
            {
              | []  => ""
              | seq => def seq = seq.Map(ConvExpr(_, true));
                                                        $<#..$(seq;";\n")#>
            }
        | <[ $n ` $t]>          => $<#token_iter_utils.repeat($(ConvExpr(t)), $(ConvExpr(n)))#>
        | <[ $a %++ $b]>        => $<#token_iter_utils.concat($(ConvExpr(a)), $(ConvExpr(b)))#>
        | <[]>                  => ""
        | <[ $a != $b]>         => $<#$(ConvExpr(a)) != $(ConvExpr(b))#>
        | <[ $a == $b]>         => $<#$(ConvExpr(a)) == $(ConvExpr(b))#>
        | <[ $a + $b]>          => $<#$(ConvExpr(a)) + $(ConvExpr(b))#>
        | <[ $a * $b]>          => $<#$(ConvExpr(a)) * $(ConvExpr(b))#>
        | <[ $(n : usesite)]>   => $<#$n#>
        | <[ Enumerable.Repeat($tok, $n) ]> => $<#token_iter_utils.repeat($(ConvExpr(tok)), $(ConvExpr(n)))#>
        | <[ $(e1).Concat($e2) ]> => $<#token_iter_utils.concat($(ConvExpr(e1)), $(ConvExpr(e2))#>
        //| <[ $func(..$parms) ]> when (parms.All(x => x is PExpr.Assign)) =>


        | <[ $func(..$parms) ]> => def func = ConvFunc(func.ToString());
                                   if (parms.All(x => x is PExpr.Assign)) 
                                   {
                                     def get_rec_parm(x)
                                     {
                                       | <[$_ = $v]> => v |> ConvExpr(_, false)
                                       | _                     => throw InvalidOperationException()
                                     }

                                     
                                     def parms = parms.Map(get_rec_parm);
                                     $<#$func(..$(parms; ","))#>
                                   } else
                                   {
                                     def parms = parms.Map(ConvExpr(_, false));
                                     $<#$func(..$(parms; ","))#>
                                   }
        | <[ $(_ : int)]> as e
        | <[ $(_ : long)]> as e
        | <[ $(_ : short)]> as e
        | <[ $(_ : ushort)]> as e
        | <[ $(_ : byte)]> as e => $<#$e#>
        | <[ $(n : string)]>    => $<#$n#>
        | <[ (..$e) ]>          => match (e)
            {
              | [e]                  => ConvExpr(e)
              | [e1, e2]             => $<#tuple2($(ConvExpr(e1)), $(ConvExpr(e2)))#>
              | [e1, e2, e3]         => $<#tuple3($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)))#>
              | [e1, e2, e3, e4]     => $<#tuple4($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)), $(ConvExpr(e4)))#>
              | [e1, e2, e3, e4, e5] => $<#tuple5($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)), $(ConvExpr(e4)), $(ConvExpr(e5)))#>
              | _                     => throw InvalidOperationException()
            }

        | <[()]>                 => <#'u'#>
        | <[$o.$m]>              => $<#$(ConvExpr(o)).$m#>
        | <[ if ($a) $b else $c]> when statement => $<#if ($(ConvExpr(a))) $(ConvExpr(b)) else $(ConvExpr(c))#>
        | <[ if ($a) $b else $c]> when !statement => $<#$(ConvExpr(a)) ? $(ConvExpr(b)) : $(ConvExpr(c))#>
        | <[ array[..$val] ]>   => CreateArray(val)
        | <[ [..$e]]>           => CreateArray(e)
        | <[ $e : $t]>          => $<#($(ConvExpr(t)))$(ConvExpr(e))#>
        | _                     => throw InvalidOperationException()
      }      
    }

    CreateGlobRef(name : string, val : PExpr) : string
    {
      def ty = Typer(gen.TypingMethod);
      def te = ty.TypeExpr(val);

      def type = ConvType(te);
      def val = ConvExpr(val, true);
      //<[decl: mutable $(name : usesite) : $(te.ty : typed) = $val]>
      //cpp("decl: $(type : type) $name = $val;")
      $"$type $name = $val;"
    }

    CreateVals(expr : PExpr) : string
    {
      | <[ def $(name : usesite) = $val]> => 
          def type = typer.TypeExpr(val);
          //def ty = type.ty;
          def type = type |> ConvType;
          def val = ConvExpr(val, false);
          //<[ decl: $(name : usesite) : $(ty : typed) = $val ]>
          //cpp("decl: $(type : type) $name = $val;")
          $"static const $type $name = $val;"
      | _ => null
    }

    ProcessFun(expr : PExpr) : PExpr
    {


      def proc_parms(p, t, b)
      {
        def proc_parm(p, (parm, e))
        {
          def (p, e) = match (p)
                        {
                          | <[parameter: $(n : usesite) : Index.[$(type : usesite)]]> => 
                              match (model.GetIndex(type))
                              {
                                | Some((t, _)) => (<[parameter: $(n : usesite) : $(t : usesite)]> :: parm, e)
                                | _            => (parm, e)
                              }
                          | p => (p :: parm, e)  
                        }

          def e = if (t is Some(t))      
                    match (e)
                    {
                      | [] => e
                      | lst => def (last, e : list[PExpr]) = lst.PartitionLast();
                  def last = match (last)
                  {
                    | <[ {(..$e)} ]>
                    | <[(..$e)]> when e.All(x => x is PExpr.Assign) => <[ $t(..$e)]>
                    | e => e
                  }
                  e + [last]
                    } else e;

          (p, e)
        }

        def expr = <[ {..$b} ]>;
        def (p, expr) = p.Fold(([], expr :: []), proc_parm);
        (p.Rev(), expr)
      }

      match (expr)
      {
        | <[ def $(n : usesite)(..$parms) { ..$body } ]> => 

          def (parms, expr) = proc_parms(parms, None(), body);

          <[ def $(n : usesite)(..$parms) { ..$expr } ]>

        | <[ def $(n : usesite)(..$parms) : $t { ..$body } ]> => 

          def (parms, expr) = proc_parms(parms, Some(t), body);

          <[ def $(n : usesite)(..$parms) : $t { ..$expr } ]>

        | _                     => throw InvalidOperationException()
      }
    }

    CreateDecl(expr : PExpr) : string
    {
      | <[ def $(n : usesite)(..$_) { ..$_ } ]> => 

          if (n.StartsWith("FUNC_")) null else
          if (n.StartsWith("EXT_"))
          {
            def n = n.Substring(4);
            $<#function $n;#>
          } else
          {
            def func = ProcessFun(expr);
            def ty = Typer(gen.TypingMethod);
            def te = ty.TypeExpr(func);
          //def type = te |> ConvType;
            match (func)
            {
              | <[ def $(n : usesite)(..$parms) { ..$expr } ]> =>
                  match (te)
                  {
                    | TExpr.DefFunctionsIn(h :: _, _) => def ret = h.ReturnType |> ConvType;
                                                      def expr = expr.Map(ConvExpr(_, true));
                                                      def (last, expr) = expr.PartitionLast();
                                                      def parms = parms.Map(ConvParm);
                                                      $<#$ret $n(..$(parms; ","))
                                                       {..$(expr;";\n")
                                                         return $last;
                                                       }
                                                       #>
                                                      //<[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                      //  {
                                                      //    ..$expr
                                                      //  }]>
                     | _                     => throw InvalidOperationException()                                  
                  }
               | _                     => throw InvalidOperationException()
            }
          }
      | <[ def $(n : usesite)(..$_) : $_t { ..$_ } ]> => 

          if (n.StartsWith("FUNC_")) null else
          if (n.StartsWith("EXT_"))
          {
            def n = n.Substring(4);
            $<#function $n;#>
          } else
          {
            def func = ProcessFun(expr);
            match (func)
            {
              | <[ def $(n : usesite)(..$parms) : $t { ..$expr } ]> =>
                  def ret = t.ToString();//FinalType(t.ToString());

                  def expr = expr.Map(ConvExpr(_, true));
                  def expr = if (ctx.IsEmpty()) expr else $<#..$(ctx;"\n")#> :: expr;
                  def (last, expr) = expr.PartitionLast();
                  def parms = parms.Map(ConvParm);
                  $<#$ret $n(..$(parms; ","))
                    {..$(expr;";\n")
                      return $last;
                    }
                    #>
              | _                     => throw InvalidOperationException()                                       //<[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                      //  {
                                                      //    ..$expr
            }                                           //  }]>
          }
      | _ => null
    }

    CreateColourSet(col : GenColourCpp) : string
    {
      match (col.Colour)
      {
        | ColourSet(n, Colour.Product(vals))   => def fnames = vals.MapI((i, t) => ($"field$(i + 1)", t));
                                                  def ctor = fnames.Map(ConvParm);
                                                  def ftypes = fnames.Map((n, t) => (n, colours[t].DestType));
                                                  def fields = ftypes.Map((n, t) => $"$t $n;");
                                                  def ctorbody = fnames.Map((f, _) => $"this->$f = $f;");
                                                  $<#struct $n
                                                        {
                                                          $n(..$(ctor;", ")) 
                                                          {
                                                            ..$(ctorbody;"\n")
                                                          }

                                                          ..$(fields;"\n")
                                                        };#>

                                                  //CTypeDecl.Decl(CTree.Decl([CSpec.Typedef()], CType.Class(n), [CDecl.Id(CName.String(new_name), None())]))
        | ColourSet(n, Colour.Record(vals))     => 
                                                  def ctor = vals.Map(ConvParm);
                                                  def ftypes = vals.Map((n, t) => (n, colours[t].DestType));
                                                  def fields = ftypes.Map((n, t) => $"$t $n;");
                                                  def ctorbody = vals.Map((f, _) => $"this->$f = $f;");
                                                  $<#struct $n
                                                        {
                                                          $n(..$(ctor;", ")) 
                                                          {
                                                            ..$(ctorbody;"\n")
                                                          }
                                                          ..$(fields;"\n")
                                                        };#>
        | ColourSet(n, Colour.Index(_mn, _mx, i)) =>   $<#typedef $n int;;
                                                     typedef $i int;#>;
        //def name = Macros.UseSiteSymbol(n);
                                                  //def mods = AttributesAndModifiers(NemerleModifiers.Private, []);
                                                  //def al = TopDeclaration.Alias(name, mods, Typarms.Empty, <[ $(new_name : usesite) ]>);
                                                  //al |> ClassMember.TypeDeclaration.TypeDeclaration;
                                                  // cpp("typedef $n $new_name")
            //$"typedef $n $new_name;"
        //| ColourSet(n, Colour.Unit(Some(t))) => 
        | ColourSet(n, Colour.Unit(Some(t))) => $<#typedef $t $n;
                                                   typedef char $t;
                                                  #>

        | ColourSet("REAL", Colour.Simple(_t))  => null
        | ColourSet(n, Colour.Simple)
        | ColourSet(n, Colour.Integer) => def t = col.DestType;
                                          $<#typedef $t $n;#>   
        | ColourSet(n, Colour.Alias(t))
        | ColourSet(n, Colour.Unit) with t = "char"                                                       
                                          => $<#typedef $t $n;#> 
        
        | ColourSet(n, Colour.Enum(vals)) => //def vals = vals.Map(x => $"$x");
                                            $<#    enum $n
                                                   {
                                                     ..$vals;
                                                   };#>
        | ColourSet(n, Colour.Timed(c))   => CreateColourSet(ColourSet(n, c) |> GenColourCpp(_, this))

        | _                               => null
      }
    }    

    CreateInitMarking(place : Place) : string
    {
      def combine(e1, e2)
      {
        | (<[Enumerable.Repeat($tok, $(n : int))]>, <[Enumerable.Repeat($tok2, $(n2 : int))]>) when (tok.Equals(tok2)) 
            => <[Enumerable.Repeat($tok, $(n2 + n))]>
        | (<[Enumerable.Repeat($(tok : int), $(n : int))]>, <[Enumerable.Repeat($(tok2 : int), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : int)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : string), $(n : int))]>, <[Enumerable.Repeat($(tok2 : string), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : string)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : double), $(n : int))]>, <[Enumerable.Repeat($(tok2 : double), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : double)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>       
        | _  //(<[Enumerable.Repeat($_, $(_ : int))]>, <[Enumerable.Repeat($_, $(_ : int))]>)                         
            => <[ $e1.Concat($e2)]> 
      }

      def unfold(expr)
      {
        | <[ () ]> => <[()]>
        | e        => e
      }

      def fold(expr) : PExpr
      {
        //| <[ {..$e} ]>   => e.Fold(acc, fold)
        | <[ 1 ` $tok %@ $time ]>             => def time = time |> ConvExpr(_, false);
                                                def tok = unfold(tok);
                                                <[at_time($tok, $time)]>
        | <[ 1 ` $tok]>                       => <[$(unfold(tok))]>
        | <[ $(n : int) ` $tok %@ $time ]>    => <[IEnumerable.Repeat(at_time($(unfold(tok)), $time), $n)]>
        | <[ $(n : int) ` $tok]>              => <[IEnumerable.Repeat($(unfold(tok)), $n)]>
        | <[ $l %++ $r]>                      => <[$(combine(fold(l), fold(r)))]>
        | e                                   => unfold(e)
      }

      if (place.init_mark == null) null else
      {
        def mark = fold(place.init_mark);
        def mark = mark |> ConvExpr(_, false);
        def mark = if (place.IsTimed) $"add_time($mark, 0);" else mark;
        def name = place.Name;
        //<[ $(name : usesite).Add($mark)]>
        $"$name.add($mark);"
      }
    }

    //CreateToString() : void
    //{
    //  def strings = model.places.Map(x => <[ $(x.name : usesite).ToString() ]>);
    //  fields ::= <[decl: public override ToString() : string 
    //  { 
    //    def str = array[..$strings];
    //    string.Join(";\n", str)
    //  }]>
    //}


    CreateCons() : void
    {
      def marking = model.places.MapToList(CreateInitMarking).Filter(_ != null);
      public_fields ::= if (model.IsTimed || model.IsHaveImmediateTransitions) 
      $<#$Name(int time_step = 15) 
      { 
        $Base(time_step);
        ..$(marking;"\n")
        ..$(cons_expr;"\n")
      }#>; 
                        else $<#$Name(int time_step = 15) 
      { 
        ..$(marking;"\n")
        ..$(cons_expr;"\n")
      }#>;//<[decl: public this() { {..$marking} {..$cons_expr} }]>;
    }

    CreateTimeMethods() : void
    {
      def body = model.transitions.Where(_.IsTimed).Map(x => <[ $(x.Name : usesite)() ]>);
      def next = model.places.Where(_.IsTimed).Map(x => $"$(x.Name).NextTokenDelay");

      def time_body = match (next)
                       {
                         | []    => "return 0xFFFFFFFF;"
                         | [one] => one
                         | lst   => def next = lst.Map(x => $<#min = math_utils::min(min, $x); #>);
                          $<#
                                  int min = 0xFFFFFFFF;
                                  ..$(next;"\n");
                                  return min;
                              #>
                       }
      private_fields ::= $<#int get_next_time()
                      {
                        $time_body;
                      }#>;
      private_fields ::= $<#void time_step()
                      {
                        ..$body;
                      }#>
    }

    CreateStepMethod() : void
    {
      def body = model.transitions.Where(x => x.IsImmediate && !x.IsTimed).Map(x => $<#$(x.Name)()#>);
      when (!body.IsEmpty())
        public_fields ::= $<#void step()
      {
        ..$(body; "\n")
      }#>
    }

    CreateStartMethod() : void
    {
      //fields ::= []
      /*cpp(<#decl: void Initiate()
                      {
                        ..$init_body;
                      })*/
    }

    CreateEvents() : void
    {
      when (proc.Flags.HasFlag(PetriNetFlags.Events))
      {
        foreach (_t in model.transitions)
        {
          //def name = t.Name;
          //def evt = $"evt_$name";
          //fields ::= $<#decl: public event $(evt : usesite) : Action#>;
          //fields ::= <[decl: $($"On$name" : usesite)() : void
          //            {
          //              $(evt : usesite)?.Invoke()
          //            } ]>;
        }
      }
    }

    public Generate() : void
    {      
      //CreateOperators();
      //assert2(false);
      
    // создаем типы генерации из цветов
      foreach (c in model.colour_sets)
      {
        colours.Add(c.Key, c.Value |> GenColourCpp(_, this))
      }

      def places_enum = CreatePlaces();
      Define(places_enum);
      def sets = colours.Values.Map(x => CreateColourSet(x) + "\n").Filter(_ != null);
      Define(sets);//typebuilder.DefineNestedTypeWithSource(m).Compile();

      def places = places.Map(CreatePlace).Filter(_ != null);      
      
      
      when (model.IsTimed) CreateTimeMethods();
      CreateStepMethod();

      CreateEvents();
      //CreateTranQueue();
      //CreateToString();
      CreateStartMethod();
      

      Define(places)//_ = typebuilder.DefineWithSource(m);
    }

    Define(decl : IEnumerable[string], pub : bool = false) : void
    {
      if (pub)
      {
        foreach (d in decl) 
        {
          public_fields ::= d;
          //public_fields ::= "\n"
        }
      } else
      {
        foreach (d in decl)
        {
          private_fields ::= d;
          //private_fields ::= "\n"
        }
      }
    }

    Define(decl : string) : void
    {
      private_fields ::= decl;
      //private_fields ::= "\n"
      //def ty = CTree.Type.type_lens >> CComplexType.Class.decls_lens;
      //main_class = ty.Update(main_class, x => x.Append(decl));
      //(main_class.type :> CComplexType.Class).
    }


    public PhaseOne() : void
    {
      //def name = proc.Name;

      //main_class = cpp(<#class $name : public $(bas : type)
      //                {
      //                };#>);
      //printer.
      //typebuilder.AddImplementedInterface(<[ IDisposable ]>);
      //typebuilder.AddImplementedInterface(if (model.IsTimed) <[ TimedPetriNet ]> 
      //                                    else <[PetriNet]>);
    }

    public PhaseTwo() : void
    {
      //CreateDummyMethod();
      CreateCons();
      CreateTransitions();
      CreateGroupTransitions();
      def methods = model.transitions.MapToList(CreateTran);
      def vals = model.ml_decls.Map(CreateVals).Filter(_ != null);
      Define(vals);//_ = typebuilder.DefineWithSource(m);
      def decls = model.ml_decls.Map(CreateDecl).Filter(_ != null);
      def (ext, decls) = decls.Partition(x => x.StartsWith("function"));
      def globrefs = model.glob_refs.KeyValuePairs.MapToList(CreateGlobRef);
      Define(globrefs);//_ = typebuilder.DefineWithSource(m);
      Define(methods, true);
      Define(decls);
      Define(ext, true);
      System.IO.File.WriteAllText(file, main_class)
      //typebuilder.Compile()
    }
  }
}