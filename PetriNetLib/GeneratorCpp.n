using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using CommonLib.Macros;
using PetriNetModel;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;
using CppParserPrinter;
using CppMacro;

namespace PetriNetLib
{
  using CommonLib.Macros.LensUtils;

  /// <summary>
  /// Description of Generator.
  /// </summary>
  partial class CppGenerator
  {
    model       : OutModel;
    proc        : PetriNetProcessor;
    converter   : Converter;
    typer       : Typer;
    typebuilder : TypeBuilder;
    mutable typing_method : MethodBuilder;
    //compiler : CompilerHost = CompilerHost();
    mutable cons_expr : list[string] = [];
    mutable fields    : list[string] = [];
    mutable init_body : list[string] = [];
    printer : Printer;
    //mutable main_class : CTree.Type;

    main_class : string
    {
      get
      {
        $<#class $Name : public $Base
            {
              ..$(fields;"\n")
            };
        #>
      }
    }
    
    public this(file : string, model : OutModel, proc : PetriNetProcessor)
    {
      this.typer = proc.Typer;
      printer = Printer(file);
      this.typebuilder = proc.Typebuilder;

      this.model = model;
      this.proc = proc;
      this.converter = proc.Converter;
    }

    Name : string
    {
      [Memoize]
      get
      {
        proc.Name
      }
    }
    
    internal GetTypeExpr(p : Colour) : string
    {
      | Colour.Simple(type) => TypeFromStr(type)
      | Integer       => "int"//cpp("type: int")
      | Unit(None())  => "Unit"//cpp("type: Unit")
      | Unit(Some(t)) => t//cpp("type: $t")
      | Product(vals) => def vals = vals.Map(TypeFromStr);
                         $<#type: tuple2<..$vals>#>//cpp(<#type: tuple2<..$vals>#>)
      | List(t, _)    => t |> TypeFromStr
                        //cpp("type: $(inner : type) *")
    }

    internal GetTypeExpr(p : ColourSet) : string
    {
      | ColourSet(n, Index)
      | ColourSet(n, Enum)          => n//cpp("type: $n")
      | ColourSet(_, Timed(p))
      | ColourSet(_, p)             => GetTypeExpr(p)
    }

    internal TypeFromStr(str : string) : string
    {
      | "string" => "char *"//cpp("type: char *")
      | "int"//    => "int"//cpp("type: int")
      | "intinf" => "int"//cpp("type: int")
      | "real"   => "float"//cpp("type: float")
      | "time"   => "int"//cpp("type: int")
      | "bool"   => "bool"//cpp("type: bool")
      | "unit"   => "Unit"//cpp("type: Unit")
      | str      => proc.colour_sets[str] |> GetTypeExpr

    }

    IsTokenExpr(expr : PExpr) : bool
    {
      | <[ $(_ : usesite) ]> => false
      | _                    => true
    }

    CreateDummyMethod() : void
    {
      def meth = typebuilder.DefineAndReturn(<[decl: TypingMethod() : void {}]>);
      typing_method = meth :> MethodBuilder;
    }

    internal static CreateArray(expr : list[PExpr]) : string
    {
      null
    }
    
    internal static GetTokenExpr(expr : PExpr) : PExpr
    {
      def loop(e)
      {
        | <[ $(count : int) ` $expr ]> => Enumerable.Repeat(expr, count).NToList()
        | <[ $left %++ $right ]>       => loop(left) + loop(right)
        | _                            => [expr]
      }

      match (expr)
      {
        | <[$_(..$_)]> as e => e
        | <[ $(_ : int)]> as e
        | <[ $(_ : long)]> as e
        | <[ $(_ : short)]> as e
        | <[ $(_ : ushort)]> as e
        | <[ $(_ : byte)]> as e
        | <[ $(_ : string)]> as e => e |> ConvExpr
        | e                 => def e = loop(e);
                               CreateArray(e)//<[array[..$e]]>
      }
    }

    CreateTranBody(tran : Transition) : CStatement
    {
      def input  = tran.InputPlaces;
      def output = tran.OutputPlaces;
      def name = tran.Name;
      //def map    = Hashtable();

      def input = input.Map((x, a) => InArcBindingCpp(x, this, tran, [], a));

      foreach (i in input)
      {
        match (i.expr)
        {
          | <[ $_(..$p) ]> => foreach (p in p)
                                {
                                  | <[ $(n : usesite)]> => match (input.Find(x => x.bind_var == n))
                                      {
                                        | Some(x) => i.Depends ::= x;
                                        | _       => ()
                                      }
                                  | _                   => ()
                                }
          | _ => ()
        }
        //map[i.name] = i;
      }

      def input    = input.Sort((x, y) => y.priority - x.priority); 
      def add_proc = output.Map((p, a) => OutArcProcess(p, tran, a));

      def extract = input.Map(_.extract_expr);
      def add_body = add_proc.Map(_.add_token);
      def code = tran.code_segment |> ConvExpr ?? "";
      def body = extract + (code :: add_body);
      def body = if (tran.guard is <[]>) body else 
                  <[ when ($(tran.guard)) {..$body}]> :: [];


      def tran_evt = if (proc.Flags.HasFlag(PetriNetFlags.Events)) $<#On$name()#> else "";
      
      def fold(x, a)
      {
        if (a == null)
        {
          if (x.check_expr.IsEmpty())
            $<#  
            $(x.bind_expr);
              ..$body
              $tran_evt
            #>
          else
          $<#  
              when ($(x.check_expr))
              {
              $(x.bind_expr);
              {..$body}
              $tran_evt
              }
          #>
        } else
        {
          if (x.check_expr.IsEmpty())
          $<#  
            $(x.bind_expr);
              $a
          #> else
          $<#  
              when ($(x.check_expr))
              {
              $(x.bind_expr);
              $a
              }
          #>
        }
      }


      //def input = eval(input, []);

      _ = input.Fold(null, fold);
      null
    }

    CreatePlace(place : Place) : string
    {
      def name = place.Name;
      //def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
      def type = GetTypeExpr(place.colour);
      def dest_cont = match (place.DestContainerType)
                       {
                         | TDestCont.MultiSet  => "multi_set"//cpp("type: multi_set")
                         | RandomEnumerable    => "random_array"//cpp("type: random_array")
                         | SortedSet           => "sorted_array"//cpp("type: sorted_array")
                         | TokenQueue          => "token_queue"//cpp("type: token_queue")
                         | TimedSimpleMultiset => "timed_heap"//cpp("type: timed_heap")
                       }
      $<#decl: $dest_cont $name;#>
      //cpp(<#decl: $(dest_cont : type) $name;#>)
      //if (place.IsTimed)
      //<[decl: $(name : usesite) : PetriNetModel.TimedPlace.[$type] = PetriNetModel.TimedPlace($(name : string), $dest_cont)]> else
      //<[decl: $(name : usesite) : PetriNetModel.Place.[$type] = PetriNetModel.Place($(name : string), $dest_cont)]>
    }


    CreateTran(tran : Transition) : string
    {
      def name = tran.Name;

      def body = CreateTranBody(tran);      
      //cpp(<#
         $<#   void $name()
               {
                 if (lock($name))
                 {
                   $body;
                   unlock();
                 }
               }
       #>//)
    }

    internal static TypeOfExpr(expr : PExpr) : string
    {
      null
    }
    
    internal ConvType(te : TExpr) : string
    {
      null
    }

    internal ConvType(te : TypeVar) : string
    {
      null
    }

    internal static ConvExpr(expr : PExpr) : string
    {
      null
    }


    internal ConvParm(expr : PParameter) : string
    {
      null
    }

    CreateGlobRef(name : string, val : PExpr) : string
    {
      def ty = Typer(typing_method);
      def te = ty.TypeExpr(val);

      def type = ConvType(te);
      def val = ConvExpr(val);
      //<[decl: mutable $(name : usesite) : $(te.ty : typed) = $val]>
      //cpp("decl: $(type : type) $name = $val;")
      $"$type $name = $val;"
    }

    CreateVals(expr : PExpr) : string
    {
      | <[ def $(name : usesite) = $val]> => 
          def type = typer.TypeExpr(val);
          def ty = type.ty;
          def type = type |> ConvType;
          def val = ConvExpr(val);
          //<[ decl: $(name : usesite) : $(ty : typed) = $val ]>
          //cpp("decl: $(type : type) $name = $val;")
          $"$type $name = $val;"
      | _ => null
    }

    ProcessFun(expr : PExpr) : PExpr
    {
      | <[ def $(n : usesite)(..$parms) { ..$body } ]> => 

            def proc_parm(p, (parm, e))
            {
              match (p)
              {
                | <[parameter: $(n : usesite) : Index.[$(type : usesite)]]> => 
                  match (model.GetIndex(type))
                  {
                    | Some((t, _)) => ($"$t $n" :: parm, $"$n = $n.num" :: e)
                    | _            => (parm, e)
                  }

              }
            }

      def expr = $"..$body";
      def (parms, expr) = parms.Fold(([], expr :: []), proc_parm);
      def parms = parms.Rev();

      $"IEnumerable[token] $n(..$parms) { ..$expr }"
    }

    CreateDecl(expr : PExpr) : string
    {
      | <[ def $(_ : usesite)(..$_) { ..$_ } ]> => 

          def func = ProcessFun(expr);
          def ty = Typer(typing_method);
          def te = ty.TypeExpr(func);
          def type = te |> ConvType;
          match (func)
          {
            | <[ def $(n : usesite)(..$parms) { ..$expr } ]> =>
                match (te)
                {
                  | TExpr.DefFunctionsIn(h :: _, _) => def ret = h.ReturnType |> ConvType;
                                                      def expr = expr.Map(ConvExpr);
                                                      def parms = parms.Map(ConvParm);
                                                      $<#$ret $n(..$parms)
                                                       {
                                                         $expr;
                                                       }#>
                                                      //<[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                      //  {
                                                      //    ..$expr
                                                      //  }]>
                }
        }
      | _ => null
    }

    CreateColourSet2(col : ColourSet) : ClassMember.TypeDeclaration
    {
      //| ColourSet(n, Colour.Index(_, _, i)) => 
      //    <[decl: [Record]
      //      class $(i : usesite) : $(n : usesite)
      //      {

      //      }
      //      ]>;
      //| _ => null    
      null
    }

    CreateColourSet(col : ColourSet) : string
    {
      | ColourSet(n, Colour.Alias(new_name))  => //def name = Macros.UseSiteSymbol(n);
                                                //def mods = AttributesAndModifiers(NemerleModifiers.Private, []);
                                                //def al = TopDeclaration.Alias(name, mods, Typarms.Empty, <[ $(new_name : usesite) ]>);
                                                //al |> ClassMember.TypeDeclaration.TypeDeclaration;
                                                // cpp("typedef $n $new_name")
          $"typedef $n $new_name;"
                                                //CTypeDecl.Decl(CTree.Decl([CSpec.Typedef()], CType.Class(n), [CDecl.Id(CName.String(new_name), None())]))
      | ColourSet(n, Colour.Record(vals))     => def fields = vals.Map((n, t) => (n, TypeFromStr(t)));
                                                def fields = fields.Map((n, t) => $"$t $n;");
                                                $<#struct $n
                                                      {
                                                        ..$fields;
                                                      };#>
                                                //<[decl: [Record] class $(n : usesite)
                                                //        {
                                                //          ..$fields
                                                //        }
                                                //]>
      //| ColourSet(n, Colour.Index(mn, mx, _i)) => def eval(m)
      //                                           {
      //                                              def expr = converter.ParseML(m);
      //                                              match (expr)
      //                                              {
      //                                                | <[$(n : int)]>  => n
      //                                                | <[$(name : usesite) ]> => 
      //                                                                     def match_var(x)
      //                                                                     {
      //                                                                       | <[ def $(n : usesite) = $_]> => n == name 
      //                                                                       | _                            => false
      //                                                                     }

      //                                                                     match (model.ml_decls.Find(match_var))
      //                                                                     {
      //                                                                       | Some(<[ def $(_ : usesite) = $(v : int)]>) => v
      //                                                                       | _                                  => throw InvalidOperationException()
      //                                                                     }
      //                                              }
      //                                           }
      //                                           def mn = mn |> eval;
      //                                           def mx = mx |> eval;

      //                                            cpp((<#decl:
      //                                                class $n : public index<$n>
      //                                                {
      //                                                  public:

      //                                                  $n(int num)
      //                                                  {
      //                                                    base($mn, $mx, num)
      //                                                  }


      //                                                };
      //                                               #>, ""))
      /*
      char *Name() {return $n;}
                                                        $(n : usesite) Create(num : int) {return $n(num)}

                                                        static $n Instance = $n(0);

                                                        static Tokens<$n> all()
                                                        {
                                                          return Instance.all_impl;
                                                        }
      */
      | ColourSet(n, Colour.Enum(vals)) => //def vals = vals.Map(x => $"$x");
                                          $<#    enum $n
                                                 {
                                                   ..$vals;
                                                 };#>
      | ColourSet(n, Colour.Timed(c))   => CreateColourSet(ColourSet(n, c))
      | _                               => null
    }    

    CreateInitMarking(place : Place) : CStatement
    {
      def combine(e1, e2)
      {
        | (<[Enumerable.Repeat($tok, $(n : int))]>, <[Enumerable.Repeat($tok2, $(n2 : int))]>) when (tok.Equals(tok2)) 
            => <[Enumerable.Repeat($tok, $(n2 + n))]>
        | (<[Enumerable.Repeat($(tok : int), $(n : int))]>, <[Enumerable.Repeat($(tok2 : int), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : int)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : string), $(n : int))]>, <[Enumerable.Repeat($(tok2 : string), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : string)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : double), $(n : int))]>, <[Enumerable.Repeat($(tok2 : double), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : double)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>       
        | _  //(<[Enumerable.Repeat($_, $(_ : int))]>, <[Enumerable.Repeat($_, $(_ : int))]>)                         
            => <[ $e1.Concat($e2)]> 
      }

      def unfold(expr)
      {
        | <[ () ]> => "Unit.Instance"
        | e        => $"$e"
      }

      def fold(expr)
      {
        //| <[ {..$e} ]>   => e.Fold(acc, fold)
        | <[ 1 ` $tok %@ $time ]>             => $"$(unfold(tok)) %@ $time"
        | <[ 1 ` $tok]>                       => $"$(unfold(tok))"
        | <[ $(n : int) ` $tok %@ $time ]>    => $"Enumerable.Repeat($(unfold(tok)) %@ $time, $n)"
        | <[ $(n : int) ` $tok]>              => $"Enumerable.Repeat($(unfold(tok)), $n)"
        | <[ $l %++ $r]>                      => $"$(combine(fold(l), fold(r)))"
        | e                                   => unfold(e)
      }

      if (place.init_mark == null) null else
      {
        def mark = fold(place.init_mark);
        def mark = if (place.IsTimed) $"$mark %@+ 0" else mark;
        def name = place.name;
        //<[ $(name : usesite).Add($mark)]>
        $"$name.Add($mark)"
      }
    }

    //CreateToString() : void
    //{
    //  def strings = model.places.Map(x => <[ $(x.name : usesite).ToString() ]>);
    //  fields ::= <[decl: public override ToString() : string 
    //  { 
    //    def str = array[..$strings];
    //    string.Join(";\n", str)
    //  }]>
    //}

    Base : string
    {
      [Memoize]
      get
      {
        if (model.IsTimed) "timed_petri_net" else "petri_net"
      }
    }
    
    CreateCons() : void
    {
      def marking = model.places.MapToList(CreateInitMarking);
      fields ::= if (model.IsTimed || model.IsHaveImmediateTransitions) 
      $<#$Name(int time_step = 15) 
      { 
        $Base(time_step);
        ..$marking;
        ..$cons_expr;
      }#>; 
      else $<#$Name(int time_step = 15) 
      { 
        ..$marking;
        ..$cons_expr;
      }#>;//<[decl: public this() { {..$marking} {..$cons_expr} }]>;
    }

    CreateTimeMethods() : void
    {
      def body = model.transitions.Where(_.IsTimed).Map(x => <[ $(x.Name : usesite)() ]>);
      def next = model.places.Where(_.IsTimed).Map(x => $"$(x.name).NextTokenDelay");

      def time_body = match (next)
                       {
                         | []    => "return 0xFFFFFFFF;"
                         | [one] => one
                         | lst   => def next = lst.Map(x => $<#expr: min = math_utils::min(min, $x); #>);
                          $<#
                                  int min = 0xFFFFFFFF;
                                  ..$(next;"\n");
                                  return min;
                              #>
                       }
      fields ::= $<#int get_next_time()
                      {
                        $time_body;
                      }#>;
      fields ::= $<#void time_step()
                      {
                        ..$body;
                      }#>
    }

    CreateStepMethod() : void
    {
      def body = model.transitions.Where(x => x.IsImmediate && !x.IsTimed).Map(x => $<#$(x.Name)()#>);
      when (!body.IsEmpty())
        fields ::= $<#Step() : void
      {
        ..$body
      }#>
    }

    CreateStartMethod() : void
    {
      //fields ::= []
      /*cpp(<#decl: void Initiate()
                      {
                        ..$init_body;
                      })*/
    }

    CreateEvents() : void
    {
      when (proc.Flags.HasFlag(PetriNetFlags.Events))
      {
        foreach (t in model.transitions)
        {
          def name = t.Name;
          def evt = $"evt_$name";
          //fields ::= $<#decl: public event $(evt : usesite) : Action#>;
          //fields ::= <[decl: $($"On$name" : usesite)() : void
          //            {
          //              $(evt : usesite)?.Invoke()
          //            } ]>;
        }
      }
    }

    public Generate() : void
    {      
      //CreateOperators();
      //assert2(false);
      def sets = model.colour_sets.Values.Map(CreateColourSet).Filter(_ != null);
      //def sets2 = model.colour_sets.Values.Map(CreateColourSet2).Filter(_ != null);
      //def sets = sets + sets2;
      foreach (m in sets) Define(m);//typebuilder.DefineNestedTypeWithSource(m).Compile();

      def places = model.places.MapToList(CreatePlace);      

      when (model.IsTimed) CreateTimeMethods();
      CreateStepMethod();

      CreateEvents();
      //CreateTranQueue();
      //CreateToString();
      CreateStartMethod();
      CreateCons();

      def members = places;
      foreach (m in members) Define(m)//_ = typebuilder.DefineWithSource(m);
    }

    Define(decl : list[string]) : void
    {
      foreach (d in decl) Define(d)
    }

    Define(decl : string) : void
    {
      fields ::= decl
      //def ty = CTree.Type.type_lens >> CComplexType.Class.decls_lens;
      //main_class = ty.Update(main_class, x => x.Append(decl));
      //(main_class.type :> CComplexType.Class).
    }


    public PhaseOne() : void
    {
      def name = proc.Name;
      
      //main_class = cpp(<#class $name : public $(bas : type)
      //                {
      //                };#>);
      //printer.
      //typebuilder.AddImplementedInterface(<[ IDisposable ]>);
      //typebuilder.AddImplementedInterface(if (model.IsTimed) <[ TimedPetriNet ]> 
      //                                    else <[PetriNet]>);
    }

    public PhaseTwo() : void
    {
      CreateDummyMethod();
      def methods = model.transitions.MapToList(CreateTran);
      def vals = model.ml_decls.Map(CreateVals).Filter(_ != null);
      Define(vals);//_ = typebuilder.DefineWithSource(m);
      def decls = model.ml_decls.Map(CreateDecl).Filter(_ != null);
      def decls = decls + methods;
      Define(decls);//_ = typebuilder.DefineWithSource(m);
      def globrefs = model.glob_refs.KeyValuePairs.MapToList(CreateGlobRef);
      Define(globrefs);//_ = typebuilder.DefineWithSource(m);
      //typebuilder.Compile()
    }
  }
}
