using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using CommonLib.Macros;
using PetriNetModel;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;
using CppParserPrinter;
using CppMacro;

namespace PetriNetLib
{
  using CommonLib.Macros.LensUtils;

  /// <summary>
  /// Description of Generator.
  /// </summary>
  partial class CppGenerator
  {
    model       : OutModel;
    proc        : PetriNetProcessor;
    converter   : Converter;
    typer       : Typer;
    typebuilder : TypeBuilder;
    gen         : Generator;
    //mutable typing_method : MethodBuilder;
    //compiler : CompilerHost = CompilerHost();
    mutable cons_expr : list[string] = [];
    mutable private_fields    : list[string] = [];
    mutable public_fields    : list[string] = [];
    mutable init_body : list[string] = [];
    file : string;
    //mutable main_class : CTree.Type;

    main_class : string
    {
      get
      {
        $<#class $Name : public $Base
            {
              ..$(private_fields;"\n")
              
              public:
                
              ..$(public_fields;"\n")
            };
        #>
      }
    }
    
    public this(file : string, gen : Generator, model : OutModel, proc : PetriNetProcessor)
    {
      this.typer = proc.Typer;
      this.file = file;
      this.gen = gen;
      this.typebuilder = proc.Typebuilder;

      this.model = model;
      this.proc = proc;
      this.converter = proc.Converter;
    }

    Name : string
    {
      [Memoize]
      get
      {
        proc.Name
      }
    }
    
    internal GetTypeExpr(p : Colour) : string
    {
      | Colour.Simple(type) => TypeFromStr(type)
      | Integer       => "int"//cpp("type: int")
      | Unit(None())  => "unit"//cpp("type: Unit")
      | Unit(Some(t)) => t//cpp("type: $t")
      | Product(vals) => def vals = vals.Map(TypeFromStr);
                         $<#type: tuple2<..$vals>#>//cpp(<#type: tuple2<..$vals>#>)
      | List(t, _)    => t |> TypeFromStr
                        //cpp("type: $(inner : type) *")
    }

    internal GetTypeExpr(p : ColourSet) : string
    {
      | ColourSet(n, Index)
      | ColourSet(n, Enum)          => n//cpp("type: $n")
      | ColourSet(_, Timed(p))
      | ColourSet(_, p)             => GetTypeExpr(p)
    }

    internal TypeFromStr(str : string) : string
    {
      | "string" => "char *"//cpp("type: char *")
      | "int"//    => "int"//cpp("type: int")
      | "intinf" => "int"//cpp("type: int")
      | "real"   => "float"//cpp("type: float")
      | "time"   => "int"//cpp("type: int")
      | "bool"   => "bool"//cpp("type: bool")
      | "unit"   => "unit"//cpp("type: Unit")
      | str      => proc.colour_sets[str] |> GetTypeExpr

    }

    IsTokenExpr(expr : PExpr) : bool
    {
      | <[ $(_ : usesite) ]> => false
      | _                    => true
    }

    //CreateDummyMethod() : void
    //{
    //  def meth = typebuilder.DefineAndReturn(<[decl: TypingMethod() : void {}]>);
    //  typing_method = meth :> MethodBuilder;
    //}

    internal static CreateArray(expr : list[PExpr]) : string
    {
      def expr = expr.Map(ConvExpr(_, false));
      $<#{..$(expr; ",")}#>
    }
    
    internal static GetTokenExpr(expr : PExpr) : string
    {
      def loop(e)
      {
        | <[ $(count : int) ` $expr ]> => Enumerable.Repeat(expr, count).NToList()
        | <[ $left %++ $right ]>       => loop(left) + loop(right)
        | _                            => [expr]
      }

      match (expr)
      {
        | <[$_(..$_)]> as e       => e |> ConvExpr(_, true)
        | <[ $(_ : int)]> as e
        | <[ $(_ : long)]> as e
        | <[ $(_ : short)]> as e
        | <[ $(_ : ushort)]> as e
        | <[ $(_ : byte)]> as e
        | <[ $(_ : string)]> as e => e |> ConvExpr(_, true)
        | e                       => def e = loop(e);
                                     CreateArray(e)//<[array[..$e]]>
      }
    }

    CreateTranBody(tran : Transition) : string
    {
      def input  = tran.InputPlaces;
      def output = tran.OutputPlaces;
      def name   = tran.Name;
      //def map    = Hashtable();

      def input = input.Map((x, a) => InArcBindingCpp(x, this, tran, [], a));

      foreach (i in input)
      {
        match (i.expr)
        {
          | <[ $_(..$p) ]> => foreach (p in p)
                                {
                                  | <[ $(n : usesite)]> => match (input.Find(x => x.bind_var == n))
                                      {
                                        | Some(x) => i.Depends ::= x;
                                        | _       => ()
                                      }
                                  | _                   => ()
                                }
          | _ => ()
        }
        //map[i.name] = i;
      }

      def input    = input.Sort((x, y) => y.priority - x.priority); 
      def add_proc = output.Map((p, a) => OutArcProcessCpp(p, tran, a));

      def extract = input.Map(_.extract_expr);
      def add_body = add_proc.Map(_.add_token);
      def code = tran.code_segment |> ConvExpr(_, true) ?? "";
      def body = extract + (code :: add_body);
      def body = if (tran.guard is <[]>) body else 
                {
                  def guard = tran.guard |> ConvExpr(_, false);
                  $<#if ($guard) 
                  {
                    ..$(body;"\n")
                  }#> :: [];
                }

      def tran_evt = if (proc.Flags.HasFlag(PetriNetFlags.Events)) $<#On$name()#> else "";
      
      def fold(x, a)
      {
        if (a : object == null)
        {
          if (x.check_expr.IsEmpty())
            $<#  
              $(x.bind_expr)
              ..$(body;"\n")
              $tran_evt
            #>
          else
          $<#  
              if ($(x.check_expr))
              {
                $(x.bind_expr)
                ..$(body; "\n")
                $tran_evt
              }
          #>
        } else
        {
          if (x.check_expr.IsEmpty())
          $<#  
              $(x.bind_expr)
              $a
          #> else
          $<#  
              if ($(x.check_expr))
              {
                $(x.bind_expr)
                $a
              }
          #>
        }
      }


      //def input = eval(input, []);

      input.Fold(null, fold)
    }

    CreatePlace(place : Place) : string
    {
      def name = place.Name;
      //def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
      def type = GetTypeExpr(place.colour);
      def dest_cont = match (place.DestContainerType)
                       {
                         | TDestCont.MultiSet  => "multi_set"//cpp("type: multi_set")
                         | RandomEnumerable    => "random_array"//cpp("type: random_array")
                         | SortedSet           => "sorted_array"//cpp("type: sorted_array")
                         | TokenQueue          => "token_queue"//cpp("type: token_queue")
                         | TimedSimpleMultiset => "timed_heap"//cpp("type: timed_heap")
                       }
      $<#$dest_cont $name;#>
      //cpp(<#decl: $(dest_cont : type) $name;#>)
      //if (place.IsTimed)
      //<[decl: $(name : usesite) : PetriNetModel.TimedPlace.[$type] = PetriNetModel.TimedPlace($(name : string), $dest_cont)]> else
      //<[decl: $(name : usesite) : PetriNetModel.Place.[$type] = PetriNetModel.Place($(name : string), $dest_cont)]>
    }


    CreateTran(tran : Transition) : string
    {
      def name = tran.Name;

      def body = CreateTranBody(tran);      
      //cpp(<#
        $<#void $name()
            {
              if (lock($name))
              {
                $body;
                unlock();
              }
            }
          #>//)
    }

    internal TypeOfVar(name : string) : string
    {
      match (model.vars.Find(x => x.Key == name))
      {
        | Some(x) => def col = x.Value;
                     GetTypeExpr(col)
        | _       => ""
      }
    }
    
    internal ConvType(te : TExpr) : string
    {
      te.Type.ToString()
    }

    internal ConvType(te : TypeVar) : string
    {
      def ty = te.ToString().TrimEnd('-', '+');
      def enum_ty = typer.BindType(<[ System.Collections.Generic.IEnumerable[_] ]>);
      if (te.TryRequire(enum_ty))
      {
        def ty = te.Fix() :> FixedType.Class;
        //def args = ty.args;
        //def args = args.Map(ConvType);
        <#token_iter#>
      } else
      {
        ty
      }
    }

    internal static ConvExpr(expr : PExpr, statement : bool = false) : string
    {
      match (expr)
      {
        | <[ {..$seq} ]> when (statement) => match (seq)
                                             {
                                               | [e] => ConvExpr(e, true)
                                               | seq => 
                                                        def seq = seq.Map(ConvExpr(_, true));
                                                        $<#..$(seq;";\n")#>
                                            }
        | <[ $n ` $t]>          => $<#token_iter_utils.repeat($(ConvExpr(t)), $(ConvExpr(n)))#>
        | <[ $a %++ $b]>        => $<#token_iter_utils.concat($(ConvExpr(a)), $(ConvExpr(b)))#>
        | <[]>                  => ""
        | <[ $a != $b]>         => $<#$(ConvExpr(a)) != $(ConvExpr(b))#>
        | <[ $a == $b]>         => $<#$(ConvExpr(a)) == $(ConvExpr(b))#>
        | <[ $a + $b]>          => $<#$(ConvExpr(a)) + $(ConvExpr(b))#>
        | <[ $a * $b]>          => $<#$(ConvExpr(a)) * $(ConvExpr(b))#>
        | <[ $(n : usesite)]>   => $<#$n#>
        | <[ Enumerable.Repeat($tok, $n) ]> => $<#token_iter_utils.repeat($(ConvExpr(tok)), $(ConvExpr(n)))#>
        | <[ $(e1).Concat($e2) ]> => $<#token_iter_utils.concat($(ConvExpr(e1)), $(ConvExpr(e2))#>
        | <[ $func(..$parms) ]> => def parms = parms.Map(ConvExpr(_, false));
                                   $<#$func(..$(parms; ","))#>
        | <[ $(_ : int)]> as e
        | <[ $(_ : long)]> as e
        | <[ $(_ : short)]> as e
        | <[ $(_ : ushort)]> as e
        | <[ $(_ : byte)]> as e => $<#$e#>
        | <[ $(n : string)]>    => $<#$n#>
        | <[ (..$e) ]>          => match (e)
                                   {
                                     | [e]                  => ConvExpr(e)
                                     | [e1, e2]             => $<#tuple2($(ConvExpr(e1)), $(ConvExpr(e2)))#>
                                     | [e1, e2, e3]         => $<#tuple3($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)))#>
                                     | [e1, e2, e3, e4]     => $<#tuple4($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)), $(ConvExpr(e4)))#>
                                     | [e1, e2, e3, e4, e5] => $<#tuple5($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)), $(ConvExpr(e4)), $(ConvExpr(e5)))#>
                                   }
        | <[ if ($a) $b else $c]> when statement => $<#if ($(ConvExpr(a))) $(ConvExpr(b)) else $(ConvExpr(c))#>
        | <[ if ($a) $b else $c]> when !statement => $<#$(ConvExpr(a)) ? $(ConvExpr(b)) : $(ConvExpr(c))#>
        | <[ array[..$val] ]>   => CreateArray(val)
      }
    }

    internal ConvParm(expr : PParameter) : string
    {
      def deflt = expr.DefaultValue.Map(x => $" = $(ConvExpr(x, false))").WithDefault("");
      $<#$(expr.Type) $(expr.Name)$deflt#>;
    }

    CreateGlobRef(name : string, val : PExpr) : string
    {
      def ty = Typer(gen.TypingMethod);
      def te = ty.TypeExpr(val);

      def type = ConvType(te);
      def val = ConvExpr(val, true);
      //<[decl: mutable $(name : usesite) : $(te.ty : typed) = $val]>
      //cpp("decl: $(type : type) $name = $val;")
      $"$type $name = $val;"
    }

    CreateVals(expr : PExpr) : string
    {
      | <[ def $(name : usesite) = $val]> => 
          def type = typer.TypeExpr(val);
          //def ty = type.ty;
          def type = type |> ConvType;
          def val = ConvExpr(val, false);
          //<[ decl: $(name : usesite) : $(ty : typed) = $val ]>
          //cpp("decl: $(type : type) $name = $val;")
          $"$type $name = $val;"
      | _ => null
    }

    ProcessFun(expr : PExpr) : PExpr
    {
      | <[ def $(n : usesite)(..$parms) { ..$body } ]> => 
      
            def proc_parm(p, (parm, e))
            {
              match (p)
              {
                | <[parameter: $(n : usesite) : Index.[$(type : usesite)]]> => 
                  match (model.GetIndex(type))
                  {
                    | Some((t, _)) => (<[parameter: $(n : usesite) : $(t : usesite)]> :: parm, e)
                    | _            => (parm, e)
                  }
                  
              }
            }
      
      def expr = <[ {..$body} ]>;
      def (parms, expr) = parms.Fold(([], expr :: []), proc_parm);
      def parms = parms.Rev();
          
      <[ def $(n : usesite)(..$parms) { ..$expr } ]>
    }

    CreateDecl(expr : PExpr) : string
    {
      | <[ def $(_ : usesite)(..$_) { ..$_ } ]> => 

          def func = ProcessFun(expr);
          def ty = Typer(gen.TypingMethod);
          def te = ty.TypeExpr(func);
          //def type = te |> ConvType;
          match (func)
          {
            | <[ def $(n : usesite)(..$parms) { ..$expr } ]> =>
                match (te)
                {
                  | TExpr.DefFunctionsIn(h :: _, _) => def ret = h.ReturnType |> ConvType;
                                                      def expr = expr.Map(ConvExpr(_, true));
                                                      def parms = parms.Map(ConvParm);
                                                      $<#$ret $n(..$(parms; ","))
                                                       {
                                                         $expr;
                                                       }#>
                                                      //<[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                      //  {
                                                      //    ..$expr
                                                      //  }]>
                }
        }
      | _ => null
    }

    CreateColourSet2(col : ColourSet) : ClassMember.TypeDeclaration
    {
      //| ColourSet(n, Colour.Index(_, _, i)) => 
      //    <[decl: [Record]
      //      class $(i : usesite) : $(n : usesite)
      //      {

      //      }
      //      ]>;
      //| _ => null    
      null
    }

    CreateColourSet(col : ColourSet) : string
    {
      | ColourSet(n, Colour.Alias(new_name))  => //def name = Macros.UseSiteSymbol(n);
                                                //def mods = AttributesAndModifiers(NemerleModifiers.Private, []);
                                                //def al = TopDeclaration.Alias(name, mods, Typarms.Empty, <[ $(new_name : usesite) ]>);
                                                //al |> ClassMember.TypeDeclaration.TypeDeclaration;
                                                // cpp("typedef $n $new_name")
          $"typedef $n $new_name;"
                                                //CTypeDecl.Decl(CTree.Decl([CSpec.Typedef()], CType.Class(n), [CDecl.Id(CName.String(new_name), None())]))
      | ColourSet(n, Colour.Record(vals))     => def fields = vals.Map((n, t) => (n, TypeFromStr(t)));
                                                def fields = fields.Map((n, t) => $"$t $n;");
                                                $<#struct $n
                                                      {
                                                        ..$(fields;"\n")
                                                      };#>
                                                //<[decl: [Record] class $(n : usesite)
                                                //        {
                                                //          ..$fields
                                                //        }
                                                //]>
      //| ColourSet(n, Colour.Index(mn, mx, _i)) => def eval(m)
      //                                           {
      //                                              def expr = converter.ParseML(m);
      //                                              match (expr)
      //                                              {
      //                                                | <[$(n : int)]>  => n
      //                                                | <[$(name : usesite) ]> => 
      //                                                                     def match_var(x)
      //                                                                     {
      //                                                                       | <[ def $(n : usesite) = $_]> => n == name 
      //                                                                       | _                            => false
      //                                                                     }

      //                                                                     match (model.ml_decls.Find(match_var))
      //                                                                     {
      //                                                                       | Some(<[ def $(_ : usesite) = $(v : int)]>) => v
      //                                                                       | _                                  => throw InvalidOperationException()
      //                                                                     }
      //                                              }
      //                                           }
      //                                           def mn = mn |> eval;
      //                                           def mx = mx |> eval;

      //                                            cpp((<#decl:
      //                                                class $n : public index<$n>
      //                                                {
      //                                                  public:

      //                                                  $n(int num)
      //                                                  {
      //                                                    base($mn, $mx, num)
      //                                                  }


      //                                                };
      //                                               #>, ""))
      /*
      char *Name() {return $n;}
                                                        $(n : usesite) Create(num : int) {return $n(num)}

                                                        static $n Instance = $n(0);

                                                        static Tokens<$n> all()
                                                        {
                                                          return Instance.all_impl;
                                                        }
      */
      | ColourSet(n, Colour.Enum(vals)) => //def vals = vals.Map(x => $"$x");
                                          $<#    enum $n
                                                 {
                                                   ..$vals;
                                                 };#>
      | ColourSet(n, Colour.Timed(c))   => CreateColourSet(ColourSet(n, c))
      | _                               => null
    }    

    CreateInitMarking(place : Place) : string
    {
      def combine(e1, e2)
      {
        | (<[Enumerable.Repeat($tok, $(n : int))]>, <[Enumerable.Repeat($tok2, $(n2 : int))]>) when (tok.Equals(tok2)) 
            => <[Enumerable.Repeat($tok, $(n2 + n))]>
        | (<[Enumerable.Repeat($(tok : int), $(n : int))]>, <[Enumerable.Repeat($(tok2 : int), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : int)]>).ToArray();
               if (val.Length > 50) <[ $(e1).Concat($e2)]> else
               <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : string), $(n : int))]>, <[Enumerable.Repeat($(tok2 : string), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : string)]>).ToArray();
               if (val.Length > 50) <[ $(e1).Concat($e2)]> else
               <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : double), $(n : int))]>, <[Enumerable.Repeat($(tok2 : double), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : double)]>).ToArray();
               if (val.Length > 50) <[ $(e1).Concat($e2)]> else
               <[ array[..$val] ]>       
        | _  //(<[Enumerable.Repeat($_, $(_ : int))]>, <[Enumerable.Repeat($_, $(_ : int))]>)                         
            => <[ $e1.Concat($e2)]> 
      }
      
      def unfold(expr)
      {
        | <[ () ]> => <[unit.instance()]>
        | e        => e
      }

      def fold(expr) : PExpr
      {
        //| <[ {..$e} ]>   => e.Fold(acc, fold)
        | <[ 1 ` $tok %@ $time ]>             => def time = time |> ConvExpr(_, false);
                                                 def tok = unfold(tok);
                                                 <[at_time($tok, $time)]>
        | <[ 1 ` $tok]>                       => <[$(unfold(tok))]>
        | <[ $(n : int) ` $tok %@ $time ]>    => <[IEnumerable.Repeat(at_time($(unfold(tok)), $time), $n)]>
        | <[ $(n : int) ` $tok]>              => <[IEnumerable.Repeat($(unfold(tok)), $n)]>
        | <[ $l %++ $r]>                      => <[$(combine(fold(l), fold(r)))]>
        | e                                   => unfold(e)
      }

      if (place.init_mark == null) null else
      {
        def mark = fold(place.init_mark);
        def mark = mark |> ConvExpr(_, false);
        def mark = if (place.IsTimed) $"add_time($mark, 0);" else mark;
        def name = place.name;
        //<[ $(name : usesite).Add($mark)]>
        $"$name.add($mark);"
      }
    }

    //CreateToString() : void
    //{
    //  def strings = model.places.Map(x => <[ $(x.name : usesite).ToString() ]>);
    //  fields ::= <[decl: public override ToString() : string 
    //  { 
    //    def str = array[..$strings];
    //    string.Join(";\n", str)
    //  }]>
    //}

    Base : string
    {
      [Memoize]
      get
      {
        if (model.IsTimed) "timed_petri_net" else "petri_net"
      }
    }
    
    CreateCons() : void
    {
      def marking = model.places.MapToList(CreateInitMarking).Filter(_ != null);
      public_fields ::= if (model.IsTimed || model.IsHaveImmediateTransitions) 
      $<#$Name(int time_step = 15) 
      { 
        $Base(time_step);
        ..$(marking;"\n")
        ..$(cons_expr;"\n")
      }#>; 
      else $<#$Name(int time_step = 15) 
      { 
        ..$(marking;"\n")
        ..$(cons_expr;"\n")
      }#>;//<[decl: public this() { {..$marking} {..$cons_expr} }]>;
    }

    CreateTimeMethods() : void
    {
      def body = model.transitions.Where(_.IsTimed).Map(x => <[ $(x.Name : usesite)() ]>);
      def next = model.places.Where(_.IsTimed).Map(x => $"$(x.name).NextTokenDelay");

      def time_body = match (next)
                       {
                         | []    => "return 0xFFFFFFFF;"
                         | [one] => one
                         | lst   => def next = lst.Map(x => $<#expr: min = math_utils::min(min, $x); #>);
                          $<#
                                  int min = 0xFFFFFFFF;
                                  ..$(next;"\n");
                                  return min;
                              #>
                       }
      private_fields ::= $<#int get_next_time()
                      {
                        $time_body;
                      }#>;
      private_fields ::= $<#void time_step()
                      {
                        ..$body;
                      }#>
    }

    CreateStepMethod() : void
    {
      def body = model.transitions.Where(x => x.IsImmediate && !x.IsTimed).Map(x => $<#$(x.Name)()#>);
      when (!body.IsEmpty())
        public_fields ::= $<#void step()
      {
        ..$(body; "\n")
      }#>
    }

    CreateStartMethod() : void
    {
      //fields ::= []
      /*cpp(<#decl: void Initiate()
                      {
                        ..$init_body;
                      })*/
    }

    CreateEvents() : void
    {
      when (proc.Flags.HasFlag(PetriNetFlags.Events))
      {
        foreach (t in model.transitions)
        {
          def name = t.Name;
          def evt = $"evt_$name";
          //fields ::= $<#decl: public event $(evt : usesite) : Action#>;
          //fields ::= <[decl: $($"On$name" : usesite)() : void
          //            {
          //              $(evt : usesite)?.Invoke()
          //            } ]>;
        }
      }
    }

    public Generate() : void
    {      
      //CreateOperators();
      //assert2(false);
      def sets = model.colour_sets.Values.Map(CreateColourSet).Filter(_ != null);
      //def sets2 = model.colour_sets.Values.Map(CreateColourSet2).Filter(_ != null);
      //def sets = sets + sets2;
      foreach (m in sets) Define(m);//typebuilder.DefineNestedTypeWithSource(m).Compile();

      def places = model.places.MapToList(CreatePlace);      

      when (model.IsTimed) CreateTimeMethods();
      CreateStepMethod();

      CreateEvents();
      //CreateTranQueue();
      //CreateToString();
      CreateStartMethod();
      CreateCons();

      def members = places;
      foreach (m in members) Define(m)//_ = typebuilder.DefineWithSource(m);
    }

    Define(decl : list[string], pub : bool = false) : void
    {
      if (pub)
        foreach (d in decl) public_fields ::= d; else
        foreach (d in decl) private_fields ::= d;
        
    }

    Define(decl : string) : void
    {
      private_fields ::= decl
      //def ty = CTree.Type.type_lens >> CComplexType.Class.decls_lens;
      //main_class = ty.Update(main_class, x => x.Append(decl));
      //(main_class.type :> CComplexType.Class).
    }


    public PhaseOne() : void
    {
      //def name = proc.Name;
      
      //main_class = cpp(<#class $name : public $(bas : type)
      //                {
      //                };#>);
      //printer.
      //typebuilder.AddImplementedInterface(<[ IDisposable ]>);
      //typebuilder.AddImplementedInterface(if (model.IsTimed) <[ TimedPetriNet ]> 
      //                                    else <[PetriNet]>);
    }

    public PhaseTwo() : void
    {
      //CreateDummyMethod();
      def methods = model.transitions.MapToList(CreateTran);
      def vals = model.ml_decls.Map(CreateVals).Filter(_ != null);
      Define(vals);//_ = typebuilder.DefineWithSource(m);
      def decls = model.ml_decls.Map(CreateDecl).Filter(_ != null);
      Define(methods, true);
      Define(decls);//_ = typebuilder.DefineWithSource(m);
      def globrefs = model.glob_refs.KeyValuePairs.MapToList(CreateGlobRef);
      Define(globrefs);//_ = typebuilder.DefineWithSource(m);
      System.IO.File.WriteAllText(file, main_class)
      //typebuilder.Compile()
    }
  }
}
