using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Builtins;
using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using CommonLib.Macros;
using PetriNetModel;
using System.Reactive.Linq;
using System.Threading;
using System.Threading.Tasks;
using CppParserPrinter;
using CppMacro;

namespace PetriNetLib
{
  using CommonLib.Macros.LensUtils;

  /*
  - то их можно запаковать в слово или несколько слов переходы и позиции, наличие токенов и разрешенность
    создается переменная places в которой бит показывает одной позиции наличие токена
    создается переменная ena в которой каждый бит означает включенность перехода 
    при добавлении токена бит устанавливается в places в 1
    при удалении токена проверяется на пустоту и если пусто то сбрасывается в 0
    бит ena = 1 в битах позиций, например ena = places & (A|B) == (A|B) << 16
    биты из разрешенных переходов быстро определяется первый установленный и его позиция и
  */
  /// <summary>
  /// Description of Generator.
  /// </summary>
  partial class CppGenerator
  {
    model       : OutModel;
    proc        : PetriNetProcessor;
    converter   : Converter;
    typer       : Typer;
    typebuilder : TypeBuilder;
    gen         : Generator;
    //mutable typing_method : MethodBuilder;
    //compiler : CompilerHost = CompilerHost();
    mutable cons_expr : list[string] = [];
    mutable private_fields    : list[string] = [];
    mutable public_fields    : list[string] = [];
    mutable init_body : list[string] = [];
    file : string;
    //mutable main_class : CTree.Type;

    main_class : string
    {
      get
      {
        $<#class $Name : public $Base
            {
              ..$(private_fields;"\n")

              public:

              ..$(public_fields;"\n")
            };
        #>
      }
    }

    public this(file : string, gen : Generator, model : OutModel, proc : PetriNetProcessor)
    {
      this.typer = proc.Typer;
      this.file = file;
      this.gen = gen;
      this.typebuilder = proc.Typebuilder;

      this.model = model;
      this.proc = proc;
      this.converter = proc.Converter;
    }

    Name : string
    {
      [Memoize]
      get
      {
        proc.Name
      }
    }

    internal GetTypeExpr(p : Colour) : string
    {
      | Colour.Alias(type)
      | Colour.Simple(type) => TypeFromStr(type)
      | Integer       => "int"//cpp("type: int")
      | Unit(None())  => "char"//cpp("type: Unit")
      | Unit(Some(t)) => t//cpp("type: $t")
      //| Product(vals) => def vals = vals.Map(TypeFromStr);
      //                  $<#type: tuple2<..$vals>#>//cpp(<#type: tuple2<..$vals>#>)
      | List(t, r)    => match (t)
                         {
                           | "INT"
                           | "SHORT"
                           | "USHORT"
                           | "BYTE"   => if (r is Some((mn, mx))) 
                                         {
                                           def diff = mx - mn;
                                           $"bytes$diff" 
                                         } else "bytesn"
                         }
                        //cpp("type: $(inner : type) *")
    }

    internal GetTypeExpr(p : ColourSet) : string
    {
      | ColourSet(n, Alias)
      | ColourSet(n, Index)
      | ColourSet(n, Record)
      | ColourSet(n, Product)
      | ColourSet(n, Enum)          => n//cpp("type: $n")
      | ColourSet(_, Timed(p))
      | ColourSet(_, p)             => GetTypeExpr(p)
    }

    internal TypeFromStr(str : string) : string
    {
      | "string" => "char *"//cpp("type: char *")
      | "int"    => "int"//cpp("type: int")
      | "intinf" => "long long"//cpp("type: int")
      | "real"   => "float"//cpp("type: float")
      | "time"   => "int"//cpp("type: int")
      | "bool"   => "bool"//cpp("type: bool")
      | "unit"   => "char"//cpp("type: Unit")
      | str      => proc.colour_sets[str] |> GetTypeExpr

    }

    IsTokenExpr(expr : PExpr) : bool
    {
      | <[ $(_ : usesite) ]> => false
      | _                    => true
    }

    //CreateDummyMethod() : void
    //{
    //  def meth = typebuilder.DefineAndReturn(<[decl: TypingMethod() : void {}]>);
    //  typing_method = meth :> MethodBuilder;
    //}

    mutable ctx : list[string];
    
    internal CreateArray(expr : list[PExpr]) : string
    {
      def ty = Typer(gen.TypingMethod);
      def te = ty.TypeExpr(<[ [..$expr] ]>);
      def ty = te.ty;
      def len = expr.Length;
      def (type, n, ty) = match (ty)
      {
        | FixedType.Class(_, [args]) => def byte = typer.BindType(<[ byte ]>);
                                        if (args.TryRequire(byte))
                                        {
                                          
                                          if (len <= 10)
                                          {
                                            ($"byte$len", false, "u8")
                                          } else
                                          {
                                            ("byten", true, "u8")
                                          }
                                        } else (null, false, null)
                                        //if (args.TryRequire(integer))
                                        //{
                                        //} else
                                        //if (args.TryRequire(uinteger))
                                        //{
                                        //} else
                                        //if (args.TryRequire(longint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(ulongint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(shortint))
                                        //{
                                        //} else
                                        //if (args.TryRequire(ushortint))
                                        //{
                                        //}
      }
      //mutable lst = [];
      def expr = expr.Map(ConvExpr(_, false));
      //{..$(expr; ",")}
      def var = Macros.NewSymbol();
      if (n)
      {
        ctx ::= $<#$ty $var[] = {..$(expr;", ")};#>;
        $<#$type($var, $len)#>
      } else
      {
        ctx ::= $<#$ty $var[] = {..$(expr;", ")};#>;
        $<#$type($var)#>
      }
    }

    internal GetTokenExpr(expr : PExpr) : string
    {
      def loop(e)
      {
        | <[ $(count : int) ` $expr ]> => Enumerable.Repeat(expr, count).NToList()
        | <[ $left %++ $right ]>       => loop(left) + loop(right)
        | _                            => [expr]
      }

      match (expr)
      {
        | <[$_(..$_)]> as e       => e |> ConvExpr(_, true)
        | <[ $(_ : int)]> as e
        | <[ $(_ : long)]> as e
        | <[ $(_ : short)]> as e
        | <[ $(_ : ushort)]> as e
        | <[ $(_ : byte)]> as e
        | <[ $(_ : string)]> as e => e |> ConvExpr(_, true)
        | e                       => def e = loop(e);
                                    CreateArray(e)//<[array[..$e]]>
      }
    }

    CreateTranBody(tran : Transition) : string
    {
      def input  = tran.InputPlaces;
      def output = tran.OutputPlaces;
      def name   = tran.Name;
      //def map    = Hashtable();

      def input = input.Map((x, a) => InArcBindingCpp(x, this, tran, [], a));

      foreach (i in input)
      {
        match (i.expr)
        {
          | <[ $_(..$p) ]> => foreach (p in p)
                                {
                                  | <[ $(n : usesite)]> => match (input.Find(x => x.bind_var == n))
                                      {
                                        | Some(x) => i.Depends ::= x;
                                        | _       => ()
                                      }
                                  | _                   => ()
                                }
          | _ => ()
        }
        //map[i.name] = i;
      }

      def input    = input.Sort((x, y) => y.priority - x.priority); 
      def add_proc = output.Map((p, a) => OutArcProcessCpp(p, tran, a, this));

      def extract = input.Map(_.extract_expr);
      def add_body = add_proc.Map(_.add_token);
      def code = tran.code_segment |> ConvExpr(_, true) ?? "";
      def body = extract + (code :: add_body);
      def body = if (tran.guard is <[]>) body else 
                  {
                    def guard = tran.guard |> ConvExpr(_, false);
                  $<#if ($guard) 
                  {
                    ..$(body;"\n")
                  }#> :: [];
                  }

      def tran_evt = if (proc.Flags.HasFlag(PetriNetFlags.Events)) $<#On$name()#> else "";

      def fold(x, a)
      {
        if (a : object == null)
        {
          if (x.check_expr.IsEmpty())
            $<#  
              $(x.bind_expr)
              ..$(body;"\n")
              $tran_evt
            #>
          else
          $<#  
              if ($(x.check_expr))
              {
                $(x.bind_expr)
                ..$(body; "\n")
                $tran_evt
              }
          #>
        } else
        {
          if (x.check_expr.IsEmpty())
          $<#  
              $(x.bind_expr)
              $a
              #>
          else
          $<#  
              if ($(x.check_expr))
              {
                $(x.bind_expr)
                $a
              }
          #>
        }
      }


      //def input = eval(input, []);

      input.Fold(null, fold)
    }

    CreatePlace(place : Place) : string
    {
      def name = place.Name;
      //def name = name.Replace(" ", "").Replace("\n", "").Replace("\r", "");
      def type = GetTypeExpr(place.colour);
      def dest_cont = match (place.DestContainerType)
                       {
                         | TDestCont.MultiSet  => "multi_set"//cpp("type: multi_set")
                         | RandomEnumerable    => "random_array"//cpp("type: random_array")
                         | SortedSet           => "sorted_array"//cpp("type: sorted_array")
                         | TokenQueue          => "token_queue"//cpp("type: token_queue")
                         | TimedSimpleMultiset => "timed_heap"//cpp("type: timed_heap")
                       }
      $<#$dest_cont $name;#>
      //cpp(<#decl: $(dest_cont : type) $name;#>)
      //if (place.IsTimed)
      //<[decl: $(name : usesite) : PetriNetModel.TimedPlace.[$type] = PetriNetModel.TimedPlace($(name : string), $dest_cont)]> else
      //<[decl: $(name : usesite) : PetriNetModel.Place.[$type] = PetriNetModel.Place($(name : string), $dest_cont)]>
    }


    CreateTran(tran : Transition) : string
    {
      def name = tran.Name;

      def body = CreateTranBody(tran);      
      //cpp(<#
        $<#void $name()
            {
              if (lock($name))
              {
                $body;
                unlock();
              }
            }
          #>//)
    }

    internal TypeOfVar(name : string) : string
    {
      match (model.vars.Find(x => x.Key == name))
      {
        | Some(x) => def col = x.Value;
                    GetTypeExpr(col)
        | _       => ""
      }
    }

    FinalType(str : string) : string
    {
      match (str.Trim())
      {
        | "BYTES" => "bytesn"
        | t       => t
      }
    }
    
    internal ConvType(te : TExpr) : string
    {
      te.Type.ToString()
    }

    internal ConvType(te : TypeVar) : string
    {
      def tystr = te.ToString().TrimEnd('-', '+');
      //def enum_ty = typer.BindType(<[ System.Collections.Generic.IEnumerable[_] ]>);
      def list_ty = typer.BindType(<[ list[_] ]>);
      def ty = te.Fix();
      if (te.TryRequire(list_ty))
      {
        def ty = ty :> FixedType.Class;
        //def args = ty.args;
        //def args = args.Map(ConvType);
        //<#token_iter#>
        def t = ty.args.Map(ConvType).First();
        <#bytesn#>
      } else
      match (ty)
      {
        | FixedType.Tuple(args) => def vals = args.Map(ConvType);
                                   def n = vals.Length;
                                   $<#tuple$n<..$(vals;",")>#>
        | _                     => tystr
      }
    }

    internal ConvExpr(expr : PExpr, statement : bool = false) : string
    {
      when (statement) ctx = [];
      match (expr)
      {
        | <[ {$seq} ]>                    => ConvExpr(seq, true)
        | <[ {..$seq} ]> when (statement) => match (seq)
            {
              | []  => ""
              | seq => def seq = seq.Map(ConvExpr(_, true));
                                                        $<#..$(seq;";\n")#>
            }
        | <[ $n ` $t]>          => $<#token_iter_utils.repeat($(ConvExpr(t)), $(ConvExpr(n)))#>
        | <[ $a %++ $b]>        => $<#token_iter_utils.concat($(ConvExpr(a)), $(ConvExpr(b)))#>
        | <[]>                  => ""
        | <[ $a != $b]>         => $<#$(ConvExpr(a)) != $(ConvExpr(b))#>
        | <[ $a == $b]>         => $<#$(ConvExpr(a)) == $(ConvExpr(b))#>
        | <[ $a + $b]>          => $<#$(ConvExpr(a)) + $(ConvExpr(b))#>
        | <[ $a * $b]>          => $<#$(ConvExpr(a)) * $(ConvExpr(b))#>
        | <[ $(n : usesite)]>   => $<#$n#>
        | <[ Enumerable.Repeat($tok, $n) ]> => $<#token_iter_utils.repeat($(ConvExpr(tok)), $(ConvExpr(n)))#>
        | <[ $(e1).Concat($e2) ]> => $<#token_iter_utils.concat($(ConvExpr(e1)), $(ConvExpr(e2))#>
        //| <[ $func(..$parms) ]> when (parms.All(x => x is PExpr.Assign)) =>


        | <[ $func(..$parms) ]> => if (parms.All(x => x is PExpr.Assign)) 
                                   {
                                     def get_rec_parm(x)
                                     {
                                       | <[$_ = $v]> => v |> ConvExpr(_, false)
                                     }

                                     def parms = parms.Map(get_rec_parm);
                                     $<#$func(..$(parms; ","))#>
                                   } else
                                   {
                                     def parms = parms.Map(ConvExpr(_, false));
                                     $<#$func(..$(parms; ","))#>
                                   }
        | <[ $(_ : int)]> as e
        | <[ $(_ : long)]> as e
        | <[ $(_ : short)]> as e
        | <[ $(_ : ushort)]> as e
        | <[ $(_ : byte)]> as e => $<#$e#>
        | <[ $(n : string)]>    => $<#$n#>
        | <[ (..$e) ]>          => match (e)
            {
              | [e]                  => ConvExpr(e)
              | [e1, e2]             => $<#tuple2($(ConvExpr(e1)), $(ConvExpr(e2)))#>
              | [e1, e2, e3]         => $<#tuple3($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)))#>
              | [e1, e2, e3, e4]     => $<#tuple4($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)), $(ConvExpr(e4)))#>
              | [e1, e2, e3, e4, e5] => $<#tuple5($(ConvExpr(e1)), $(ConvExpr(e2)), $(ConvExpr(e3)), $(ConvExpr(e4)), $(ConvExpr(e5)))#>
            }
           
        | <[()]>                 => <#'u'#>
        | <[$o.$m]>              => $<#$(ConvExpr(o)).$m#>
        | <[ if ($a) $b else $c]> when statement => $<#if ($(ConvExpr(a))) $(ConvExpr(b)) else $(ConvExpr(c))#>
        | <[ if ($a) $b else $c]> when !statement => $<#$(ConvExpr(a)) ? $(ConvExpr(b)) : $(ConvExpr(c))#>
        | <[ array[..$val] ]>   => CreateArray(val)
        | <[ [..$e]]>           => CreateArray(e)
        | <[ $e : $t]>          => $<#($(ConvExpr(t)))$(ConvExpr(e))#>
      }      
    }

    IsComplexType(expr : string) : bool
    {
      def loop(t)
      {
        def loop2(t2)
        {
          | Colour.Timed(t) => loop2(t)
          | Colour.Union
          | Colour.String
          | Colour.Record
          | Colour.Product
          | Colour.List     => true
          | Colour.Integer
          | Colour.Index
          | Colour.Enum
          | Colour.Simple
          | Colour.Unit
          | Colour.Bool     => false
          | Colour.Alias(t) => loop(t)
        }
        
        loop2(model.colour_sets[t].type)
      }
      
      loop(expr)
    }
   
    internal ConvParm(expr : PParameter) : string
    {
      def deflt = expr.DefaultValue.Map(x => $" = $(ConvExpr(x, false))").WithDefault("");
      def t = expr.Type;
      def type = if (IsComplexType(t.ToString())) $<#const $t &#> else $<#$t #>;
      $<#$type$(expr.Name)$deflt#>;
    }

    CreateGlobRef(name : string, val : PExpr) : string
    {
      def ty = Typer(gen.TypingMethod);
      def te = ty.TypeExpr(val);

      def type = ConvType(te);
      def val = ConvExpr(val, true);
      //<[decl: mutable $(name : usesite) : $(te.ty : typed) = $val]>
      //cpp("decl: $(type : type) $name = $val;")
      $"$type $name = $val;"
    }

    CreateVals(expr : PExpr) : string
    {
      | <[ def $(name : usesite) = $val]> => 
          def type = typer.TypeExpr(val);
          //def ty = type.ty;
          def type = type |> ConvType;
          def val = ConvExpr(val, false);
          //<[ decl: $(name : usesite) : $(ty : typed) = $val ]>
          //cpp("decl: $(type : type) $name = $val;")
          $"const $type $name = $val;"
      | _ => null
    }

    ProcessFun(expr : PExpr) : PExpr
    {


      def proc_parms(p, t, b)
      {
        def proc_parm(p, (parm, e))
        {
          def (p, e) = match (p)
                        {
                          | <[parameter: $(n : usesite) : Index.[$(type : usesite)]]> => 
                              match (model.GetIndex(type))
                              {
                                | Some((t, _)) => (<[parameter: $(n : usesite) : $(t : usesite)]> :: parm, e)
                                | _            => (parm, e)
                              }
                          | p => (p :: parm, e)  
                        }

          def e = if (t is Some(t))      
                    match (e)
                    {
                      | [] => e
                      | lst => def (last, e : list[PExpr]) = lst.PartitionLast();
                  def last = match (last)
                  {
                    | <[ {(..$e)} ]>
                    | <[(..$e)]> when e.All(x => x is PExpr.Assign) => <[ $t(..$e)]>
                    | e => e
                  }
                  e + [last]
                    } else e;

          (p, e)
        }

        def expr = <[ {..$b} ]>;
        def (p, expr) = p.Fold(([], expr :: []), proc_parm);
        (p.Rev(), expr)
      }

      match (expr)
      {
        | <[ def $(n : usesite)(..$parms) { ..$body } ]> => 

          def (parms, expr) = proc_parms(parms, None(), body);

          <[ def $(n : usesite)(..$parms) { ..$expr } ]>

        | <[ def $(n : usesite)(..$parms) : $t { ..$body } ]> => 

          def (parms, expr) = proc_parms(parms, Some(t), body);

          <[ def $(n : usesite)(..$parms) : $t { ..$expr } ]>


      }
    }

    CreateDecl(expr : PExpr) : string
    {
      | <[ def $(_ : usesite)(..$_) { ..$_ } ]> => 

          def func = ProcessFun(expr);
          def ty = Typer(gen.TypingMethod);
          def te = ty.TypeExpr(func);
          //def type = te |> ConvType;
          match (func)
          {
            | <[ def $(n : usesite)(..$parms) { ..$expr } ]> =>
                match (te)
                {
                  | TExpr.DefFunctionsIn(h :: _, _) => def ret = h.ReturnType |> ConvType;
                                                      def expr = expr.Map(ConvExpr(_, true));
                                                      def (last, expr) = expr.PartitionLast();
                                                      def parms = parms.Map(ConvParm);
                                                      $<#$ret $n(..$(parms; ","))
                                                       {..$(expr;";\n")
                                                         return $last;
                                                       }
                                                       #>
                                                      //<[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                      //  {
                                                      //    ..$expr
                                                      //  }]>
                }
        }
      | <[ def $(_ : usesite)(..$_) : $_t { ..$_ } ]> => 

          def func = ProcessFun(expr);
          match (func)
          {
            | <[ def $(n : usesite)(..$parms) : $t { ..$expr } ]> =>
                  def ret = FinalType(t.ToString());
                  
                  def expr = expr.Map(ConvExpr(_, true));
                  def expr = if (ctx.IsEmpty()) expr else $<#..$(ctx;"\n")#> :: expr;
                  def (last, expr) = expr.PartitionLast();
                  def parms = parms.Map(ConvParm);
                  $<#$ret $n(..$(parms; ","))
                    {..$(expr;";\n")
                      return $last;
                    }
                    #>
                                                      //<[decl: $(n : usesite)(..$parms) : $(ret : typed)
                                                      //  {
                                                      //    ..$expr
                }                                           //  }]>
      | _ => null
    }

    CreateColourSet2(col : ColourSet) : ClassMember.TypeDeclaration
    {
      //| ColourSet(n, Colour.Index(_, _, i)) => 
      //    <[decl: [Record]
      //      class $(i : usesite) : $(n : usesite)
      //      {

      //      }
      //      ]>;
      //| _ => null    
      null
    }

    CreateColourSet(col : ColourSet) : string
    {
      | ColourSet(n, Colour.Product(vals))   => def ftypes = vals.MapI((i, t) => ($"field$(i + 1)", TypeFromStr(t)));
                                                def fields = ftypes.Map((n, t) => $"$t $n;");
                                                def ctor = ftypes.Map((f, t) => $"$t $f");
                                                def ctorbody = ftypes.Map((f, _) => $"this->$f = $f;");
                                                $<#struct $n
                                                      {
                                                        $n(..$(ctor;", ")) 
                                                        {
                                                          ..$(ctorbody;"\n")
                                                        }
                                                        
                                                        ..$(fields;"\n")
                                                      };#>
      
                                                //CTypeDecl.Decl(CTree.Decl([CSpec.Typedef()], CType.Class(n), [CDecl.Id(CName.String(new_name), None())]))
      | ColourSet(n, Colour.Record(vals))     => def ftypes = vals.Map((n, t) => (n, TypeFromStr(t)));
                                                def fields = ftypes.Map((n, t) => $"$t $n;");
                                                def ctor = ftypes.Map((f, t) => $"$t $f");
                                                def ctorbody = ftypes.Map((f, _) => $"this->$f = $f;");
                                                $<#struct $n
                                                      {
                                                        $n(..$(ctor;", ")) 
                                                        {
                                                          ..$(ctorbody;"\n")
                                                        }
                                                        ..$(fields;"\n")
                                                      };#>
                                                //<[decl: [Record] class $(n : usesite)
                                                //        {
                                                //          ..$fields
                                                //        }
                                                //]>
      | ColourSet(n, Colour.Index(mn, mx, i)) =>   
                                                  //def eval(m : string)
                                                  //{
                                                  //   def expr = converter.ParseML(m);
                                                  //   match (expr)
                                                  //   {
                                                  //     | <[$(n : int)]>  => n
                                                  //     | <[$(name : usesite) ]> => 
                                                  //                          def match_var(x)
                                                  //                          {
                                                  //                            | <[ def $(n : usesite) = $_]> => n == name 
                                                  //                            | _                            => false
                                                  //                          }

                                                  //                          match (model.ml_decls.Find(match_var))
                                                  //                          {
                                                  //                            | Some(<[ def $(_ : usesite) = $(v : int)]>) => v
                                                  //                            | _                                  => throw InvalidOperationException()
                                                  //                          }
                                                  //   }
                                                  //}

                                                //def mn = mn |> eval;
                                                //def mx = mx |> eval;
                                                private_fields ::= $<#typedef $n int;#>;
                                                private_fields ::= $<#typedef $i int;#>;
                                                null
      //                                            cpp((<#decl:
      //                                                class $n : public index<$n>
      //                                                {
      //                                                  public:

      //                                                  $n(int num)
      //                                                  {
      //                                                    base($mn, $mx, num)
      //                                                  }


      //                                                };
      //                                               #>, ""))
      /*
      char *Name() {return $n;}
                                                        $(n : usesite) Create(num : int) {return $n(num)}

                                                        static $n Instance = $n(0);

                                                        static Tokens<$n> all()
                                                        {
                                                          return Instance.all_impl;
                                                        }
      */
      | ColourSet(n, Colour.Alias(t)) //def name = Macros.UseSiteSymbol(n);
                                                //def mods = AttributesAndModifiers(NemerleModifiers.Private, []);
                                                //def al = TopDeclaration.Alias(name, mods, Typarms.Empty, <[ $(new_name : usesite) ]>);
                                                //al |> ClassMember.TypeDeclaration.TypeDeclaration;
                                                // cpp("typedef $n $new_name")
          //$"typedef $n $new_name;"
      //| ColourSet(n, Colour.Unit(Some(t))) => 
      | ColourSet(n, Colour.Unit(Some(t))) => $<#typedef $t $n;
                                                 typedef char $t;
                                                #>
      
      | ColourSet(n, Colour.Integer) => def (t, n) = match (n)
                                                      {
                                                        | "BYTE"   => ("byte", "BYTE")
                                                        | "SHORT"  => ("short", "SHORT")
                                                        | "INT"    => ("int", "INT")
                                                        | "UINT"   => ("uint", "UINT")
                                                        | "USHORT" => ("ushort", "USHORT")
                                                      }
                                        $<#typedef $t $n;#>               
      | ColourSet(n, Colour.Unit) with t = "char"                                                       
      | ColourSet(n, Colour.Simple(t))  => $<#typedef $t $n;#>
      | ColourSet(n, Colour.Enum(vals)) => //def vals = vals.Map(x => $"$x");
                                          $<#    enum $n
                                                 {
                                                   ..$vals;
                                                 };#>
      | ColourSet(n, Colour.Timed(c))   => CreateColourSet(ColourSet(n, c))
      
      | _                               => null
    }    

    CreateInitMarking(place : Place) : string
    {
      def combine(e1, e2)
      {
        | (<[Enumerable.Repeat($tok, $(n : int))]>, <[Enumerable.Repeat($tok2, $(n2 : int))]>) when (tok.Equals(tok2)) 
            => <[Enumerable.Repeat($tok, $(n2 + n))]>
        | (<[Enumerable.Repeat($(tok : int), $(n : int))]>, <[Enumerable.Repeat($(tok2 : int), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : int)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : string), $(n : int))]>, <[Enumerable.Repeat($(tok2 : string), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : string)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>
        | (<[Enumerable.Repeat($(tok : double), $(n : int))]>, <[Enumerable.Repeat($(tok2 : double), $(n2 : int))]>)                         
            => def val = Enumerable.Repeat(tok, n).Concat(Enumerable.Repeat(tok2, n2)).Select(x => <[ $(x : double)]>).ToArray();
              if (val.Length > 50) <[ $(e1).Concat($e2)]> else
              <[ array[..$val] ]>       
        | _  //(<[Enumerable.Repeat($_, $(_ : int))]>, <[Enumerable.Repeat($_, $(_ : int))]>)                         
            => <[ $e1.Concat($e2)]> 
      }

      def unfold(expr)
      {
        | <[ () ]> => <[()]>
        | e        => e
      }

      def fold(expr) : PExpr
      {
        //| <[ {..$e} ]>   => e.Fold(acc, fold)
        | <[ 1 ` $tok %@ $time ]>             => def time = time |> ConvExpr(_, false);
                                                def tok = unfold(tok);
                                                <[at_time($tok, $time)]>
        | <[ 1 ` $tok]>                       => <[$(unfold(tok))]>
        | <[ $(n : int) ` $tok %@ $time ]>    => <[IEnumerable.Repeat(at_time($(unfold(tok)), $time), $n)]>
        | <[ $(n : int) ` $tok]>              => <[IEnumerable.Repeat($(unfold(tok)), $n)]>
        | <[ $l %++ $r]>                      => <[$(combine(fold(l), fold(r)))]>
        | e                                   => unfold(e)
      }

      if (place.init_mark == null) null else
      {
        def mark = fold(place.init_mark);
        def mark = mark |> ConvExpr(_, false);
        def mark = if (place.IsTimed) $"add_time($mark, 0);" else mark;
        def name = place.name;
        //<[ $(name : usesite).Add($mark)]>
        $"$name.add($mark);"
      }
    }

    //CreateToString() : void
    //{
    //  def strings = model.places.Map(x => <[ $(x.name : usesite).ToString() ]>);
    //  fields ::= <[decl: public override ToString() : string 
    //  { 
    //    def str = array[..$strings];
    //    string.Join(";\n", str)
    //  }]>
    //}

    Base : string
    {
      [Memoize]
      get
      {
        if (model.IsTimed) "timed_petri_net" else "petri_net"
      }
    }

    CreateCons() : void
    {
      def marking = model.places.MapToList(CreateInitMarking).Filter(_ != null);
      public_fields ::= if (model.IsTimed || model.IsHaveImmediateTransitions) 
      $<#$Name(int time_step = 15) 
      { 
        $Base(time_step);
        ..$(marking;"\n")
        ..$(cons_expr;"\n")
      }#>; 
                        else $<#$Name(int time_step = 15) 
      { 
        ..$(marking;"\n")
        ..$(cons_expr;"\n")
      }#>;//<[decl: public this() { {..$marking} {..$cons_expr} }]>;
    }

    CreateTimeMethods() : void
    {
      def body = model.transitions.Where(_.IsTimed).Map(x => <[ $(x.Name : usesite)() ]>);
      def next = model.places.Where(_.IsTimed).Map(x => $"$(x.name).NextTokenDelay");

      def time_body = match (next)
                       {
                         | []    => "return 0xFFFFFFFF;"
                         | [one] => one
                         | lst   => def next = lst.Map(x => $<#min = math_utils::min(min, $x); #>);
                          $<#
                                  int min = 0xFFFFFFFF;
                                  ..$(next;"\n");
                                  return min;
                              #>
                       }
      private_fields ::= $<#int get_next_time()
                      {
                        $time_body;
                      }#>;
      private_fields ::= $<#void time_step()
                      {
                        ..$body;
                      }#>
    }

    CreateStepMethod() : void
    {
      def body = model.transitions.Where(x => x.IsImmediate && !x.IsTimed).Map(x => $<#$(x.Name)()#>);
      when (!body.IsEmpty())
        public_fields ::= $<#void step()
      {
        ..$(body; "\n")
      }#>
    }

    CreateStartMethod() : void
    {
      //fields ::= []
      /*cpp(<#decl: void Initiate()
                      {
                        ..$init_body;
                      })*/
    }

    CreateEvents() : void
    {
      when (proc.Flags.HasFlag(PetriNetFlags.Events))
      {
        foreach (t in model.transitions)
        {
          def name = t.Name;
          def evt = $"evt_$name";
          //fields ::= $<#decl: public event $(evt : usesite) : Action#>;
          //fields ::= <[decl: $($"On$name" : usesite)() : void
          //            {
          //              $(evt : usesite)?.Invoke()
          //            } ]>;
        }
      }
    }

    public Generate() : void
    {      
      //CreateOperators();
      //assert2(false);
      def sets = model.colour_sets.Values.Map(CreateColourSet).Filter(_ != null);
      //def sets2 = model.colour_sets.Values.Map(CreateColourSet2).Filter(_ != null);
      //def sets = sets + sets2;
      foreach (m in sets) Define(m);//typebuilder.DefineNestedTypeWithSource(m).Compile();

      def places = model.places.MapToList(CreatePlace);      

      when (model.IsTimed) CreateTimeMethods();
      CreateStepMethod();

      CreateEvents();
      //CreateTranQueue();
      //CreateToString();
      CreateStartMethod();
      CreateCons();

      def members = places;
      foreach (m in members) Define(m)//_ = typebuilder.DefineWithSource(m);
    }

    Define(decl : list[string], pub : bool = false) : void
    {
      if (pub)
      {
        foreach (d in decl) 
        {
          public_fields ::= d;
          //public_fields ::= "\n"
        }
      } else
      {
        foreach (d in decl)
        {
          private_fields ::= d;
          //private_fields ::= "\n"
        }
      }
    }

    Define(decl : string) : void
    {
      private_fields ::= decl;
      //private_fields ::= "\n"
      //def ty = CTree.Type.type_lens >> CComplexType.Class.decls_lens;
      //main_class = ty.Update(main_class, x => x.Append(decl));
      //(main_class.type :> CComplexType.Class).
    }


    public PhaseOne() : void
    {
      //def name = proc.Name;

      //main_class = cpp(<#class $name : public $(bas : type)
      //                {
      //                };#>);
      //printer.
      //typebuilder.AddImplementedInterface(<[ IDisposable ]>);
      //typebuilder.AddImplementedInterface(if (model.IsTimed) <[ TimedPetriNet ]> 
      //                                    else <[PetriNet]>);
    }

    public PhaseTwo() : void
    {
      //CreateDummyMethod();
      def methods = model.transitions.MapToList(CreateTran);
      def vals = model.ml_decls.Map(CreateVals).Filter(_ != null);
      Define(vals);//_ = typebuilder.DefineWithSource(m);
      def decls = model.ml_decls.Map(CreateDecl).Filter(_ != null);
      Define(methods, true);
      Define(decls);//_ = typebuilder.DefineWithSource(m);
      def globrefs = model.glob_refs.KeyValuePairs.MapToList(CreateGlobRef);
      Define(globrefs);//_ = typebuilder.DefineWithSource(m);
      System.IO.File.WriteAllText(file, main_class)
      //typebuilder.Compile()
    }
  }
}