using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler;
using CommonLib.Macros;

namespace PetriNetLib
{

  enum TDestCont
  {
    | MultiSet
    | RandomEnumerable
    | TokenQueue
    | SortedSet
    | TimedSimpleMultiset
    | Var    // имеет 1 фишку, аналогично обычному полю
    | Single // имеет 0 или 1 фишку, для отсутствия использует отдельный флаг
    | ReqContainer    // значение запрашивается из внешней функции
    | ZeroSingle // имеет 0 или 1 фишку, для отсутствия используется 0 если INT
    | MinusSingle // имеет 0 или 1 фишку, для отсутствия используется -1 если INT
    // возможно PUSH сочетать с Var, Single и ZeroSingle для 
    // выдвигания фишек в именованый переход, подобно событию
  }

  [Record]
  //[Lens]
  class Place
  {
    public idx    : int;
    public id     : string;
    public name   : string;
    public colour : ColourSet;

    public init_mark : PExpr;
    public port      : option[PortType];
    public tree      : CpnTree.Place;
    public net       : PetriNetProcessor;
    
    public gen_idx : int {get;set;}
    public Name : string
    {
      [Memoize]
      get
      {
        match (name.LastIndexOf("]"))
        {
          | -1 => name
          | n  => name.Substring(n + 1)
        }
      }
    }

    public Attributes : list[string]
    {
      [Memoize]
      get
      {
        def start_idx = name.IndexOf("[");
        def end_idx = name.IndexOf("]");
        if (start_idx != -1 && end_idx != -1)
        {
          def str = name.Substring(start_idx + 1, end_idx - start_idx - 1);
          str.Split(',').NToList()
        } else []
      }
    }

    public IsTransparent : bool
    {
      [Memoize]
      get
      {
        match (OutputTransitions)
        {
          | [(tran, _arc)] => 
                             def inpl = tran.InputPlaces.Exclude((x, _) => x.idx  == this.idx);
                             inpl.All((x, _) => x.Var || x.Req) &&
                             tran.guard is <[]>
                             //tran.OutputPlaces.All((_, a) => a.expr.ToString() == arc.expr.ToString()) &&
                             //tran.code_segment
          | _             => false                             
        }
      }
    }
    
    public Req : bool
    {
      [Memoize]
      get
      {
        Attributes.Exists(_ == "REQ")
      }
    }

    public ZeroSingle : bool
    {
      [Memoize]
      get
      {
        Attributes.Exists(_ == "ZEROSINGLE") 
      }
    }
    
    public Push : bool
    {
      [Memoize]
      get
      {
        Attributes.Exists(_ == "PUSH") 
      }
    }
    
    public Cached : bool
    {
      [Memoize]
      get
      {
        Attributes.Exists(_ == "CACHED")
      }
    }

    public Var : bool
    {
      [Memoize]
      get
      {
        Attributes.Exists(_ == "VAR")
      }
    }

    public Single : bool
    {
      [Memoize]
      get
      {
        Attributes.Exists(_ == "SINGLE")
      }
    }

    public Queue : bool
    {
      [Memoize]
      get
      {
        Attributes.Exists(_ == "QUEUE")
      }
    }

    public Sorted : bool
    {
      [Memoize]
      get
      {
        Attributes.Exists(_ == "SORTED")
      }
    }
    
    public IsTimed : bool
    {
      [Memoize]
      get
      {
        colour is ColourSet(_, Timed)
      }
    }

    public OutputTransitions : list[Transition * Arc]
    {
      [Memoize]
      get
      {
        net.OutputPlaceArcs(this)
      }
    }

    public InputTransitions : list[Transition * Arc]
    {
      [Memoize]
      get
      {
        net.InputPlaceArcs(this)
      }
    }

    public override GetHashCode() : int
    {
      idx
    }
  }

  //[Record]
  //class TokenSet
  //{
  //  public num   : int;
  //  public token : Token;
  //}

  [Record]
  [Lens]
  class Transition
  { 
    public idx : int;
    public id  : string;
    public name : string;
    public guard : PExpr;

    public time_expr : PExpr;
    public code_segment : PExpr;
    public priority : int;
    public net : PetriNetProcessor;

    public IsTimed : bool
    {
      [Memoize]
      get
      {
        InputPlaces.Exists((x, a) => x.IsTimed && a.kind == ArcKind.Normal)
        //colour is ColourSet(_, Timed)
      }
    }

    public IsImmediate : bool
    {
      [Memoize]
      get
      {
        IsUnnamed || guard is <[ immediate ]>
      }
    }

    public OutputPlaces : list[Place * Arc]
    {
      [Memoize]
      get
      {
        net.OutputTransitionArcs(this)
      }
    }

    public InputPlaces : list[Place * Arc]
    {
      [Memoize]
      get
      {
        net.InputTransitionArcs(this)
      }
    }

    public IsUnnamed : bool
    {
      [Memoize]
      get
      {
        name == null || name.IsEmpty()
      }
    }

    static mutable unnamed_idx : int;

    public UnnamedIdx : int
    {
      [Memoize]
      get
      {
        if (IsUnnamed)
        {
          def idx = unnamed_idx;
          unnamed_idx++;
          idx
        } else 0
      }
    }
    
    public IsPartOfGroupTransition : bool
    {
      [Memoize]
      get
      {
        !InputPlaces.SelectMany((x : Place, _) => x.OutputTransitions
        .Select(x => x[0].priority)).NToList()
        .ElementsEqual(_ == _)
      }
    }
    
    public Name : string
    {
      [Memoize]
      get
      {
        if (IsUnnamed)
        {
          $"UnnamedTransition$UnnamedIdx"
        } else
        {
          name
        }
      }
    }

    public override GetHashCode() : int
    {
      idx
    }
  }

  [Record]
  variant ArcSource
  {
    | PlaceEnd      {place : Place}
    | TransitionEnd {tran  : Transition}
  }

  enum ArcKind
  {
    | Normal
    | Reset
    | Inhibitor
  }
    
  [Record]
  [Lens]
  class Arc
  { 
    public expr : PExpr;

    public from : ArcSource;
    public to   : ArcSource;

    public NumberTokensGet : int
    {
      [Memoize]
      get
      {
        match (expr)
        {
          | <[ $(n : int) ` $_ ]>     => n
          | <[ $(_ : usesite)]>       => 1
          | _                         => -1
        }
      }
    }
    
    public kind : ArcKind;
  }

  [Record]
  class ColourSet
  {
    public name : string;
    public type : Colour;
    
    

  }

  variant ExecError
  {
    | TokenConstantNotFound { place : Place; val : object }
    | VarNotFound {name : string}
    | TypeTokenNotCompat {incol : Colour; outcol : Colour;place : Place}
  }

  [Flags]
  public enum PetriNetFlags
  {
    | Debug        = 1
    | Events       = 2
    | PrintBinding = 4
  }
}
