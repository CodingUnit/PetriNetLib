using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace PetriNetModel
{
  class BitIEnumerable
  {
    buf : List[int] = List();
  }
  
  public interface ITokenContainer[T]
  {
    Create() : ITokenContainer[T];
    Create(en : IEnumerable[T]) : ITokenContainer[T];
    Add(tok : T) : void;
    
    AddMany(tok : IEnumerable[T]) : void;
    
    Have(tok : IEnumerable[T]) : bool;
    
    HaveTokens : bool
    {
      get;
    }
    
    GetMany(tok : IEnumerable[T]) : IEnumerable[T];
    
    Get() : T;
  }
  
  
  class TokenQueue[T] : ITokenContainer[T]
  {
    public Create() : ITokenContainer[T]
    {
      TokenQueue()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      TokenQueue(en)
    }
    
    public this() {}
    public this(en : IEnumerable[T])
    {
      
    }
    
    public Add(tok : T) : void {}
    
    public AddMany(tok : IEnumerable[T]) : void {}
    
    public Have(tok : IEnumerable[T]) : bool {false}
    
    public HaveTokens : bool
    {
      get {false}
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      throw NotImplementedException()
    }
    
    public Get() : T
    {
      default(T)
    }
  }
  
  class RandomIEnumerable[T] : ITokenContainer[T]
  {
    queue   : List[T];
    elems   : BitIEnumerable;
    
    public Create() : ITokenContainer[T]
    {
      RandomIEnumerable()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      RandomIEnumerable(en)
    }
    
    public this(en : IEnumerable[T])
    {
      
    }
    
    public this()
    {
      
    }
    
    public Add(tok : T) : void {}
    
    public AddMany(tok : IEnumerable[T]) : void {}
    
    public Have(tok : IEnumerable[T]) : bool {false}
    
    public HaveTokens : bool
    {
      get {false}
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      Enumerable.Empty()
    }
    
    public Get() : T
    {
      default(T)
    }
  }
  
  class HashMultiSet[T]
  {
    mutable table : array[Entry] = array(32);
    
    [Record]
    class Entry
    {
      public key   : T;
      public count : int {get;set;}
     
      public Empty : bool
      {
        get
        {
          count == 0
        }
      }
    }
    
    Prime : int;
    
    Resize(size : int) : void
    {
      Array.Resize(ref table, size)
    }
    
    public this()
    {
    }
    
    public this(vals : IEnumerable[T])
    {
    }
    
    hash1(x : T) : int
    {
      x.GetHashCode() % table.Length
    }
    
    hash2(x : T) : int
    {
      Prime - (x.GetHashCode() % Prime)
    }
    
    public Add(k : T, count : int = 1) : void
    {
      def (entry, point) = FindEntry(k);
      if (entry != null)
      {
        entry.count += count;
      } else
      {
        table[point] = Entry(k, count)
      }
    }
    
    public Remove(k : T, count : int = 1) : void
    {
      def (entry, _) = FindEntry(k);
      when (entry != null)
      {
        if (entry.count > count)
          entry.count -= count; else entry.count = 0;
      }
    }
    
    FindEntry(k : T) : Entry * int
    {
      def probePoint = hash1(k);
      def incr = hash2(k);
      
      def loop(point)
      {
          def entry = table[point];
          if (entry == null || entry.Empty || entry.key.Equals(k)) (entry, point) else loop((point + incr) % table.Length)
      }
    
      
      loop(probePoint)
    }
  }
  
  public class MultiSet[T] : ITokenContainer[T]
  {
    table : HashMultiSet[T] = HashMultiSet();
    
    public Create() : ITokenContainer[T]
    {
      MultiSet()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      MultiSet(en)
    }
    
    public this(en : IEnumerable[T])
    {
      AddMany(en)
    }
    
    public this()
    {
    }
    
    public Add(tok : T) : void {}
    
    public AddMany(tok : IEnumerable[T]) : void {}
    
    public Have(tok : IEnumerable[T]) : bool {false}
    
    public HaveTokens : bool
    {
      get {false}
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      Enumerable.Empty()
    }
    
    public Get() : T
    {
      default(T)
    }
  }
  
  public class Place[T]
  {
    tokens : ITokenContainer[T];
    
    public this() {tokens = MultiSet()}
    public this(cont : ITokenContainer[T]) {tokens = cont}
    
    public this(en : IEnumerable[T], cont : ITokenContainer[T])
    {
      tokens = cont.Create(en)
    }
    
    public Add(tok : T) : void
    {
      tokens.Add(tok)
    }
    
    public Add(tok : IEnumerable[T]) : void
    {
      tokens.AddMany(tok)
    }
    
    public Have(tok : IEnumerable[T]) : bool
    {
      tokens.Have(tok)
    }
    
    public HaveTokens : bool
    {
      get
      {
        tokens.HaveTokens
      }
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      tokens.GetMany(tok)
    }
    
    public Get() : T
    {
      tokens.Get()
    }
  }
}
