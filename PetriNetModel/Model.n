using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Random;

namespace PetriNetModel
{
  class BitIEnumerable
  {
    buf : List[int] = List();
  }
  
  public interface ITokenContainer[T]
  {
    Create() : ITokenContainer[T];
    Create(en : IEnumerable[T]) : ITokenContainer[T];
    Add(tok : T) : void;
    
    AddMany(tok : IEnumerable[T]) : void;
    
    Have(num : int) : option[T];
    Have(tok : IEnumerable[T]) : bool;
    
    HaveTokens : bool
    {
      get;
    }
    
    GetMany(key : T, num : int) : void;
    GetMany(tok : IEnumerable[T]) : void;
    
    Get() : T;
  }
  
  
  class TokenQueue[T] : ITokenContainer[T]
  {
    public Create() : ITokenContainer[T]
    {
      TokenQueue()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      TokenQueue(en)
    }
    
    public this() {}
    public this(en : IEnumerable[T])
    {
      
    }
    
    public Add(tok : T) : void {}
    
    public AddMany(tok : IEnumerable[T]) : void {}
    
    public Have(tok : IEnumerable[T]) : bool {false}
    
    public HaveTokens : bool
    {
      get {false}
    }
    
    public GetMany(tok : IEnumerable[T]) : void
    {
      throw NotImplementedException()
    }
    
    public Get() : T
    {
      default(T)
    }
  }
  
  class RandomArray[T] : ITokenContainer[T]
  {
    queue   : List[T];
    elems   : BitIEnumerable;
    
    public Create() : ITokenContainer[T]
    {
      RandomArray()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      RandomArray(en)
    }
    
    public this(en : IEnumerable[T])
    {
      
    }
    
    public this()
    {
      
    }
    
    public Add(tok : T) : void {}
    
    public AddMany(tok : IEnumerable[T]) : void {}
    
    public Have(tok : IEnumerable[T]) : bool {false}
    
    public HaveTokens : bool
    {
      get {false}
    }
    
    public GetMany(tok : IEnumerable[T]) : void
    {
    }
    
    public Get() : T
    {
      default(T)
    }
  }
  
  
  class RQueue[T]
  {
    queue : List[T] = List();
    mutable wi : int;
    mutable ri : int;
    
    public Enqueue(elem : T) : void
    {
      queue[wi] = elem;
      wi++;
    }
    
    public Deque() : T
    {
      def val = queue[ri];
      ri++;
      val
    }
    
    public Peek() : T
    {
      queue[ri]
    }
    
    public Item[index : int] : T
    {
      get
      {
        queue[index]
      }
      set
      {
        queue[index] = value
      }
    }
  }
  
  class HashMultiSet[T]// : IEnumerable[T * int]
  {
    mutable buckets : array[Bucket] = array(32);
    //class Enumerator : IEnumerator[T * int]
    //{
    //  public MoveNext() : bool
    //  {
    //  }
      
    //  public Current : T * int
    //  {
    //    get
    //    {
          
    //    }
    //  }
    //}
    
    public Buckets : int
    {
      get
      {
        buckets.Length
      }
    }
    
    //public GetEnumerator() : IEnumerator[T * int]
    //{
    //}
    
    public Count : int
    {
      get;
      private set;
    }
    
    factor : double
    {
      get
      {
        1.0 * Count / buckets.Length
      }
    }
    
    [Record]
    class Bucket
    {
      public key   : T;
      public count : int {get;set;}
     
      public Empty : bool
      {
        get
        {
          count == 0
        }
      }
    }
    
    Rehash() : void
    {
      def old = buckets;
      buckets = array(buckets.Length * 2);
      foreach (bucket in old)
      {
        | null 
        | Bucket(Empty = true)       => ()
        | Bucket(key = k, count = c) => Add(k, c)
      }
    }
    
    public this()
    {
    }
    
    public this(vals : IEnumerable[T])
    {
      foreach (item in vals)
      {
        Add(item)
      }
    }
    
    hash1(x : T) : int
    {
      x.GetHashCode() % buckets.Length
    }
    
    hash2(x : T) : int
    {
      def prime = buckets.Length - 1;
      prime - (x.GetHashCode() % prime)
    }
    
    public ContainsCount(count : int) : option[T]
    {
      def en = buckets.AsEnumerable().GetEnumerator();
      
      def loop()
      {
        match (en.Current)
        {
          | null
          | Bucket(Empty = true) => if (en.MoveNext()) loop() else None()
          | n                    => if (n.count >= count)
                                    {
                                      Some(n.key)
                                    } else 
                                    {
                                      if (en.MoveNext()) loop() else None()
                                    }
        }
      }
      
      loop();
    }
    
    public ElementAtPos(pos : int) : T
    {
      def end = pos;
      
      def loop(i, c)            
      {
        if (c == 0 && i == buckets.Length) loop(0, 1) else
        if (c == 1 && i == end) default(T) else
        match (buckets[i])
        {
          | null
          | Bucket(Empty = true) => loop(i + 1, c)
          | e                   => e.count--;e.key
        }
      }
      
      loop(pos % buckets.Length, 0)
    }
    
    public Contains(k : T, count : int = 1) : bool
    {
      def (e, _) = FindEntry(k);
      e != null && !e.Empty && e.count >= count
    }
    
    public Add(k : T, count : int = 1) : void
    {
      def (entry, point) = FindEntry(k);
      if (entry != null)
      {
        entry.count += count;
      } else
      {
        buckets[point] = Bucket(k, count);
        Count++;
        when (factor >= 0.75) Rehash();
      }
    }
    
    public Remove(k : T, count : int = 1) : void
    {
      def (entry, _) = FindEntry(k);
      when (entry != null)
      {
        if (entry.count > count)
          entry.count -= count; else entry.count = 0;
      }
    }
    
    FindEntry(k : T) : Bucket * int
    {
      def probePoint = hash1(k);
      def incr = hash2(k);
      
      def loop(point)
      {
          def entry = buckets[point];
          if (entry == null || entry.Empty || entry.key.Equals(k)) (entry, point) else loop((point + incr) % buckets.Length)
      }
    
      loop(probePoint)
    }
    
  }
  
  public class MultiSet[T] : ITokenContainer[T]
  {
    table : HashMultiSet[T] = HashMultiSet();
    rnd   : Random = Random();
    
    public Create() : ITokenContainer[T]
    {
      MultiSet()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      MultiSet(en)
    }
    
    public this(en : IEnumerable[T])
    {
      AddMany(en)
    }
    
    public this()
    {
    }
    
    public Add(tok : T) : void {table.Add(tok)}
    
    public AddMany(tok : IEnumerable[T]) : void 
    {
      foreach (t in tok)
      {
        table.Add(t)
      }
    }
    
    public Have(tok : IEnumerable[T]) : bool 
    {
      tok.All(x => table.Contains(x))// table.Contains()
    }
    
    public Have(num : int) : option[T]
    {
      table.ContainsCount(num)
    }
    
    public HaveTokens : bool
    {
      get {table.Count != 0}
    }
    
    public GetMany(key : T, num : int) : void
    {
      table.Remove(key, num)
    }
    
    public GetMany(tok : IEnumerable[T]) : void
    {
      foreach (t in tok)
      {
        table.Remove(t)
      }
    }
    
    public Get() : T
    {
      def pos = rnd.Next(table.Buckets);
      table.ElementAtPos(pos)
    }
    
    public override ToString() : string
    {
      
    }
  }
  
  public class Place[T]
  {
    tokens : ITokenContainer[T];
    
    public Name : string;
    public this(name : string) {Name =  name;tokens = MultiSet()}
    public this(name : string, cont : ITokenContainer[T]) {tokens = cont; Name = name;}
    
    public this(en : IEnumerable[T], cont : ITokenContainer[T])
    {
      tokens = cont.Create(en)
    }
    
    public Add(tok : T) : void
    {
      tokens.Add(tok)
    }
    
    public Add(tok : IEnumerable[T]) : void
    {
      tokens.AddMany(tok)
    }
    
    public Have(tok : IEnumerable[T]) : bool
    {
      tokens.Have(tok)
    }
    
    public HaveTokens : bool
    {
      get
      {
        tokens.HaveTokens
      }
    }
    
    public GetMany(tok : IEnumerable[T]) : void
    {
      tokens.GetMany(tok)
    }
    
    public Get() : T
    {
      tokens.Get()
    }
    
    public override ToString() : string
    {
      $"$Name{$tokens}"
    }
  }
}
