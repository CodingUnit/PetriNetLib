using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Random;

namespace PetriNetModel
{
  class BitIEnumerable
  {
    buf : List[int] = List();
  }
  
  public interface ITokenContainer[T]
  {
    Create() : ITokenContainer[T];
    Create(en : IEnumerable[T]) : ITokenContainer[T];
    Add(tok : T) : void;
    
    AddMany(tok : IEnumerable[T]) : void;
    
    Have(tok : IEnumerable[T]) : bool;
    
    HaveTokens : bool
    {
      get;
    }
    
    GetMany(tok : IEnumerable[T]) : void;
    
    Get() : T;
  }
  
  
  class TokenQueue[T] : ITokenContainer[T]
  {
    public Create() : ITokenContainer[T]
    {
      TokenQueue()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      TokenQueue(en)
    }
    
    public this() {}
    public this(en : IEnumerable[T])
    {
      
    }
    
    public Add(tok : T) : void {}
    
    public AddMany(tok : IEnumerable[T]) : void {}
    
    public Have(tok : IEnumerable[T]) : bool {false}
    
    public HaveTokens : bool
    {
      get {false}
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      throw NotImplementedException()
    }
    
    public Get() : T
    {
      default(T)
    }
  }
  
  class RandomIEnumerable[T] : ITokenContainer[T]
  {
    queue   : List[T];
    elems   : BitIEnumerable;
    
    public Create() : ITokenContainer[T]
    {
      RandomIEnumerable()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      RandomIEnumerable(en)
    }
    
    public this(en : IEnumerable[T])
    {
      
    }
    
    public this()
    {
      
    }
    
    public Add(tok : T) : void {}
    
    public AddMany(tok : IEnumerable[T]) : void {}
    
    public Have(tok : IEnumerable[T]) : bool {false}
    
    public HaveTokens : bool
    {
      get {false}
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      Enumerable.Empty()
    }
    
    public Get() : T
    {
      default(T)
    }
  }
  
  class HashMultiSet[T]
  {
    mutable buckets : array[Entry] = array(32);
    
    public Buckets : int
    {
      get
      {
        buckets.Length
      }
    }
    
    public Count : int
    {
      get;
      private set;
    }
    
    factor : double
    {
      get
      {
        1.0 * Count / buckets.Length
      }
    }
    
    [Record]
    class Entry
    {
      public key   : T;
      public count : int {get;set;}
     
      public Empty : bool
      {
        get
        {
          count == 0
        }
      }
    }
    
    Rehash() : void
    {
      def old = buckets;
      buckets = array(buckets.Length * 2);
      foreach (bucket in old)
      {
        | null 
        | Entry(Empty = true)       => ()
        | Entry(key = k, count = c) => Add(k, c)
      }
    }
    
    public this()
    {
    }
    
    public this(vals : IEnumerable[T])
    {
      foreach (item in vals)
      {
        Add(item)
      }
    }
    
    hash1(x : T) : int
    {
      x.GetHashCode() % buckets.Length
    }
    
    hash2(x : T) : int
    {
      def prime = buckets.Length - 1;
      prime - (x.GetHashCode() % prime)
    }
    
    public ElementAtPos(pos : int) : T
    {
      def end = pos;
      
      def loop(i, c)            
      {
        if (c == 0 && i == buckets.Length) loop(0, 1) else
        if (c == 1 && i == end) default(T) else
        match (buckets[i])
        {
          | null
          | Entry(Empty = true) => loop(i + 1, c)
          | e                   => e.count--;e.key
        }
      }
      
      loop(pos % buckets.Length, 0)
    }
    
    public Contains(k : T, count : int = 1) : bool
    {
      def (e, _) = FindEntry(k);
      e != null && !e.Empty && e.count >= count
    }
    
    public Add(k : T, count : int = 1) : void
    {
      def (entry, point) = FindEntry(k);
      if (entry != null)
      {
        entry.count += count;
      } else
      {
        buckets[point] = Entry(k, count);
        Count++;
        when (factor >= 0.75) Rehash();
      }
    }
    
    public Remove(k : T, count : int = 1) : void
    {
      def (entry, _) = FindEntry(k);
      when (entry != null)
      {
        if (entry.count > count)
          entry.count -= count; else entry.count = 0;
      }
    }
    
    FindEntry(k : T) : Entry * int
    {
      def probePoint = hash1(k);
      def incr = hash2(k);
      
      def loop(point)
      {
          def entry = buckets[point];
          if (entry == null || entry.Empty || entry.key.Equals(k)) (entry, point) else loop((point + incr) % table.Length)
      }
    
      loop(probePoint)
    }
    
  }
  
  public class MultiSet[T] : ITokenContainer[T]
  {
    table : HashMultiSet[T] = HashMultiSet();
    rnd : Random = Random();
    
    public Create() : ITokenContainer[T]
    {
      MultiSet()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      MultiSet(en)
    }
    
    public this(en : IEnumerable[T])
    {
      AddMany(en)
    }
    
    public this()
    {
    }
    
    public Add(tok : T) : void {table.Add(tok)}
    
    public AddMany(tok : IEnumerable[T]) : void 
    {
      foreach (t in tok)
      {
        table.Add(t)
      }
    }
    
    public Have(tok : IEnumerable[T]) : bool 
    {
      tok.All(x => table.Contains(x))// table.Contains()
    }
    
    public HaveTokens : bool
    {
      get {table.Count != 0}
    }
    
    public GetMany(tok : IEnumerable[T]) : void
    {
      foreach (t in tok)
      {
        table.Remove(t)
      }
    }
    
    public Get() : T
    {
      def pos = rnd.Next(table.Buckets);
      table.ElementAtPos(pos)
    }
  }
  
  public class Place[T]
  {
    tokens : ITokenContainer[T];
    
    public this() {tokens = MultiSet()}
    public this(cont : ITokenContainer[T]) {tokens = cont}
    
    public this(en : IEnumerable[T], cont : ITokenContainer[T])
    {
      tokens = cont.Create(en)
    }
    
    public Add(tok : T) : void
    {
      tokens.Add(tok)
    }
    
    public Add(tok : IEnumerable[T]) : void
    {
      tokens.AddMany(tok)
    }
    
    public Have(tok : IEnumerable[T]) : bool
    {
      tokens.Have(tok)
    }
    
    public HaveTokens : bool
    {
      get
      {
        tokens.HaveTokens
      }
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      tokens.GetMany(tok)
    }
    
    public Get() : T
    {
      tokens.Get()
    }
  }
}
