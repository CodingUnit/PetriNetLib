using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace PetriNetModel
{
  class BitIEnumerable
  {
    buf : List[int] = List();
  }
  
  public interface ITokenContainer[T]
  {
    Create() : ITokenContainer[T];
    Create(en : IEnumerable[T]) : ITokenContainer[T];
    Add(tok : T) : void;
    
    AddMany(tok : IEnumerable[T]) : void;
    
    Have(tok : IEnumerable[T]) : bool;
    
    HaveTokens : bool
    {
      get;
    }
    
    GetMany(tok : IEnumerable[T]) : IEnumerable[T];
    
    Get() : T;
  }
  
  
  class TokenQueue[T] : ITokenContainer[T]
  {
    public Create() : ITokenContainer[T]
    {
      TokenQueue()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      TokenQueue(en)
    }
    
    public this() {}
    public this(en : IEnumerable[T])
    {
      
    }
    
    public Add(tok : T) : void {}
    
    public AddMany(tok : IEnumerable[T]) : void {}
    
    public Have(tok : IEnumerable[T]) : bool {false}
    
    public HaveTokens : bool
    {
      get {false}
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      throw NotImplementedException()
    }
    
    public Get() : T
    {
      default(T)
    }
  }
  
  class RandomIEnumerable[T] : ITokenContainer[T]
  {
    queue   : List[T];
    elems   : BitIEnumerable;
    
    public Create() : ITokenContainer[T]
    {
      RandomIEnumerable()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      RandomIEnumerable(en)
    }
    
    public this(en : IEnumerable[T])
    {
      
    }
    
    public this()
    {
      
    }
    
    public Add(tok : T) : void {}
    
    public AddMany(tok : IEnumerable[T]) : void {}
    
    public Have(tok : IEnumerable[T]) : bool {false}
    
    public HaveTokens : bool
    {
      get {false}
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      Enumerable.Empty()
    }
    
    public Get() : T
    {
      default(T)
    }
  }
  
  class HashMultiSet[T]
  {
    table : array[Entry];
    
    [Record]
    class Entry
    {
      public key   : T;
      public count : int;
     
      public Empty : bool
      {
        get
        {
          count == 0
        }
      }
    }
    
    Prime : int;
    
    hash1(x : T) : int
    {
      x.GetHashCode() % table.Length
    }
    
    hash2(x : T) : int
    {
      Prime - (x.GetHashCode() % Prime)
    }
    
    public FindEntry(k : T) : bool
    {
      def probePoint = hash1(k);
      def incr = hash2(k);
      
      def loop(point)
      {
          def entry = table[point];
          if (entry == null || entry.Empty || !entry.key.Equals(k)) loop((point + incr) % table.Length) else true
      }
    
      
      loop(probePoint)
    }
  }
  
  public class MultiSet[T] : ITokenContainer[T]
  {
    table : HashMultiSet[T] = HashMultiSet();
    
    public Create() : ITokenContainer[T]
    {
      MultiSet()
    }
    
    public Create(en : IEnumerable[T]) : ITokenContainer[T]
    {
      MultiSet(en)
    }
    
    public this(en : IEnumerable[T])
    {
      AddMany(en)
    }
    
    public this()
    {
    }
    
    public Add(tok : T) : void {}
    
    public AddMany(tok : IEnumerable[T]) : void {}
    
    public Have(tok : IEnumerable[T]) : bool {false}
    
    public HaveTokens : bool
    {
      get {false}
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      Enumerable.Empty()
    }
    
    public Get() : T
    {
      default(T)
    }
  }
  
  [Record]
  public class Place[T, TCont] where TCont : ITokenContainer[T]
  {
    tokens : ITokenContainer[T];
    
    public this() {}
    
    public this(en : IEnumerable[T])
    {
      tokens = tokens.Create(en)
    }
    
    public Add(tok : T) : void
    {
      tokens.Add(tok)
    }
    
    public Add(tok : IEnumerable[T]) : void
    {
      tokens.AddMany(tok)
    }
    
    public Have(tok : IEnumerable[T]) : bool
    {
      tokens.Have(tok)
    }
    
    public HaveTokens : bool
    {
      get
      {
        tokens.HaveTokens
      }
    }
    
    public GetMany(tok : IEnumerable[T]) : IEnumerable[T]
    {
      tokens.GetMany(tok)
    }
    
    public Get() : T
    {
      tokens.Get()
    }
  }
}
