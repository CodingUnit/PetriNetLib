language Cplusplus
{
  syntax module Cpp.Grammar.CppGrammar start rule Declaration;
  //syntax module Nemerle.Statechart.Grammar.Actions;
  //syntax module Nemerle.Statechart.Grammar.Base;
  //syntax module Nemerle.Statechart.Grammar.Events;
  //syntax module Nemerle.Statechart.Grammar.PseudoStates;
  //syntax module Nemerle.Statechart.Grammar.Regions;
  //syntax module Nemerle.Statechart.Grammar.Targets;
  //syntax module Nemerle.Statechart.Grammar.Transitions;
}

namespace Cpp.Grammar
{

 //using Nitra;

syntax module CppGrammar
{
  literal Less                = "<";
  literal Greater             = ">";
  literal OpenBrace           = "(";
  literal CloseBrace          = ")";
  literal OpenBrace           = "{";
  literal CloseBrace          = "}";
  literal OpenSquareBrace     = "[";
  literal CloseSquareBrace    = "]";
  literal SingleQuote         = "\'";
  literal Quote               = "\"";
  literal Semicolon           = ";";
  literal Comma               = ",";
  literal Dot                 = ".";
  literal Colon               = ":";
  literal Question            = "?";
  literal At                  = "@";
  literal AliasSeparator      = "::";
  literal Assign              = "=";
  literal Prefix              = "\\u";
  literal DodDot              = "..";
  literal Op                  = "=>", "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", "&=", "^=", "|=", "??",
                                "||", "&&", "|", "^", "&", "==", "!=", "<=", ">=", "<<", ">>", "+", "-", "!", "~", "++", "--", "*", "/", "%", "->";
  literal Backslash           = "\\";
  literal Epsilon             = "";

  regex Any = ['\u0000'..'\uFFFF'];

  [StartRule, ExplicitSpaces]
  syntax CompilationUnit = s Expression !Any;

  /////////////////////////////////////////////////////////
  // Spacing

  regex NewLineCharacter  = '\n' | '\r' | '\u2028' /*  line separator */ | '\u2029' /*  paragraph separator */;
  regex NewLine  = "\r\n" | NewLineCharacter;
  regex Whitespace = [Zs] | '\t' | '\v' | '\f' | '\uFEFF' | '\u0000';
  regex Space = Whitespace | NewLine;
  regex Spaces = Space+;

  void s   = Spaces*;                     // optional spacer
  void S   = !IdentifierPartCharacters s; // identifier break spacer

  marker i;     // increase a indent
  marker d;     // decrease a indent
  marker nl;    // optional spacer and plase for \n while pretty printing
  marker inl;   // i + nl
  marker sm;    // optional spacer and prefer to print space while pretty printing

  keyword regex ['A'..'Z', 'a'..'z', '_'..'_']+ rule S;

  regex KeywordToken =   "struct" | "class" | "case" | "switch" | "if" | "union";

  //alias Name                = Identifier;
  alias QualifiedName       = QualifiedIdentifier;
  alias Char                = Any;
  alias Comma               = ","?;

  // Spacing
  /////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////
  // Identifiers

  //[ExplicitSpaces, SuppressTrailingSpaces]
  token Identifier           = !Keyword IdentifierBody//s
  {
    token Keyword = KeywordToken !IdentifierPartCharacters;
  }

  token QualifiedIdentifier  = (Identifier; "::")+;

  regex LetterCharacter           = [Lu, Ll, Lt, Lm, Lo, Nl];//['A'..'Z', 'a'..'z', 'а'..'я', 'А'..'Я', 'і'];//
  regex CombiningCharacter        = [Mn, Mc];
  regex DecimalDigitCharacter     = [Nd];
  regex ConnectingCharacter       = [Pc];
  regex FormattingCharacter       = [Cf];

  regex IdentifierStartCharacter  = LetterCharacter | "_";
  regex IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter | CombiningCharacter | FormattingCharacter;
  regex IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;

  // Identifiers
  /////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////
  // Literals

  regex DecimalDigit                        = ['0'..'9'];
  regex HexDigit                            = ['0'..'9', 'a'..'f', 'A'..'F'];
  regex IntegerTypeSuffixTerminal           = ('U' | 'u') ('l' | 'L')? | ('l' | 'L') ('U' | 'u')?;
  regex IntegerTypeSuffix                   = IntegerTypeSuffixTerminal; // "UL" | "ul" | "uL" | "Ul" | "LU" | "lu" | "Lu" | "lU" | "U" | "u" | "L" | "l";
  regex DecimalIntegerLiteral               = DecimalDigit+ IntegerTypeSuffix?;
  regex HexadecimalIntegerLiteral           = ("0x" | "0X") HexDigit+ IntegerTypeSuffix?;
  regex IntegerLiteral                      = HexadecimalIntegerLiteral | DecimalIntegerLiteral;

  ////////////////////////////////////////////////////////////////////////////////////
  // Type

  /*syntax Type
  {
    | QualifiedTypeName = QualifiedName;

    precedence FunctionType:
    | FunctionType      = Type ^ FunctionType "(" (Type; ",")* ")";
  }*/

  ////////////////////////////////////////////////////////////////////////////////////
  // Expressions
  syntax Constant
  {
    | Int = IntegerLiteral
  }

  syntax Expression
  {
    /*| IdentifierExpression             = QualifiedName;
    | IntegerLiteralExpression         = IntegerLiteral;

    | QualifiedNameExpression          = QualifiedName; // simple-name || member-access
    | ParenthesizedExpression          = "(" Expression ")"; // parenthesized-expression
    | Cast                             = "(" Type ")" Expression;

    precedence Invocation:
    | Invocation                       = Expression ^ Invocation "(" (Expression; ",")* ")";*/
  }

  syntax Modifier
  {
    | Public    = "public"
    | Private   = "private"
    | Protected = "protected"
  }

  syntax Specifier
  {
    | Typedef  = "typedef"
    | Auto     = "auto"
    | Register = "register"
    | Static   = "static"
    | Extern   = "extern"
    | Const    = "const"
    | Volatile = "volatile"
    //| Restrict 
    | Inline   = "inline"
    | Noreturn = "noreturn"
    | Virtual  = "virtual"
  }

  syntax Type
  {
    | Void  = "void"
    | Short = "short"
    | Char  = "char"
    | Int   = "int"
    | Long  = "long"
    | UnsignedType = "unsigned" sm Type
    | SignedType = "signed" sm Type
    | Named = Name Template?
      {
        syntax Template = "<" (Name;",")* ">";
      }
  }

  syntax Statement
  {
    | Compound = Statement+
    | BraceStatement = "{" Statement "}"
    | Null = ";"
    | Decl
    | Expression
    | Return = "return" Expression? ";"
    | Break = "break" ";"
    | Continue = "continue" ";"
    | Goto = "goto" Name
    | Label = Name ":" Statement
    | Switch = "switch" "(" Expression ")" "{" SwitchCase* "}"
    {
      syntax SwitchCase
      {
        | Default = "default:" Statement
        | Case    = "case" ConstExpr ":" Statement
      }
    }
    | If = "if" "(" Expression ")" Statement Else?
    {
      syntax Else = "else" Statement;
    }
  }

  syntax Decl = Specifier* sm Type sm Decls=TreeDecl+ Init? ';'
  {
    syntax Init = '=' ConstExpr;
  }

  syntax ConstExpr
  {
    | Int  = IntegerLiteral
    | Enum = Name
    | Oper = ReadOnlyOper
  }

  syntax ReadOnlyOper
  {
    | Not    = "!" Expr=ConstExpr
    | Invert = "~" Expr=ConstExpr
    | Plus   = "+" Expr=ConstExpr
    | Minus  = "-" Expr=ConstExpr
    | Sizeof = "sizeof" "(" Expr=ConstExpr ")"
    | BinaryOper
  }

  syntax BinaryOper
  {
  }

  syntax TreeDecl
  {
	  | Id       = Name
	  | Pointer  = '*' Name
	  | Array    = Name '[' Size=IntegerLiteral? ']'
	  | FuncDecl = Specifier? sm Name '(' Parms=Parm* ')'
	  {
		  syntax Parm = Type Name?;
	  }
	//| Func
  }

  syntax InitConstExpr
  {
  }

  syntax Qualifier
  {
	  | Const = "const"
  }

  syntax SplicableMembers = "$" Name=Identifier ";";

  syntax TypeDecl
  {
	  | StructDecl
    | ClassDecl
	  | Decl
	  | Modifier = Modifier ':'
	  | Constructor = Name '(' Parms=Type* ')' nl '{' nl Body=Statement* nl '}'
	  | Destructor = '~' Name '(' ')' nl '{' nl Body=Statement* nl '}'
	  | AssignmentOp = RetType=Type sm "operator" "=" '(' Parms=Type* ')' sm Qualifier? nl '{' nl Body=Statement* nl '}' 
    | Method = Specifier? sm RetType=Type sm Name '(' Parms=Type* ')' sm Qualifier? nl '{' i nl Body=Statement* d nl '}' 
    | SplicableMembers
  }

  syntax StructTypeDecl
  {
	  | StructDecl
	  | Decl
    | SplicableMembers
  }

  syntax StructDecl = "struct" sm Name nl '{' i Body=StructTypeDecl* d nl '}' ';';

  syntax ClassDecl = "class" sm Name sm Base? nl '{' i Body=TypeDecl* d nl '}' ';'
  {
      syntax Base = ':' sm Modifier sm BaseClass=NameClass;
  }

  syntax NameClass = Name Template?
  {
    syntax Template = "<" (Name; ",")+ ">";
  }

  syntax Name
  {
    | Id                 = Identifier
    | Qualified          = QualifiedName
    //| SplicableList      = "..$" Name=Identifier
    | Splicable          = '$' Name=Identifier
    | SplicableType      = "$" "(" Name=Identifier ":" "type" ")" 
	  | SplicableQualified = '$' '(' Name=QualifiedName ')'
  }


  syntax Func = Specifier? sm RetType=Type sm Name=Identifier '(' Parms=Parm* ')' nl '{' nl Body=Statement* nl '}'
  {
	  syntax Parm = Type Name;
  }
//RetType = CType; name : CName; parms : list[CType]; body : CStatement}
  syntax QuotDecl
  {
    | TypeDecl
    //| Func
  }

  syntax QuotType = "type:" QType
  {
    syntax QType
    {
      | Type
      | TypePtr = Specifier? Type "*"
    }
  }

  syntax Declaration
  {
    | QuotDecl = "decl:" QuotDecl
    | QuotExpr = "expr:" Statement
    | QuotType 
    | Namespace = "namespace" sm Name nl '{' Declaration* nl '}'
    | TypeDecl
    | Func
    | Decl
  }
}

}